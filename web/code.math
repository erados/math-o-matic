#####################################
######## PROPOSITIONAL LOGIC ########
#####################################

"문장 타입."
base type st;

"verum (T). 즉 임의의 항진명제를 표시한다."
$\top$
st T;

"falsum (F). 즉 임의의 모순명제를 표시한다."
$\bot$
st F;

"not (FT)."
$!<prec=250><<\neg>>#1$
st N(st p);

"and (TFFF)."
$!<prec=596>#1<<\land>>#2$
st A(st p, st q);

"or (TTTF)."
$!<prec=596>#1<<\lor>>#2$
st O(st p, st q);

"implies (TFTT)."
$!<prec=598>#1<<\to>>#2$
st I(st p, st q);

"iff (TFFT)."
$!<prec=599>#1<<\leftrightarrow>>#2$
st E(st p, st q);

"함의 도입(implication introduction). conditional proof를 가능케 한다. 특정 힐베르트 체계(Hilbert system)에서는 메타정리(metatheorem)이며 이를 연역 정리(deduction theorem)라 부른다."
axiomatic schema cp(st p: @11, st q: @1r) {
	(p |- q) |- I(p, q)
}

"modus ponens. 함의 소거(implication elimination) 또는 전건 긍정이라고도 한다."
axiomatic schema mp(st p: @1, st q: @22) {
	p, I(p, q) |- q
}

"연언 도입(conjunction introduction)."
axiomatic schema Ai(st p: @1, st q: @2) {
	p, q |- A(p, q)
}

"연언 도입 2번."
schema A3i(st p: @1, st q: @2, st r: @3) {
	p, q, r |- Ai[Ai[@h1, @h2], @h3]
}

"연언 소거(conjunction elimination) 1."
axiomatic schema Ae1(st p: @11, st q: @12) {
	A(p, q) |- p
}

"연언 소거(conjunction elimination) 2."
axiomatic schema Ae2(st p: @11, st q: @12) {
	A(p, q) |- q
}

"선언 도입(disjunction introduction) 1."
axiomatic schema Oi1(st p: @1, st q) {
	p |- O(p, q)
}

"선언 도입(disjunction introduction) 2."
axiomatic schema Oi2(st p, st q: @1) {
	q |- O(p, q)
}

"선언 소거(disjunction elimination). proof by cases라고도 한다."
axiomatic schema Oe(st p: @11, st q: @12, st r: @22) {
	O(p, q), I(p, r), I(q, r) |- r
}

schema Oeu(st p: @11, st q: @12, st r: @2r) {
	O(p, q), (p |- r), (q |- r) |- Oe[
		@h1,
		cp[@h2],
		cp[@h3]
	]
}

"부정 도입(negation introduction). 귀류법(reductio ad absurdum)이라고도 한다."
axiomatic schema Ni(st p: @11) {
	I(p, F) |- N(p)
}

schema Niu(st p: @11) {
	(p |- F) |-
		Ni[cp[@h1]]
}

"부정 소거(negation elimination). 폭발률(ex falso quodlibet)이라고도 한다."
axiomatic schema Ne(st p: @1, st q) {
	p, N(p) |- q
}

"이중부정 도입(double negation introduction)."
axiomatic schema NNi(st p: @1) {
	p |- N(N(p))
}

"이중부정 소거(double negation elimination)."
axiomatic schema NNe(st p: @111) {
	N(N(p)) |- p
}

"쌍조건문 도입(biconditional introduction)."
axiomatic schema Ei(st p: @11, st q: @12) {
	I(p, q), I(q, p) |- E(p, q)
}

"Ei의 다른 버전."
schema Eiu(st p: @11, st q: @21) {
	(p |- q), (q |- p) |-
		Ei[cp[@h1], cp[@h2]]
}

"쌍조건문 소거(biconditional elimination) 1."
axiomatic schema Ee1(st p: @11, st q: @12) {
	E(p, q) |- I(p, q)
}

"쌍조건문 소거(biconditional elimination) 2."
axiomatic schema Ee2(st p: @11, st q: @12) {
	E(p, q) |- I(q, p)
}

schema A_flip(st p: @11, st q: @12) {
	A(p, q) |-
		Ai[Ae2[@h1], Ae1[@h1]]
}

schema E_flip(st p: @11, st q: @12) {
	E(p, q) |- Ei[Ee2[@h1], Ee1[@h1]]
}

schema weaken(st p: @1, st q) {
	p |- cp[
		q |- p
	]
}

schema mpE1(st p: @1, st q: @22) {
	p, E(p, q) |-
		mp[@h1, Ee1[@h2]]
}

schema mpE2(st p: @1, st q: @21) {
	p, E(q, p) |-
		mp[@h1, Ee2[@h2]]
}

"가언적 삼단논법(hypothetical syllogism)."
schema syll(st p: @11, st q: @12, st r: @22) {
	I(p, q), I(q, r) |- cp[
		p |- mp[mp[p, @h1], @h2]
	]
}

"syll을 두 번 적용한 것. 사단논법이라 해도 좋을 것이다."
schema syll4(st p: @11, st q: @21, st r: @31, st s: @32) {
	I(p, q), I(q, r), I(r, s) |-
		syll[syll[@h1, @h2], @h3]
}

"E를 위한 syll."
schema syllE(st p: @11, st q: @12, st r: @22) {
	E(p, q), E(q, r) |- Ei[
		syll[
			Ee1[@h1],
			Ee1[@h2]
		],
		syll[
			Ee2[@h2],
			Ee2[@h1]
		]
	]
}

schema syllE4(st p: @11, st q: @21, st r: @31, st s: @32) {
	E(p, q), E(q, r), E(r, s) |-
		syllE[syllE[@h1, @h2], @h3]
}

"sequent calculus의 I 규칙 같은 것. 표현형식을 바꾸는 데 쓰이고 있다."
schema id(st p) {
	p |- p
}

"[$\bot]을 도입한다. falsum introduction이라 불러도 좋을 것이다."
schema Fi(st p: @1) {
	Ne(p, F)
}

schema Fi_c(st p: @11) {
	N(p) |- cp[p |- Fi[@h2, @h1]]
}

"[$\bot]을 소거한다. falsum elimination이라 불러도 좋을 것이다. Ne와 마찬가지로 폭발률을 나타낸다 할 수 있다."
schema Fe(st p) {
	F |- NNe[Niu[N(p) |- @h1]]
}

"[$\top] 도입."
axiomatic schema Ti() {
	T
}

"후건 부정(modus tollens)."
schema mt(st p: @11, st q: @21) {
	I(p, q), N(q) |-
		Niu[p |-
			Fi[mp[@h3 ,@h1], @h2]]
}

"대우명제(contrapositive)를 유도한다."
schema contrapose(st p: @11, st q: @12) {
	I(p, q) |-
		cp[N(q) |- mt[@h1, @h2]]
}

"contrapose의 다른 버전."
schema contrapose_u(st p: @11, st q: @1r) {
	(p |- q) |- N(q) |- mp[@h2, contrapose[cp[@h1]]]
}

schema NO_to_AN(st p: @111, st q: @112) {
	N(O(p, q)) |-
		Ai[
			Niu[
				p |-
					Fi[
						Oi1(?, q)[@h2],
						@h1
					]
			],
			Niu[
				q |-
					Fi[
						Oi2(p, ?)[@h2],
						@h1
					]
			]
		]
}

schema AN_to_NO(st p: @111, st q: @121) {
	A(N(p), N(q)) |-
		Niu[O(p, q) |- Oe[
			@h2,
			Fi_c[Ae1[@h1]],
			Fi_c[Ae2[@h1]]
		]]
}

schema NA_to_ON(st p: @111, st q: @112) {
	N(A(p, q)) |-
		NNe[Niu[N(O(N(p), N(q))) |- Fi[
			Ai[
				NNe[Ae1[NO_to_AN[@h2]]],
				NNe[Ae2[NO_to_AN[@h2]]]
			],
			@h1
		]]]
}

schema ON_to_NA(st p: @111, st q: @112) {
	O(N(p), N(q)) |-
		Niu[A(p, q) |- Oeu[
			@h1,
			(N(p) |- Fi[
				Ae1[@h2], @h3
			]),
			(N(q) |- Fi[
				Ae2[@h2], @h3
			])
		]]
}

"무모순율(law of noncontradiction)."
schema lnc(st p) {
	Niu[A(p, N(p)) |- Fi[
		Ae1[@h1],
		Ae2[@h1]
	]]
}

"배중률(law of excluded middle)."
schema lxm(st p) {
	NNe[Niu[N(O(p, N(p))) |- Fi[
		Ai[
			NNe[Ae2[NO_to_AN[@h1]]],
			Ae1[NO_to_AN[@h1]]
		],
		lnc(p)
	]]]
}

schema swap(st p: @11, st q: @121, st r: @122) {
	I(p, I(q, r)) |- cp[
		q |- cp[
			p |- mp[
				@h2, mp[
					@h3, @h1
				]
			]
		]
	]
}

schema swap_c(st p, st q, st r) {
	cp[swap(p, q, r)]
}

schema swap_m(st p: @11, st q: @121, st r: @122) {
	I(p, I(q, r)), q |-
		mp[@h2, swap[@h1]]
}

schema O_flip(st p: @11, st q: @12) {
	O(p, q) |-
		Oe[
			@h1,
			cp[Oi2(q, p)],
			cp[Oi1(q, p)]
		]
}

schema OI1(st p: @11, st q: @12, st r: @22) {
	O(p, q), I(p, r) |-
		Oe[
			@h1,
			cp[p |- Oi1(?, q)[mp[p, @h2]]],
			cp[q |- Oi2(r, ?)[q]]
		]
}

schema OI2(st p: @11, st q: @12, st r: @22) {
	O(p, q), I(q, r) |-
		Oe[
			@h1,
			cp[p |- Oi1(?, r)[@h3]],
			cp[q |- Oi2(p, ?)[mp[@h3, @h2]]]
		]
}

schema OI(st p: @11, st q: @12, st r: @22, st s: @32) {
	O(p, q), I(p, r), I(q, s) |-
		OI2[OI1[@h1, @h2], @h3]
}

schema Oe1(st p: @11, st q: @12) {
	O(p, q), N(p) |-
		NNe[Niu[N(q) |- Fi[@h1, AN_to_NO[Ai[@h2, @h3]]]]]
}

schema Oe2(st p: @11, st q: @12) {
	O(p, q), N(q) |-
		NNe[Niu[N(p) |- Fi[@h1, AN_to_NO[Ai[@h3, @h2]]]]]
}

schema O1Ai(st p: @11, st q: @21, st r: @12) {
	O(p, r), O(q, r) |-
		Oe[
			lxm(r),
			cp[r |- Oi2(A(p, q), ?)[@h3]],
			cp[N(r) |- Oi1(?, r)[Ai[Oe2[@h1, @h3], Oe2[@h2, @h3]]]]
		]
}

schema O2Ai(st p: @11, st q: @12, st r: @22) {
	O(p, q), O(p, r) |- O_flip[O1Ai[
		O_flip[@h1],
		O_flip[@h2]
	]]
}

schema I_distribute_left(st p: @11, st q: @121, st r: @122) {
	I(p, I(q, r)) |-
		cp[
			I(p, q) |-
				cp[p |- mp[mp[@h3, @h2], mp[@h3, @h1]]]
		]
}

schema EOi(st p: @11, st q: @12, st r: @21, st s: @22) {
	E(p, q), E(r, s) |-
		Eiu[
			(O(p, r) |-
				Oeu[
					@h3,
					(p |- Oi1(?, s)[mpE1[@h4, @h1]]),
					(r |- Oi2(q, ?)[mpE1[@h4, @h2]])
				]),
			(O(q, s) |-
				Oeu[
					@h3,
					(q |- Oi1(?, r)[mpE2[@h4, @h1]]),
					(s |- Oi2(p, ?)[mpE2[@h4, @h2]])
				])
		]
}

schema DIpqEpApq(st p: @11, st q: @12) {
	I(p, q) |-
		Ei[
			cp[p |- Ai[@h2, mp[@h2, @h1]]],
			cp[A(p, q) |- Ae1[@h2]]
		]
}

schema Ipp(st p) {
	cp[id(p)]
}

schema Epp(st p) {
	Ei[Ipp(p), Ipp(p)]
}

#################################
######## PREDICATE LOGIC ########
#################################

"클래스 타입. 술어 논리에서 쓰인다."
type cls;

"class 하나를 받는 술어 타입."
type [cls -> st] pr;

"class 두 개를 받는 술어 타입."
type [(cls, cls) -> st] pr2;

"class 세 개를 받는 술어 타입."
type [(cls, cls, cls) -> st] pr3;

"pr 타입을 위한 A."
$\left(#1<<\land>>#2\right)$
pr Af(pr f, pr g) {
	(cls z) => { A(f(z), g(z)) }
}

"pr 타입을 위한 O."
$\left(#1<<\lor>>#2\right)$
pr Of(pr f, pr g) {
	(cls z) => { O(f(z), g(z)) }
}

"pr 타입을 위한 I."
$\left(#1<<\to>>#2\right)$
pr If(pr f, pr g) {
	(cls z) => { I(f(z), g(z)) }
}

"pr 타입을 위한 E."
$\left(#1<<\leftrightarrow>>#2\right)$
pr Ef(pr f, pr g) {
	(cls z) => { E(f(z), g(z)) }
}

"pr 타입을 위한 N."
$\left(<<\neg>>#1\right)$
pr Nf(pr f) {
	(cls z) => { N(f(z)) }
}

"pr2 타입을 위한 A."
$\left(#1<<\land>>#2\right)$
pr2 Af2(pr2 f, pr2 g) {
	(cls x, cls y) => { A(f(x, y), g(x, y)) }
}

"pr2 타입을 위한 O."
$\left(#1<<\lor>>#2\right)$
pr2 Of2(pr2 f, pr2 g) {
	(cls x, cls y) => { O(f(x, y), g(x, y)) }
}

"pr2 타입을 위한 I."
$\left(#1<<\to>>#2\right)$
pr2 If2(pr2 f, pr2 g) {
	(cls x, cls y) => { I(f(x, y), g(x, y)) }
}

"pr2 타입을 위한 E."
$\left(#1<<\leftrightarrow>>#2\right)$
pr2 Ef2(pr2 f, pr2 g) {
	(cls x, cls y) => { E(f(x, y), g(x, y)) }
}

"pr2 타입을 위한 N."
$\left(<<\neg>>#1\right)$
pr2 Nf2(pr2 f) {
	(cls x, cls y) => { N(f(x, y)) }
}

"보편 양화(universal quantification). 일반적인 표기법과는 다르게 pr을 입력으로 받는다. 또한 [*domain of discourse는 공집합일 수도 있다]."
$!<prec=249><<\forall>>#1$
st U(pr f);

"pr2를 위한 보편 양화."
$!<prec=249><<\forall^2>>#1$
st U2(pr2 f) {
	U((cls x) => {
		U((cls y) => {
			f(x, y)
		})
	})
}

"pr3을 위한 보편 양화."
$!<prec=249><<\forall^3>>#1$
st U3(pr3 f) {
	U((cls x) => {
		U((cls y) => {
			U((cls z) => {
				f(x, y, z)
			})
		})
	})
}

"존재 양화(existential quantification). 일반적인 표기법과는 다르게 pr을 입력으로 받으며 U에 의존한다. 또한 [*domain of discourse는 공집합일 수도 있다]."
$!<prec=249><<\exists>>#1$
st X(pr f) {
	N(U(Nf(f)))
}

"pr2를 위한 존재 양화. X에 의존한다."
$!<prec=249><<\exists^2>>#1$
st X2(pr2 f) {
	X((cls x) => {
		X((cls y) => { f(x, y) })
	})
}

schema NX_to_UN(pr f: @111) {
	N(X(f)) |- id(U(Nf(f)))[NNe[@h1]]
}

schema UN_to_NX(pr f: @111) {
	U(Nf(f)) |- id(N(X(f)))[NNi[@h1]]
}

"보편 양화 도입(universal introduction)."
axiomatic schema Ui(pr f: @1) {
	f |- U(f)
}

schema Ui2(pr2 f: @1) {
	f |- id(U2(f))[
		Ui[(cls x) => { Ui[(cls y) => { @h1(x, y) }] }]
	]
}

"보편 양화 소거(universal elimination)."
axiomatic schema Ue(pr f: @11, cls x) {
	U(f) |- f(x)
}

schema Ue2(pr2 f: @11, cls x, cls y) {
	U2(f) |- Ue(?, y)[Ue(?, x)[@h1]]
}

schema Ui_p(st p: @1) {
	p |- Ui((cls x) => { p })[(cls x) => { p }]
}

schema Ui_c(st p) {
	cp[Ui_p(p)]
}

"U를 위한 contrapose."
schema contrapose_U(pr f: @111, pr g: @112) {
	U(If(f, g)) |- Ui[(cls x) => {
		contrapose(f(x), g(x))[Ue(?, x)[@h1]]
	}]
}

"U를 위한 mp."
schema mpU(pr f: @11, pr g: @212) {
	U(f), U(If(f, g)) |-
		id(U(g))[Ui[(cls x) => {
			mp[Ue(?, x)[@h1], Ue(?, x)[id(U((cls x) => { I(f(x), g(x)) }))[@h2]]]
		}]]
}

"U를 위한 mt."
schema mtU(pr f: @111, pr g: @112) {
	U(If(f, g)), N(U(g)) |-
		Niu[
			U(f) |-
				Ne(?, F)[
					mpU[@h3, @h1],
					@h2
				]
		]
}

"UA의 m1형."
schema UAm1(pr f: @111, pr g: @112) {
	U(Af(f, g)) |-
		id(A(U(f), U(g)))[Ai[
			Ui[(cls x) => {
				Ae1[id(A(f(x), g(x)))[Ue(?, x)[@h1]]]
			}],
			Ui[(cls x) => {
				Ae2[id(A(f(x), g(x)))[Ue(?, x)[@h1]]]
			}]
		]]
}

"UA의 m2형."
schema UAm2(pr f: @111, pr g: @121) {
	A(U(f), U(g)) |-
		id(U(Af(f, g)))[
			Ui[(cls x) => {
				Ai[
					Ue(?, x)[Ae1[@h1]],
					Ue(?, x)[Ae2[@h1]]
				]
			}]
		]
}

"[$\forall]과 [$\land] 간의 분배법칙 같은 것."
schema UA(pr f, pr g) {
	Ei[cp[UAm1(f, g)], cp[UAm2(f, g)]]
}

"UI의 m형."
schema UIm(pr f: @111, pr g: @112) {
	U(If(f, g)) |-
		cp[U(f) |- mpU[@h2, @h1]]
}

"[$\forall]과 [$\to] 간의 분배법칙 같은 것."
schema UI(pr f, pr g) {
	cp[UIm(f, g)]
}

"U를 위한 Oi1."
schema Oi1U(pr f, pr g) {
	U(f) |-
		id(U(Of(f, g)))[
			Ui[(cls x) => {
				Oi1(?, g(x))[Ue(?, x)[@h1]]
			}]
		]
}

"U를 위한 Oi2."
schema Oi2U(pr f, pr g) {
	U(g) |-
		id(U(Of(f, g)))[
			Ui[(cls x) => {
				Oi2(f(x), ?)[Ue(?, x)[@h1]]
			}]
		]
}

schema UOm(pr f, pr g) {
	O(U(f), U(g)) |-
		Oe[
			@h1,
			cp[Oi1U(f, g)],
			cp[Oi2U(f, g)]
		]
}

schema UO(pr f, pr g) {
	cp[UOm(f, g)]
}

"UU의 m형. 재미있게도 Ui 및 Ue로부터 유도할 수 있다."
schema UUm(pr2 f: @11) {
	U2((cls x, cls y) => { f(x, y) }) |-
		id(U2((cls y, cls x) => { f(x, y) }))[Ui[(cls y) => {
			Ui[(cls x) => {
				Ue2(?, x, y)[@h1]
			}]
		}]]
}

"[$\forall x\forall y]랑 [$\forall y\forall x]가 같다는 것."
schema UU(pr2 f) {
	cp[UUm(f)]
}

schema UE_flip(pr f: @111, pr g: @112) {
	U(Ef(f, g)) |-
		id(U(Ef(g, f)))[Ui[(cls x) => {
			E_flip[id(E(f(x), g(x)))[Ue(?, x)[@h1]]]
		}]]
}

schema EiU(pr f: @111, pr g: @112) {
	U(If(f, g)), U(If(g, f)) |-
		id(U(Ef(f, g)))[Ui[(cls z) => { Ei[
			id(I(f(z), g(z)))[Ue(?, z)[@h1]],
			id(I(g(z), f(z)))[Ue(?, z)[@h2]]
		] }]]
}

"Ee1의 U형."
schema Ee1U(pr f: @111, pr g: @112) {
	U(Ef(f, g)) |-
		id(U(If(f, g)))[Ui[(cls x) => {
			Ee1[id(E(f(x), g(x)))[Ue(?, x)[@h1]]]
		}]]
}

"Ee2의 U형."
schema Ee2U(pr f: @111, pr g: @112) {
	U(Ef(f, g)) |-
		id(U(If(g, f)))[Ui[(cls x) => {
			Ee2[id(E(f(x), g(x)))[Ue(?, x)[@h1]]]
		}]]
}

schema UEe(pr f: @111, pr g: @112) {
	U(Ef(f, g)) |-
		Ei[
			UIm[Ee1U[@h1]],
			UIm[Ee2U[@h1]]
		]
}

schema syllU(pr f: @111, pr g: @112, pr h: @212) {
	U(If(f, g)), U(If(g, h)) |-
		id(U(If(f, h)))[Ui[(cls x) => { syll[
			id(I(f(x), g(x)))[Ue(?, x)[@h1]],
			id(I(g(x), h(x)))[Ue(?, x)[@h2]]
		] }]]
}

schema syllUE(pr f: @111, pr g: @112, pr h: @212) {
	U(Ef(f, g)), U(Ef(g, h)) |-
		id(U(Ef(f, h)))[Ui[(cls x) => { syllE[
			id(E(f(x), g(x)))[Ue(?, x)[@h1]],
			id(E(g(x), h(x)))[Ue(?, x)[@h2]]
		] }]]
}

"존재 양화 도입(existential introduction). Ue와 합치면 [$\forall f \vdash \exists f]가 될 것도 같으나 어떤 class x가 있어야 한다."
schema Xi(pr f, cls x: @12) {
	f(x) |-
		id(X(f))[contrapose_u[Ue(Nf(f), x)][NNi[@h1]]]
}

schema Xi2(pr2 f, cls x, cls y) {
	f(x, y) |- id(X2(f))[Xi((cls x) => {
		X((cls y) => { f(x, y) })
	}, x)[
		Xi((cls y) => { f(x, y) }, y)[@h1]
	]]
}

"X를 위한 mp."
schema mpX(pr f: @11, pr g: @212) {
	X(f), U(If(f, g)) |-
		NNe[Niu[
			N(X(g)) |- Fi[
				Ui(Nf(f))[(cls x) => {
					mt(f(x), g(x))[
						Ue(?, x)[@h2],
						Ue(?, x)[NNe[@h3]]
					]
				}],
				@h1
			]
		]]
}

"X2를 위한 mp."
schema mpX2(pr2 f: @11, pr2 g: @212) {
	X2(f), U2(If2(f, g)) |-
		NNe[Niu[N(X2(g)) |- Fi[
			Ui[(cls x) => {
				id(N(X((cls y) => {f(x, y)})))[NNi[Ui[(cls y) => {
					mt[
						Ue2(?, x, y)[id(U2((cls x, cls y) => {
							I(f(x, y), g(x, y))
						}))[@h2]],
						Ue(?, y)[NNe(U((cls y) => {N(g(x, y))}))[Ue(?, x)[NNe[@h3]]]]
					]
				}]]]
			}],
			@h1
		]]]
}

"mpX의 더 강력한 버전."
schema mpX_strong(pr f: @11, pr g: @212) {
	X(f), U(If(f, g)) |-
		mpX(?, Af(f, g))[
			@h1,
			Ui[(cls x) => {
				cp[
					f(x) |-
						Ai[
							@h3,
							mp(f(x), g(x))[@h3, Ue(?, x)[@h2]]
						]
				]
			}]
		]
}

schema mpXE(pr f, pr g) {
	X(f), U(Ef(f, g)) |-
		mpX[@h1, Ee1U[@h2]]
}

"st 타입을 위한 존재 양화 소거(existential elimination)."
schema Xe_p(st p) {
	X((cls z) => { p }) |-
		NNe[Niu[N(p) |-
			Fi[
				@h1,
				id(N(X((cls z) => { p })))[NNi[Ui_p[@h2]]]
			]]]
}

schema X2e_p(st p) {
	X2((cls x, cls y) => { p }) |-
		Xe_p(p)[Xe_p(X((cls y) => { p }))[@h1]]
}

schema mpX_Xe_p(pr f: @11, st p) {
	X(f), U(If(f, (cls z) => { p })) |-
		Xe_p(p)[mpX[@h1, @h2]]
}

schema mpX2_X2e_p(pr2 f: @11, st p) {
	X2(f), U2(If2(f, (cls x, cls y) => { p })) |-
		X2e_p(p)[mpX2[@h1, @h2]]
}

schema XOm1(pr f: @111, pr g: @112) {
	X(Of(f, g)) |-
		NNe[Niu[N(O(X(f), X(g))) |-
			$noan = NO_to_AN[@h2];
			
			$foo = UAm2[Ai[
				NX_to_UN[Ae1[$noan]],
				NX_to_UN[Ae2[$noan]]
			]];
			
			Fi[@h1, id(N(X(Of(f, g))))[NNi[Ui[(cls x) => {
				AN_to_NO[id(A(N(f(x)), N(g(x))))[Ue(?, x)[$foo]]]
			}]]]]]]
}

schema XOm2(pr f: @111, pr g: @121) {
	O(X(f), X(g)) |-
		NNe[Niu[N(X(Of(f, g))) |-
			$foo = NNe[@h2];
			
			$1 = UAm1(Nf(f), Nf(g))[Ui[(cls x) => {
				NO_to_AN[id(N(O(f(x), g(x))))[Ue(?, x)[$foo]]]
			}]];
			
			Fi[@h1, AN_to_NO[Ai[
				UN_to_NX[Ae1[$1]],
				UN_to_NX[Ae2[$1]]
			]]]
		]]
}
"[$\exists]과 [$\lor] 간의 분배법칙 같은 것. UA로부터 증명할 수 있다."
schema XO(pr f, pr g) {
	Eiu[XOm1(f, g), XOm2(f, g)]
}

schema ON_to_NA_U(pr f, pr g) {
	U(Of(Nf(f), Nf(g))) |-
		Ui[(cls x) => {
			ON_to_NA(f(x), g(x))[Ue(?, x)[@h1]]
		}]
}

schema XAe(pr f: @111, pr g: @112) {
	X(Af(f, g)) |- id(A(X(f), X(g)))[
		NO_to_AN[mp[
			contrapose_u[ON_to_NA_U(f, g)][@h1],
			contrapose[UO(Nf(f), Nf(g))]
		]]
	]
}

schema XAe1(pr f: @111, pr g: @112) {
	X(Af(f, g)) |-
		Ae1[XAe[@h1]]
}

schema XAe2(pr f: @111, pr g: @112) {
	X(Af(f, g)) |-
		Ae2[XAe[@h1]]
}

schema X2Ae(pr2 f, pr2 g) {
	X2(Af2(f, g)) |-
		Ai[
			mpX2[
				@h1,
				id(U2(If2(Af2(f, g), f)))[Ui2[(cls x, cls y) => {
					cp[A(f(x, y), g(x, y)) |-
						Ae1[@h2]]
				}]]
			],
			mpX2[
				@h1,
				id(U2(If2(Af2(f, g), g)))[Ui2[(cls x, cls y) => {
					cp[A(f(x, y), g(x, y)) |-
						Ae2[@h2]]
				}]]
			]
		]
}

schema X2Ae1(pr2 f: @111, pr2 g: @112) {
	X2(Af2(f, g)) |-
		Ae1[X2Ae(f, g)[@h1]]
}

schema X2Ae2(pr2 f: @111, pr2 g: @112) {
	X2(Af2(f, g)) |-
		Ae2[X2Ae(f, g)[@h1]]
}

schema mpUE(pr f, pr g) {
	U(f), U(Ef(f, g)) |-
		mpU[@h1, Ee1U[@h2]]
}

############################
######## SET THEORY ########
############################

"집합론에서 정의하는 [$\in] 관계."
$!<prec=450>#1<<\in>>#2$
st in(cls x, cls y);

$\left(\cdot<<\in>>#1\right)$
pr is_in(cls y) {
	(cls x) => {in(x, y)}
}

$\left(#1<<\in>>\cdot\right)$
pr contains(cls x) {
	(cls y) => {in(x, y)}
}

"[$\notin]."
$!<prec=450>#1<<\notin>>#2$
st Nin(cls x, cls y) {
	N(in(x, y))
}

"[$\subseteq]."
$!<prec=350>#1<<\subseteq>>#2$
st subseteq(cls x, cls y) {
	U((cls z) => {
		I(
			in(z, x),
			in(z, y)
		)
	})
}

"[$=]. [$\in]에 의존한다."
$!<prec=350>#1<<=>>#2$
st eq(cls x, cls y) {
	A(
		U((cls z) => {
			E(in(z, x), in(z, y))
		}),
		U((cls w) => {
			E(in(x, w), in(y, w))
		})
	)
}

"[$\neq]."
$!<prec=350>#1<<\neq>>#2$
st neq(cls x, cls y) {
	N(eq(x, y))
}

"어떤 class 내에서의 forall."
$!<prec=249><<\forall>>_{\in #1}#2$
st Uin(cls a, pr f) {
	U((cls z) => {
		I(
			in(z, a),
			f(z)
		)
	})
}

schema UinA_i(pr f: @12, pr g: @22, cls x: @11) {
	Uin(x, f), Uin(x, g) |-
		id(Uin(x, Af(f, g)))[Ui[(cls z) => { cp[in(z, x) |-
			Ai[mp[@h3, Ue(?, z)[@h1]], mp[@h3, Ue(?, z)[@h2]]]]
		}]]
}

schema Uin_subset(cls a: @12, cls b: @11, pr f: @22) {
	subseteq(a, b), Uin(b, f) |-
		id(Uin(a, f))[syllU(is_in(a), is_in(b), f)[@h1, @h2]]
}

schema UUin_to_UinU(cls a, pr2 f) {
	U((cls z) => {
		Uin(a, (cls w) => {f(z, w)})
	}) |-
		id(Uin(a, (cls w) => {
			U((cls z) => {f(z, w)})
		}))[Ui[(cls w) => { cp[in(w, a) |-
			Ui[(cls z) => {
				mp[@h2, Ue(?, w)[Ue(?, z)[@h1]]]
			}]] }]]
}

"어떤 class 내에서의 exists. Uin과 달리 and로 연결된다."
$!<prec=249><<\exists>>_{\in #1}#2$
st Xin(cls a, pr f) {
	X((cls z) => {
		A(
			in(z, a),
			f(z)
		)
	})
}

"어떤 class가 집합이라는 것. 어떤 class의 원소면 된다. 독일어 [*Menge] (집합)의 M이다."
$\left(<<\operatorname{\mathfrak M}>> #1\right)$
st set(cls x) {
	X((cls y) => {
		in(x, y)
	})
}

"set을 도입한다."
schema set_i(cls x: @11, cls y: @12) {
	in(x, y) |-
		id(set(x))[Xi(contains(x), y)[@h1]]
}

schema set_i_A(cls x, cls y, cls z) {
	A(in(z, x), in(z, y)) |-
		set_i[Ae1[@h1]]
}

schema set_i_O(cls x, cls y, cls z) {
	O(in(z, x), in(z, y)) |-
		Oe[
			@h1,
			cp[set_i(z, x)],
			cp[set_i(z, y)]
		]
}

schema eq_Ae1(cls x: @11, cls y: @12) {
	eq(x, y) |- Ae1[@h1]
}

schema eq_Ae1_Ue(cls x, cls y, cls z) {
	eq(x, y) |- Ue(?, z)[eq_Ae1(x, y)[@h1]]
}

schema eq_Ae1_Ue_Ee1(cls x, cls y, cls z) {
	eq(x, y) |- Ee1[eq_Ae1_Ue(x, y, z)[@h1]]
}

schema eq_Ae1_Ue_Ee2(cls x, cls y, cls z) {
	eq(x, y) |- Ee2[eq_Ae1_Ue(x, y, z)[@h1]]
}

schema in_subseteq(cls x: @12, cls y: @22, cls z: @11) {
	in(z, x), subseteq(x, y) |-
		mp[
			@h1,
			Ue(?, z)[@h2]
		]
}

schema self_subseteq_self(cls x) {
	id(subseteq(x, x))[Ui[(cls z) => {
		cp[in(z, x) |- @h1]
	}]]
}

schema eq_Ae2(cls x: @11, cls y: @12) {
	eq(x, y) |- Ae2[@h1]
}

schema eq_Ae2_Ue(cls x, cls y, cls w) {
	eq(x, y) |- Ue(?, w)[eq_Ae2(x, y)[@h1]]
}

schema eq_Ae2_Ue_Ee1(cls x, cls y, cls w) {
	eq(x, y) |- Ee1[eq_Ae2_Ue(x, y, w)[@h1]]
}

schema eq_Ae2_Ue_Ee1_c(cls x, cls y, cls z) {
	cp[eq_Ae2_Ue_Ee1(x, y, z)]
}

schema eq_Ae2_Ue_Ee2(cls x, cls y, cls z) {
	eq(x, y) |- Ee2[eq_Ae2_Ue(x, y, z)[@h1]]
}

schema in_eq_left_1(cls x: @11, cls y: @22, cls z: @12) {
	in(x, z), eq(x, y) |-
		mp[
			@h1,
			eq_Ae2_Ue_Ee1(x, y, z)[
				@h2
			]
		]
}

schema in_eq_left_2(cls x: @21, cls y: @22, cls z: @12) {
	in(y, z), eq(x, y) |-
		mp[
			@h1,
			eq_Ae2_Ue_Ee2(x, y, z)[
				@h2
			]
		]
}

schema in_eq_right_1(cls x: @12, cls y: @22, cls z: @11) {
	in(z, x), eq(x, y) |-
		mp[
			@h1,
			eq_Ae1_Ue_Ee1(x, y, z)[
				@h2
			]
		]
}

schema in_eq_right_2(cls x: @21, cls y: @22, cls z: @11) {
	in(z, y), eq(x, y) |-
		mp[
			@h1,
			eq_Ae1_Ue_Ee2(x, y, z)[
				@h2
			]
		]
}

schema swapU(pr f, pr g, pr h) {
	U(If(f, If(g, h))) |-
		id(U(If(g, If(f, h))))[Ui[(cls x) => {
			swap[id(I(f(x), I(g(x), h(x))))[Ue(?, x)[@h1]]]
		}]]
}

schema swapU_c(pr f, pr g, pr h) {
	cp[swapU(f, g, h)]
}

schema swapU2(pr2 f, pr2 g, pr2 h) {
	U2(If2(f, If2(g, h))) |-
		id(U2(If2(g, If2(f, h))))[Ui2[(cls x, cls y) => {
			swap(f(x, y), g(x, y), h(x, y))[Ue2(?, x, y)[@h1]]
		}]]
}

schema swapU2_c(pr2 f, pr2 g, pr2 h) {
	cp[swapU2(f ,g, h)]
}

schema eq_Ae2_Ue_Ee1_c_swap(cls x, cls y, cls z) {
	swap[eq_Ae2_Ue_Ee1_c(x, y, z)]
}

schema eq_reflexive(cls x) {
	id(eq(x, x))[Ai[
		Ui[(cls z) => {
			Epp(in(z, x))
		}],
		Ui[(cls w) => {
			Epp(in(x, w))
		}]
	]]
}

schema eq_symmetric(cls x: @11, cls y: @12) {
	eq(x, y) |-
		id(eq(y, x))[Ai[
			UE_flip(is_in(x), is_in(y))[Ae1[@h1]],
			UE_flip(contains(x), contains(y))[Ae2[@h1]]
		]]
}

schema eq_transitive(cls x: @11, cls y: @12, cls z: @22) {
	eq(x, y), eq(y, z) |-
		id(eq(x, z))[
			Ai[
				syllUE(
					is_in(x), is_in(y), is_in(z)
				)[Ae1[@h1], Ae1[@h2]],
				syllUE(
					contains(x), contains(y), contains(z)
				)[Ae2[@h1], Ae2[@h2]]
			]
		]
}

schema eq_transitive_3(cls x: @11, cls y: @12, cls z: @22) {
	eq(x, y), eq(y, z) |- eq_symmetric[eq_transitive[@h1, @h2]]
}

schema eq_transitive_2(cls x: @11, cls y: @12, cls z: @21) {
	eq(x, y), eq(z, y) |- eq_transitive[@h1, eq_symmetric[@h2]]
}

schema eq_transitive_23(cls x: @11, cls y: @12, cls z: @21) {
	eq(x, y), eq(z, y) |- eq_symmetric[eq_transitive[@h1, eq_symmetric[@h2]]]
}

schema eq_transitive_1(cls x: @12, cls y: @11, cls z: @22) {
	eq(y, x), eq(y, z) |- eq_transitive[eq_symmetric[@h1], @h2]
}

schema eq_transitive_13(cls x: @12, cls y: @11, cls z: @22) {
	eq(y, x), eq(y, z) |- eq_symmetric[eq_transitive[eq_symmetric[@h1], @h2]]
}

schema eq_transitive_El(cls x: @11, cls y: @12, cls z) {
	eq(x, y) |-
		Eiu[
			(eq(z, x) |- eq_transitive[@h2, @h1]),
			(eq(z, y) |- eq_transitive_23[@h1, @h2])
		]
}

schema eq_transitive_Er(cls x: @11, cls y: @12, cls z) {
	eq(x, y) |-
		Ei[
			cp[eq(x, z) |- eq_transitive_1[@h1, @h2]],
			cp[eq(y, z) |- eq_transitive[@h1, @h2]]
		]
}

"[$f]를 만족하는 것들이 서로 같다."
$!<prec=249><<\exists_{\leq 1}>>#1$
st Q(pr f) {
	U2((cls x, cls y) => {
		I(
			A(f(x), f(y)),
			eq(x, y)
		)
	})
}

"유일 존재 양화(unique existential quantification)."
$!<prec=249><<\exists!>>#1$
st Xq(pr f) {
	A(X(f), Q(f))
}

schema XQ_to_Xq(pr f: @11) {
	X(f), Q(f) |- id(Xq(f))[Ai[@h1, @h2]]
}

schema set_is_set_1(cls x: @11, cls y: @22) {
	set(x), eq(x, y) |-
		id(set(y))[mpXE(contains(x), contains(y))[@h1, eq_Ae2[@h2]]]
}

schema set_is_set_2(cls x: @11, cls y: @21) {
	set(x), eq(y, x) |-
		set_is_set_1[@h1, eq_symmetric[@h2]]
}

schema subseteq_subseteq(cls x: @11, cls y: @12, cls z: @22) {
	subseteq(x, y), subseteq(y, z) |-
		id(subseteq(x, z))[syllU(is_in(x), is_in(y), is_in(z))[@h1, @h2]]
}

"axiom of extensionality."
axiomatic schema ax_extensional() {
	U2((cls x, cls y) => {
		I(
			U((cls z) => {
				E(
					in(z, x),
					in(z, y)
				)
			}),
			eq(x, y)
		)
	})
}

schema ax_extensional_m(cls x, cls y) {
	U((cls z) => {E(in(z, x), in(z, y))}) |-
		mp[@h1, Ue2(?, x, y)[ax_extensional()]]
}

schema eq_simple(cls x, cls y) {
	Eiu[
		eq_Ae1(x, y),
		ax_extensional_m(x, y)
	]
}

schema eq_to_subseteq_1(cls x: @11, cls y: @12) {
	eq(x, y) |-
		id(subseteq(x, y))[Ee1U(is_in(x), is_in(y))[mp[@h1, Ee1[eq_simple(x, y)]]]]
}

schema eq_to_subseteq_2(cls x: @11, cls y: @12) {
	eq(x, y) |-
		eq_to_subseteq_1[eq_symmetric[@h1]]
}

schema subseteq_to_eq(cls x: @11, cls y: @12) {
	subseteq(x, y), subseteq(y, x) |-
		ax_extensional_m(x, y)[EiU(is_in(x), is_in(y))[@h1, @h2]]
}

schema eq_subseteq(cls x, cls y, cls z) {
	eq(x, y), subseteq(y, z) |-
		subseteq_subseteq[eq_to_subseteq_1[@h1], @h2]
}

schema subseteq_eq(cls x, cls y, cls z) {
	subseteq(x, y), eq(y, z) |-
		subseteq_subseteq[@h1, eq_to_subseteq_1[@h2]]
}

"술어를 만족하는 set들의 class를 만든다. 일반적으로는 [$\{z: f(z)\}]라고 쓰는 것이다."
$\left\{<<:>>#1\right\}$
cls setbuilder(pr f);

"술어를 만족하는 집합 [$z]에 대해 [$f(z)]를 포함하는 클래스를 만든다. 일반적으로 [$\{f(z): g(z)\}]라고 쓰는 것이다."
$\left\{#1<<:>>#2\right\}$
cls setbuilder2([cls -> cls] f, pr g) {
	setbuilder((cls w) => {
		X((cls z) => {
			A(
				eq(w, f(z)),
				g(z)
			)
		})
	})
}

"setbuilder의 defining property. f를 만족하는 임의의 [**집합]의 class를 만들게 해 준다. `[Pinter]`에서는 axiom of class construction이라 부르는 것 같다."
axiomatic schema setbuilder_def(pr f) {
	U((cls w) => {
		E(
			in(w, setbuilder(f)),
			A(set(w), f(w))
		)
	})
}

schema setbuilder_def_Ue(pr f, cls z) {
	Ue((cls w) => {
		E(in(w, setbuilder(f)), A(set(w), f(w)))
	}, z)[setbuilder_def(f)]
}

"setbuilder를 소거한다."
schema setbuilder_e(pr f: @121, cls z: @11) {
	in(z, setbuilder(f)) |-
		Ae2[mp[
			@h1,
			Ee1[setbuilder_def_Ue(f, z)]
		]]
}

schema setbuilder_ec(pr f, cls z) {
	cp[setbuilder_e(f, z)]
}

"setbuilder를 도입한다."
schema setbuilder_i(pr f, cls z: @11) {
	set(z), f(z) |-
		mp[
			Ai[@h1, @h2],
			Ee2[setbuilder_def_Ue(f, z)]
		]
}

schema setbuilder_subseteq_i(pr f: @111, pr g: @112) {
	U(If(f, g)) |-
		id(subseteq(setbuilder(f), setbuilder(g)))[
			Ui[(cls z) => { cp[in(z, setbuilder(f)) |- setbuilder_i(g, z)[
				set_i[@h2],
				mp[setbuilder_e[@h2], id(I(f(z), g(z)))[Ue(?, z)[@h1]]]
			]] }]
		]
}

schema setbuilder_subseteq_e(pr f: @211, pr g: @221, cls z: @11) {
	set(z), subseteq(setbuilder(f), setbuilder(g)) |-
		cp[f(z) |-
			setbuilder_e[in_subseteq[setbuilder_i(f, z)[@h1, @h3], @h2]]]
}

schema setbuilder_eq_i(pr f: @111, pr g: @112) {
	U(Ef(f, g)) |-
		ax_extensional_m(setbuilder(f), setbuilder(g))[
			EiU(is_in(setbuilder(f)), is_in(setbuilder(g)))[
				setbuilder_subseteq_i[Ee1U[@h1]], setbuilder_subseteq_i[Ee2U[@h1]]
			]
		]
}

schema setbuilder_eq_e(pr f: @211, pr g: @221, cls z: @11) {
	set(z), eq(setbuilder(f), setbuilder(g)) |-
		Ei[
			setbuilder_subseteq_e[@h1, eq_to_subseteq_1[@h2]],
			setbuilder_subseteq_e[@h1, eq_to_subseteq_2[@h2]]
		]
}

schema setbuilder_ia(pr f, cls z: @111) {
	A(set(z), f(z)) |-
		mp[
			@h1,
			Ee2[setbuilder_def_Ue(f, z)]
		]
}

schema setbuilder_def_set(pr f, cls x: @111) {
	I(f(x), set(x)) |-
		Ei[
			cp[
				in(x, setbuilder(f)) |-
					Ae2[mp[
						@h2,
						Ee1[Ue(?, x)[setbuilder_def(f)]]
					]]
			],
			cp[
				f(x) |-
					mp[
						Ai[
							mp[@h2, @h1],
							@h2
						],
						Ee2[Ue(?, x)[setbuilder_def(f)]]
					]
			]
		]
}

schema setbuilder_def_set_2(pr f, cls x) {
	set(x) |- setbuilder_def_set(f, x)[
		weaken(?, f(x))[@h1]
	]
}

"교집합."
$!<prec=300>#1<<\cap>>#2$
cls cap(cls x, cls y) {
	setbuilder((cls z) => {
		A(in(z, x), in(z, y))
	})
}

schema set_i_A_c(cls x, cls y, cls z) {
	cp[set_i_A(x, y, z)]
}

schema cap_def(cls x, cls y, cls z) {
	id(E(in(z, cap(x, y)), A(in(z, x), in(z, y))))[
		setbuilder_def_set((cls z) => {
			A(in(z, x), in(z, y))
		}, z)[set_i_A_c(x, y, z)]
	]
}

schema cap_i(cls x: @112, cls y: @122, cls z: @111) {
	A(in(z, x), in(z, y)) |-
		mp[@h1, Ee2[cap_def(x, y, z)]]
}

schema cap_e(cls x: @121, cls y: @122, cls z: @11) {
	in(z, cap(x, y)) |-
		mp[@h1, Ee1[cap_def(x, y, z)]]
}

schema cap_def_vi(cls x, cls y) {
	Ui[(cls z) => { cap_def(x, y, z) }]
}

schema cap_commutative_0(cls x: @121, cls y: @122, cls z: @11) {
	in(z, cap(x, y)) |-
		cap_i[A_flip[cap_e[@h1]]]
}

schema cap_commutative_1(cls x, cls y, cls z) {
	Eiu[cap_commutative_0(x, y, z), cap_commutative_0(y, x, z)]
}

schema cap_commutative_2(cls x, cls y) {
	ax_extensional_m(
		cap(x, y),
		cap(y, x)
	)[Ui((cls z) => {
		E(in(z, cap(x, y)), in(z, cap(y, x)))
	})[(cls z) => { cap_commutative_1(x, y, z) }]]
}

"합집합."
$!<prec=300>#1<<\cup>>#2$
cls cup(cls x, cls y) {
	setbuilder((cls z) => {
		O(in(z, x), in(z, y))
	})
}

schema cup_i1(cls x: @12, cls y, cls z: @11) {
	in(z, x) |-
		id(in(z, cup(x, y)))[setbuilder_i((cls z) => {O(in(z, x), in(z, y))}, ?)[
			set_i[@h1],
			Oi1(?, in(z, y))[@h1]
		]]
}

schema cup_i2(cls x, cls y: @12, cls z: @11) {
	in(z, y) |-
		id(in(z, cup(x, y)))[setbuilder_i((cls z) => {O(in(z, x), in(z, y))}, ?)[
			set_i[@h1],
			Oi2(in(z, x), ?)[@h1]
		]]
}

"합집합을 도입한다."
schema cup_i(cls x: @112, cls y: @122, cls z: @111) {
	O(in(z, x), in(z, y)) |-
		Oe[
			@h1,
			cp[cup_i1(x, y, z)],
			cp[cup_i2(x, y, z)]
		]
}

schema cup_e(cls x: @121, cls y: @122, cls z: @11) {
	in(z, cup(x, y)) |-
		setbuilder_e[@h1]
}

schema cup_is_bigger_1(cls x, cls y) {
	id(subseteq(x, cup(x, y)))[Ui[(cls z) => {cp[in(z, x) |- cup_i[Oi1(?, in(z, y))[@h1]]]}]]
}

schema cup_is_bigger_2(cls x, cls y) {
	id(subseteq(y, cup(x, y)))[Ui[(cls z) => {cp[in(z, y) |- cup_i[Oi2(in(z, x), ?)[@h1]]]}]]
}

schema cup_eq_i(cls x: @11, cls y: @12, cls u: @21, cls v: @22) {
	$foo = (cls x, cls y, cls u, cls v, cls z) => {
		eq(x, y), eq(u, v) |-
			cp[in(z, cup(x, u)) |-
				id(in(z, cup(y, v)))[setbuilder_i((cls z) => { O(in(z, y), in(z, v)) }, z)[
					set_i[@h3],
					Oeu[
						setbuilder_e[@h3],
						(in(z, x) |- Oi1(?, in(z, v))[in_eq_right_1[@h4, @h1]]),
						(in(z, u) |- Oi2(in(z, y), ?)[in_eq_right_1[@h4, @h2]])
					]
				]]]
	};
	
	eq(x, y), eq(u, v) |-
		ax_extensional_m(cup(x, u), cup(y, v))[Ui[(cls z) => {
			Ei[$foo(x, y, u, v, z)[@h1, @h2], $foo(y, x, v, u, z)[eq_symmetric[@h1], eq_symmetric[@h2]]]
		}]]
}

"일반화된 교집합."
$<<\bigcap>>#1$
cls bigcap($A$ cls a) {
	setbuilder((cls z) => {
		Uin(a, (cls x) => {
			in(z, x)
		})
	})
}

"일반화된 합집합."
$<<\bigcup>>#1$
cls bigcup($A$ cls a) {
	setbuilder((cls z) => {
		Xin(a, (cls x) => {
			in(z, x)
		})
	})
}

schema bigcap_i($A$ cls a, cls z) {
	set(z), Uin(a, (cls x) => {
		in(z, x)
	}) |-
		id(in(z, bigcap(a)))[setbuilder_i((cls z) => {
			Uin(a, (cls x) => {
				in(z, x)
			})
		}, z)[@h1, @h2]]
}

schema bigcap_e($A$ cls a, cls z) {
	in(z, bigcap(a)) |-
		setbuilder_e((cls z) => {
				Uin(a, (cls x) => {
					in(z, x)
				})
			}, z)[@h1]
}

schema bigcup_i($A$ cls a: @12, cls x: @11, cls z: @21) {
	in(x, a), in(z, x) |-
		id(in(z, bigcup(a)))[setbuilder_i((cls z) => {
			X((cls w) => {
				A(in(w, a), in(z, w))
			})
		}, z)[
			set_i[@h2],
			Xi((cls w) => {
				A(in(w, a), in(z, w))
			}, x)[Ai[@h1, @h2]]
		]]
}

schema bigcap_is_smaller($A$ cls a: @12, cls x: @11) {
	in(x, a) |-
		id(subseteq(bigcap(a), x))[Ui[(cls z) => {
			cp[
				in(z, bigcap(a)) |-
					mp[
						@h1,
						Ue(?, x)[bigcap_e(a, z)[@h2]]
					]
			]
		}]]
}

schema setbuilder_is_setbuilder(pr f: @121, cls x: @11) {
	eq(x, setbuilder(f)) |-
		id(U((cls z) => {
			E(in(z, x), A(set(z), f(z)))
		}))[syllUE(
			is_in(x),
			is_in(setbuilder(f)),
			(cls z) => {A(set(z), f(z))}
		)[eq_Ae1[@h1], setbuilder_def(f)]]
}

"술어와 집합으로부터 술어를 만족하는 집합의 부분집합을 만든다.
일반적으로는 [$\{z \in x: f(z)\}]라고 쓰는 것이다."
$\left\{\in #1<<:>>#2\right\}$
cls subsetbuilder(cls x, pr f) {
	setbuilder((cls y) => {
		A(
			in(y, x),
			f(y)
		)
	})
}

"axiom schema of specification. 어떤 집합에서 임의 술어를 만족시키는 원소들의 class를 만들었을 때 이 class가 집합이라는 뜻이다."
axiomatic schema ax_specify(pr f) {
	U((cls x) => {
		I(
			set(x),
			set(subsetbuilder(x, f))
		)
	})
}

schema ax_specify_m(pr f, cls x: @11) {
	set(x) |- mp[@h1, Ue(?, x)[ax_specify(f)]]
}

schema cap_is_set_1(cls x, cls y) {
	set(x) |- id(set(cap(x, y)))[ax_specify_m(is_in(y), ?)[@h1]]
}

schema cap_is_set_2(cls x, cls y) {
	set(y) |- set_is_set_1[
		cap_is_set_1(y, x)[@h1],
		cap_commutative_2(y, x)
	]
}

"axiom of union."
axiomatic schema ax_bigcup() {
	U(($A$ cls a) => {
		I(set(a), set(bigcup(a)))
	})
}

schema ax_bigcup_m($A$ cls a) {
	set(a) |-
		mp[
			@h1,
			Ue(?, a)[ax_bigcup()]
		]
}

schema subset_cap_is_subset(cls x: @11, cls y: @12) {
	subseteq(x, y) |-
		ax_extensional_m(x, cap(x, y))[
			Ui[(cls z) => {
				syllE[
					DIpqEpApq[Ue(?, z)[@h1]],
					E_flip[cap_def(x, y, z)]
				]
			}]
		]
}

schema subset_is_set(cls x: @21, cls y: @22) {
	set(y), subseteq(x, y) |-
		set_is_set_2[cap_is_set_2(x, y)[@h1], subset_cap_is_subset[@h2]]
}

schema supset_is_not_set(cls x: @111, cls y: @22) {
	N(set(x)), subseteq(x, y) |-
		Niu[set(y) |- Fi[subset_is_set[@h3, @h2], @h1]]
}

"empty class."
$<<\varnothing>>$
cls emptyset() {
	setbuilder((cls z) => { F })
}

"axiom of empty set."
axiomatic schema ax_emptyset() {
	set(emptyset())
}

"emptyset의 defining property."
schema emptyset_def(cls z) {
	id(Nin(z, emptyset()))[Niu[in(z, emptyset()) |-
		setbuilder_e[@h1]]]
}

"universal class."
$<<V>>$
cls universe() {
	setbuilder((cls z) => { T })
}

schema universe_in_i(cls x: @11) {
	set(x) |-
		id(in(x, universe()))[setbuilder_i((cls z) => {T}, x)[@h1, Ti()]]
}

schema universe_subseteq_i($X$ cls x) {
	id(subseteq(x, universe()))[Ui[(cls z) => {cp[in(z, x) |- universe_in_i[set_i[@h1]]]}]]
}

schema cup_universe_is_universe($X$ cls x) {
	subseteq_to_eq[
		id(subseteq(cup(x, universe()), universe()))[
			Ui[(cls z) => {cp[in(z, cup(x, universe())) |-
				universe_in_i[set_i[@h1]]]}]
		],
		cup_is_bigger_2(x, universe())
	]
}

schema universe_cup_is_universe($X$ cls x) {
	subseteq_to_eq[
		id(subseteq(cup(universe(), x), universe()))[
			Ui[(cls z) => {cp[in(z, cup(universe(), x)) |-
				universe_in_i[set_i[@h1]]]}]
		],
		cup_is_bigger_1(universe(), x)
	]
}

"러셀 집합. 사실 집합이 아니라 proper class이다."
cls russell_set() {
	setbuilder((cls z) => {
		Nin(z, z)
	})
}

"러셀 집합은 집합이 아니다."
schema russell_set_is_not_set() {
	Niu[set(russell_set()) |-
		$russell_in_russell = NNe[Niu[Nin(russell_set(), russell_set()) |-
			Fi[
				id(in(russell_set(), russell_set()))[setbuilder_i((cls z) => {
					Nin(z, z)
				}, ?)[
					@h1,
					@h2
				]],
				@h2
			]]];

		Fi[$russell_in_russell, setbuilder_e[$russell_in_russell]]
	]
}

"전체집합은 집합이 아니다."
schema universe_is_not_set() {
	supset_is_not_set[russell_set_is_not_set(), universe_subseteq_i(russell_set())]
}

"싱글턴 클래스. [$x]가 집합일 때는 일반적인 정의와 같이 [$x]만을 원소로 갖는 클래스를 만들고, [$x]가 고유 클래스(proper class)일 경우는 전체집합 [$V]가 된다.

클래스 개념이 있는 집합론에서 고유 클래스는 정의에 의해 어떤 클래스의 원소가 될 수 없으므로 고유 클래스로는 싱글턴 클래스를 만들 수 없다. 그러나 우리의 체계에서는 고유 클래스에 대해서도 singleton을 호출할 수 있다. 그러나 만들어지는 클래스는 원소의 개수가 1이 아니게 되므로 싱글턴이 되지는 않는다.

만약 [$\{x\} = \{z: z=x\}]로 정의한다면 [$x]가 고유 클래스일 때 [$\{x\}]가 조용히 공집합이 되는데, 이는 공집합 공리에 의해 집합이 된다. 그러므로 순서쌍이 Kuratowski의 정의에 따라 [$(x, y) = \{\{x\}, \{x, y\}\}]와 같이 정의될 때, 이주 지저분한 이유에 의해서 [$(x, y)\in A\times B]이어도 [$y\in B]임을 유도할 수 없는 등의 문제가 있었다. 이때 [$\{x, y\} = \{x\}\cup\{y\}]이다.

그러므로 조용히 공집합이 되는 것보다 마치 에러를 던지듯 [$V]가 되는 것이 낫다고 판단하였다. 이는 [~http://www.qedeq.org/current/doc/math/qedeq_set_theory_v1_en.pdf]의 Definition 11과 같은 방식의 정의이다. 집합에 대해서만 잘 정의되는 개념을 고유 클래스에 적용하면 고유 클래스가 만들어지는 패턴을 일반적으로 적용하면 될 듯하다.

이 정의가 도입되는 과정은 [~(href=https://github.com/logico-philosophical/math-o-matic/issues/8)이슈 #8]에 기록되어 있다."
$\left\{#1\right\}{}^{<<\scriptscriptstyle\dag>>}$
cls singleton(cls x) {
	setbuilder((cls z) => {
		O(N(set(x)), eq(z, x))
	})
}

st is_singleton(cls x) {
	Xq(is_in(x))
}

schema self_in_singleton(cls x: @11) {
	set(x) |-
		id(in(x, singleton(x)))[
			setbuilder_i((cls z) => {
				O(N(set(x)), eq(z, x))
			}, x)[
				@h1,
				Oi2(N(set(x)), ?)[eq_reflexive(x)]
			]
		]
}

schema singleton_Q(cls x) {
	set(x) |-
		id(Q(is_in(singleton(x))))[Ui2[(cls y, cls z) => {
			cp[A(in(y, singleton(x)), in(z, singleton(x))) |-
				eq_transitive_2[Oe1[setbuilder_e[Ae1[@h2]], NNi[@h1]], Oe1[setbuilder_e[Ae2[@h2]], NNi[@h1]]]
		] }]]
}

schema singleton_is_singleton(cls x) {
	set(x) |-
		id(is_singleton(singleton(x)))[
			Ai[Xi(is_in(singleton(x)), x)[self_in_singleton[@h1]], singleton_Q(x)[@h1]]
		]
}

schema singleton_eq_i(cls x: @11, cls y: @12) {
	$foo = (cls x, cls y, cls z) => {
		eq(x, y) |-
			cp[O(N(set(x)), eq(z, x)) |-
				$c1 = N(set(x)) |-
					Oi1(?, eq(z, y))[Niu[set(y) |-
						Fi[set_is_set_2[@h4, @h1], @h3]]];

				$c2 = eq(z, x) |-
					Oi2(N(set(y)), ?)[eq_transitive[@h3, @h1]];

				Oeu[@h2, $c1, $c2]]
	};
	
	eq(x, y) |-
		id(eq(singleton(x), singleton(y)))[setbuilder_eq_i(
			(cls z) => {O(N(set(x)), eq(z, x))},
			(cls z) => {O(N(set(y)), eq(z, y))}
		)[Ui[(cls z) => { Ei[$foo(x, y, z)[@h1], $foo(y, x, z)[eq_symmetric[@h1]]] }]]]
}

schema singleton_eq_e(cls x: @11, cls y: @21) {
	set(x), set(y), eq(singleton(x), singleton(y)) |-
		Oe1[setbuilder_e[in_eq_right_1[self_in_singleton[@h1], @h3]], NNi[@h2]]
}

"더블턴 클래스. singleton의 정의에 의존한다."
$\left\{#1<<,>> #2\right\}$
cls doubleton(cls x, cls y) {
	cup(singleton(x), singleton(y))
}

schema doubleton_e(cls x: @11, cls y: @21, cls z: @31) {
	set(x), set(y), in(z, doubleton(x, y)) |-
		OI[
			setbuilder_e[@h3],
			cp[in(z, singleton(x)) |- Oe1[setbuilder_e[@h4], NNi[@h1]]],
			cp[in(z, singleton(y)) |- Oe1[setbuilder_e[@h4], NNi[@h2]]]
		]
}

"set(y) 조건을 완화할 수도 있으나, 그러면 y가 집합이 아닐 때의 doubleton의 정의에 너무 의존하게 되므로 그러지 않았다."
schema doubleton_in_1(cls x, cls y) {
	set(x), set(y) |-
		id(in(x, doubleton(x, y)))[cup_i1(?, singleton(y), ?)[self_in_singleton(x)[@h1]]]
}

"set(x) 조건을 완화할 수도 있으나, 그러면 x가 집합이 아닐 때의 doubleton의 정의에 너무 의존하게 되므로 그러지 않았다."
schema doubleton_in_2(cls x, cls y) {
	set(x), set(y) |-
		id(in(y, doubleton(x, y)))[cup_i2(singleton(x), ?, ?)[self_in_singleton(y)[@h2]]]
}

schema doubleton_eq_i(cls x: @11, cls y: @21, cls u: @12, cls v: @22) {
	eq(x, u), eq(y, v) |-
		id(eq(doubleton(x, y), doubleton(u, v)))[cup_eq_i[singleton_eq_i[@h1], singleton_eq_i[@h2]]]
}

"x, y가 집합이 아닐 때의 doubleton의 정의에 의존하는 정리이므로 참조하는 것을 삼가라."
@discouraged schema doubleton_is_universe_1(cls x: @111, cls y) {
	N(set(x)) |-
		subseteq_to_eq[
			universe_subseteq_i(doubleton(x, y)),
			id(subseteq(universe(), doubleton(x, y)))[Ui[(cls z) => {cp[in(z, universe()) |-
				id(in(z, doubleton(x, y)))[setbuilder_i(
					Of(is_in(singleton(x)), is_in(singleton(y))), z
				)[
					set_i[@h2],
					Oi1(?, in(z, singleton(y)))[id(in(z, singleton(x)))[setbuilder_i(
						(cls z) => {O(N(set(x)), eq(z, x))},
						z
					)[set_i[@h2], Oi1(?, eq(z, x))[@h1]]]]
				]]
			]}]]
		]
}

"x, y가 집합이 아닐 때의 doubleton의 정의에 의존하는 정리이므로 참조하는 것을 삼가라."
@discouraged schema doubleton_is_universe_2(cls x, cls y: @111) {
	N(set(y)) |-
		subseteq_to_eq[
			universe_subseteq_i(doubleton(x, y)),
			id(subseteq(universe(), doubleton(x, y)))[Ui[(cls z) => {cp[in(z, universe()) |-
				id(in(z, doubleton(x, y)))[setbuilder_i(
					Of(is_in(singleton(x)), is_in(singleton(y))), z
				)[
					set_i[@h2],
					Oi2(in(z, singleton(x)), ?)[id(in(z, singleton(y)))[setbuilder_i(
						(cls z) => {O(N(set(y)), eq(z, y))},
						z
					)[set_i[@h2], Oi1(?, eq(z, y))[@h1]]]]
				]]
			]}]]
		]
}

"x, y가 집합이 아닐 때의 doubleton의 정의에 의존하는 정리이므로 참조하는 것을 삼가라."
@discouraged schema doubleton_is_universe(cls x: @1111, cls y: @1211) {
	O(N(set(x)), N(set(y))) |-
		Oeu[
			@h1,
			doubleton_is_universe_1(x, y),
			doubleton_is_universe_2(x, y)
		]
}

schema doubleton_set_e1(cls x: @111, cls y: @112) {
	set(doubleton(x, y)) |-
		NNe[Niu[N(set(x)) |-
			Fi[set_is_set_1[@h1, doubleton_is_universe_1(x, y)[@h2]], universe_is_not_set()]
		]]
}

schema doubleton_set_e2(cls x: @111, cls y: @112) {
	set(doubleton(x, y)) |-
		NNe[Niu[N(set(y)) |-
			Fi[set_is_set_1[@h1, doubleton_is_universe_2(x, y)[@h2]], universe_is_not_set()]
		]]
}

schema doubleton_set_e(cls x: @111, cls y: @112) {
	set(doubleton(x, y)) |-
		Ai[doubleton_set_e1[@h1], doubleton_set_e2[@h1]]
}

schema doubleton_eq_e1(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		doubleton_e[
			@h3, @h4,
			in_eq_right_1(doubleton(x, y), doubleton(u, v), x)[
				doubleton_in_1(x, y)[@h1, @h2],
				@h5
			]
		]
}

schema doubleton_eq_e2(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		doubleton_e[
			@h3, @h4,
			in_eq_right_1(doubleton(x, y), doubleton(u, v), y)[
				doubleton_in_2(x, y)[@h1, @h2],
				@h5
			]
		]
}

schema doubleton_eq_e3_flip(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		doubleton_eq_e1[@h3, @h4, @h1, @h2, eq_symmetric[@h5]]
}

schema doubleton_eq_e3(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		OI[
			doubleton_eq_e3_flip[@h1, @h2, @h3, @h4, @h5],
			cp[eq_symmetric(u, x)],
			cp[eq_symmetric(u, y)]
		]
}

schema doubleton_eq_e4_flip(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		doubleton_eq_e2[@h3, @h4, @h1, @h2, eq_symmetric[@h5]]
}

schema doubleton_eq_e4(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		OI[
			doubleton_eq_e4_flip[@h1, @h2, @h3, @h4, @h5],
			cp[eq_symmetric(v, x)],
			cp[eq_symmetric(v, y)]
		]
}

"`[Pinter]` 정리 1.27."
schema doubleton_eq_e(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(doubleton(x, y), doubleton(u, v)) |-
		O1Ai[
			O2Ai[
				doubleton_eq_e1[@h1, @h2, @h3, @h4, @h5],
				doubleton_eq_e3[@h1, @h2, @h3, @h4, @h5]
			],
			O_flip[O1Ai[
				doubleton_eq_e4[@h1, @h2, @h3, @h4, @h5],
				doubleton_eq_e2[@h1, @h2, @h3, @h4, @h5]
			]]
		]
}

"axiom of pairing. doubleton의 정의가 이상해졌으므로 doubleton에 의존하지 않도록 바꾸는 것이 좋을 것이다."
axiomatic schema ax_doubleton() {
	U2((cls x, cls y) => {
		I(
			A(set(x), set(y)),
			set(doubleton(x, y))
		)
	})
}

schema doubleton_set_i(cls x: @11, cls y: @21) {
	set(x), set(y) |-
		mp[
			Ai[@h1, @h2],
			Ue2(?, x, y)[ax_doubleton()]
		]
}

schema doubleton_to_cup(cls x: @11, cls y: @21, cls z: @31, cls w: @41) {
	set(x), set(y), in(z, doubleton(x, y)), in(w, z) |-
		Oe[
			doubleton_e[@h1, @h2, @h3],
			cp[eq(z, x) |- cup_i1(?, y, ?)[in_eq_right_1[
				@h4, @h5
			]]],
			cp[eq(z, y) |- cup_i2(x, ?, ?)[in_eq_right_1[
				@h4, @h5
			]]]
		]
}

schema bigcup_singleton_to_element($A$ cls a: @11, cls x: @21, cls z: @31) {
	is_singleton(a), in(x, a), in(z, bigcup(a)) |-
		mpX_Xe_p(?, in(z, x))[
			setbuilder_e[@h3],
			Ui[(cls w) => { cp[A(in(w, a), in(z, w)) |-
				in_eq_right_2[Ae2[@h4], mp[Ai[@h2, Ae1[@h4]], Ue2(?, x, w)[Ae2[@h1]]]]] }]
		]
}

schema bigcup_singleton_is_element($A$ cls a: @11, cls x: @21) {
	is_singleton(a), in(x, a) |-
		ax_extensional_m(bigcup(a), x)[Ui[(cls z) => { Ei[
			cp[in(z, bigcup(a)) |- bigcup_singleton_to_element[@h1, @h2, @h3]],
			cp[in(z, x) |- bigcup_i[@h2, @h3]]
		] }]]
}

schema bigcup_singleton_to_self(cls x: @11, cls z: @21) {
	set(x), in(z, bigcup(singleton(x))) |-
		mpX_Xe_p(?, in(z, x))[
			setbuilder_e[@h2],
			Ui[(cls w) => { cp[A(in(w, singleton(x)), in(z, w)) |-
				in_eq_right_1[Ae2[@h3], Oe1[setbuilder_e[Ae1[@h3]], NNi[@h1]]]] }]
		]
}

schema self_to_bigcup_singleton(cls x: @11, cls z: @21) {
	set(x), in(z, x) |-
		id(in(z, bigcup(singleton(x))))[setbuilder_i((cls z) => {
			X((cls w) => {A(in(w, singleton(x)), in(z, w))})
		}, z)[set_i[@h2], Xi((cls w) => {A(in(w, singleton(x)), in(z, w))}, x)[Ai[
			self_in_singleton[@h1],
			@h2
		]]]]
}

schema bigcup_singleton_is_self(cls x: @11) {
	set(x) |-
		ax_extensional_m(bigcup(singleton(x)), x)[Ui[(cls z) => {
			Eiu[
				(in(z, bigcup(singleton(x))) |- bigcup_singleton_to_self(x, z)[@h1, @h2]),
				(in(z, x) |- self_to_bigcup_singleton[@h1, @h2])
			]
		}]]
}

schema bigcup_doubleton_to_cup(cls x: @11, cls y: @21, cls w: @31) {
	set(x), set(y), in(w, bigcup(doubleton(x, y))) |-
		mpX_Xe_p(
			(cls z) => {
				A(
					in(z, doubleton(x, y)),
					in(w, z)
				)
			},
			in(w, cup(x, y))
		)[
			setbuilder_e[@h3],
			Ui[(cls z) => {
				cp[A(in(z, doubleton(x, y)), in(w, z)) |-
					doubleton_to_cup[
						@h1, @h2,
						Ae1[@h4],
						Ae2[@h4]
					]]
			}]
		]
}

schema cup_to_bigcup_doubleton(cls x: @11, cls y: @21, cls w: @31) {
	set(x), set(y), in(w, cup(x, y)) |-
		id(in(w, bigcup(doubleton(x, y))))[
			setbuilder_i((cls w) => {
				X((cls z) => {
					A(in(z, doubleton(x, y)), in(w, z))
				})
			}, w)[
				set_i[@h3],
				Oe[
					cup_e[@h3],
					cp[
						in(w, x) |-
							Xi((cls z) => {
								A(
									in(z, doubleton(x, y)),
									in(w, z)
								)
							}, x)[
								Ai[
									doubleton_in_1(x, y)[@h1, @h2],
									in_eq_right_1[@h4, eq_reflexive(x)]
								]
							]
					],
					cp[
						in(w, y) |-
							Xi((cls z) => {
								A(
									in(z, doubleton(x, y)),
									in(w, z)
								)
							}, y)[
								Ai[
									doubleton_in_2(x, y)[@h1, @h2],
									in_eq_right_1[@h4, eq_reflexive(y)]
								]
							]
					]
				]
			]
		]
}

schema bigcup_doubleton_is_cup(cls x: @11, cls y: @21) {
	set(x), set(y) |-
		ax_extensional_m(
			bigcup(doubleton(x, y)),
			cup(x, y)
		)[
			Ui[(cls w) => {
				Ei[
					cp[in(w, bigcup(doubleton(x, y))) |- bigcup_doubleton_to_cup(x, y, w)[@h1, @h2, @h3]],
					cp[
						in(w, cup(x, y)) |-
							cup_to_bigcup_doubleton[
								@h1, @h2, @h3
							]
					]
				]
			}]
		]
}

schema cup_is_set(cls x: @11, cls y: @21) {
	set(x), set(y) |-
		set_is_set_1[
			ax_bigcup_m(doubleton(x, y))[
				doubleton_set_i[@h1, @h2]
			],
			bigcup_doubleton_is_cup[
				@h1, @h2
			]
		]
}

"power class."
$<<\mathcal P>>(#1)$
cls power(cls x) {
	setbuilder((cls z) => {
		subseteq(z, x)
	})
}

schema power_def_Ue(cls x, cls y) {
	set(x) |-
		Eiu[
			(in(y, power(x)) |- setbuilder_e[@h2]),
			(subseteq(y, x) |-
				id(in(y, power(x)))[setbuilder_i((cls y) => {
					subseteq(y, x)
				}, y)[subset_is_set[@h1, @h2], @h2]])
		]
}

"x가 집합일 때, x와 같은 것은 x의 power class에 속한다."
schema self_in_power(cls x, cls z) {
	set(x) |-
		cp[eq(z, x) |-
			mp[eq_to_subseteq_1[@h2], Ee2[power_def_Ue(x, z)[@h1]]]]
}

schema singleton_subseteq_power_1(cls x, cls y) {
	set(x) |-
		cp[in(y, singleton(x)) |-
			mp[
				Oe1[setbuilder_e((cls z) => {O(N(set(x)), eq(z, x))}, y)[@h2], NNi[@h1]],
				self_in_power(x, y)[@h1]
			]]
}

schema singleton_subseteq_power(cls x: @11) {
	set(x) |-
		id(subseteq(singleton(x), power(x)))[Ui[(cls y) => {
			singleton_subseteq_power_1(x, y)[@h1]
		}]]
}

"axiom of power set."
axiomatic schema ax_power() {
	U((cls x) => {
		I(
			set(x),
			X((cls y) => {
				A(
					set(y),
					U((cls z) => {
						I(subseteq(z, x), in(z, y))
					})
				)
			})
		)
	})
}

schema ax_power_m(cls x) {
	set(x) |- mp[@h1, Ue(?, x)[ax_power()]]
}

"멱집합은 집합이다."
schema power_is_set(cls x: @11) {
	set(x) |-
		Xe_p(set(power(x)))[mpX(?, (cls y) => {set(power(x))})[
			ax_power_m(x)[@h1],
			Ui[(cls y) => {
				cp[
					A(set(y), U((cls z) => {
						I(subseteq(z, x), in(z, y))
					})) |-
						subset_is_set[
							Ae1[@h2],
							id(subseteq(power(x), y))[Ui[(cls z) => {
								syll[
									setbuilder_ec((cls z) => {
										subseteq(z, x)
									}, z),
									Ue(?, z)[Ae2[@h2]]
								]
							}]]
						]
				]
			}]
		]]
}

"x가 집합이 아닐 때의 singleton의 정의에 의존하는 정리이므로 참조하는 것을 삼가라."
@discouraged schema singleton_is_universe(cls x: @111) {
	N(set(x)) |-
		ax_extensional_m(singleton(x), universe())[Ui[(cls z) => { Ei[
			cp[in(z, singleton(x)) |- universe_in_i[set_i[@h2]]],
			cp[in(z, universe()) |- id(in(z, singleton(x)))[setbuilder_i(
				(cls z) => {O(N(set(x)), eq(z, x))}, z
			)[
				set_i[@h2],
				Oi1(?, eq(z, x))[@h1]
			]]]
		] }]]
}

"싱글턴은 집합이다."
schema singleton_set_i(cls x: @11) {
	set(x) |-
		subset_is_set[power_is_set[@h1], singleton_subseteq_power(x)[@h1]]
}

schema singleton_set_e(cls x: @111) {
	set(singleton(x)) |-
		NNe[Niu[N(set(x)) |-
			Fi[
				set_is_set_1[@h1, singleton_is_universe[@h2]],
				universe_is_not_set()
			]
		]]
}

###########################
######## RELATIONS ########
###########################

"순서쌍(ordered pair). Kuratowski의 정의이다."
$\left(#1<<,>>#2\right)$
cls v2(cls x, cls y) {
	doubleton(singleton(x), doubleton(x, y))
}

schema v2_eq_i(cls x: @11, cls y: @21, cls u: @12, cls v: @22) {
	eq(x, u), eq(y, v) |-
		id(eq(v2(x, y), v2(u, v)))[
			doubleton_eq_i[
				singleton_eq_i[@h1],
				doubleton_eq_i[@h1, @h2]
			]
		]
}

"`[Pinter]` 정리 1.30."
schema v2_eq_e(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(v2(x, y), v2(u, v)) |-
		Oe[
			doubleton_eq_e[
				singleton_set_i[@h1],
				doubleton_set_i[@h1, @h2],
				singleton_set_i[@h3],
				doubleton_set_i[@h3, @h4],
				@h5
			],
			cp[
				A(eq(singleton(x), singleton(u)), eq(doubleton(x, y), doubleton(u, v))) |-
				Oe[
					doubleton_eq_e[
						@h1, @h2, @h3, @h4,
						Ae2[@h6]
					],
					cp[id(A(eq(x, u), eq(y, v)))],
					cp[
						A(eq(x, v), eq(y, u)) |-
							Ai[
								singleton_eq_e[
									@h1, @h3,
									Ae1[@h6]
								],
								eq_transitive_1[
									eq_transitive_2[
										singleton_eq_e[
											@h1, @h3,
											Ae1[@h6]
										],
										Ae2[@h7]
									],
									Ae1[@h7]
								]
							]
					]
				]
			],
			cp[
				A(eq(singleton(x), doubleton(u, v)), eq(doubleton(x, y), singleton(u))) |-
					Ai[
						eq_symmetric[Oe1[setbuilder_e[in_eq_right_2[
							doubleton_in_1(u, v)[@h3, @h4],
							Ae1[@h6]
						]], NNi[@h1]]],
						eq_transitive_13[
							eq_transitive_1[
								eq_symmetric[Oe1[setbuilder_e[in_eq_right_2[
									doubleton_in_1(u, v)[@h3, @h4],
									Ae1[@h6]
								]], NNi[@h1]]],
								eq_symmetric[Oe1[setbuilder_e[in_eq_right_2[
									doubleton_in_2(u, v)[@h3, @h4],
									Ae1[@h6]
								]], NNi[@h1]]]
							],
							eq_symmetric[Oe1[setbuilder_e[in_eq_right_1[
								doubleton_in_2(x, y)[@h1, @h2],
								Ae2[@h6]
							]], NNi[@h3]]]
						]
					]
			]
		]
}

schema v2_eq_e1(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(v2(x, y), v2(u, v)) |-
		Ae1[v2_eq_e[@h1, @h2, @h3, @h4, @h5]]
}

schema v2_eq_e2(cls x: @11, cls y: @21, cls u: @31, cls v: @41) {
	set(x), set(y), set(u), set(v), eq(v2(x, y), v2(u, v)) |-
		Ae2[v2_eq_e[@h1, @h2, @h3, @h4, @h5]]
}

schema v2_set_i(cls x: @11, cls y: @21) {
	set(x), set(y) |-
		id(set(v2(x, y)))[
			doubleton_set_i[
				singleton_set_i[@h1],
				doubleton_set_i[@h1, @h2]
			]
		]
}

schema v2_set_e1(cls x: @111, cls y: @112) {
	set(v2(x, y)) |-
		singleton_set_e[doubleton_set_e1[@h1]]
}

schema v2_set_e2(cls x: @111, cls y: @112) {
	set(v2(x, y)) |-
		doubleton_set_e2[doubleton_set_e2[@h1]]
}

"순서쌍을 위한 setbuilder. 즉 [$\{(a, b): f(a, b)\}]이다."
$\left\{<<:>>#1\right\}$
cls setbuilder_v2(pr2 f) {
	setbuilder((cls z) => {
		X2((cls a, cls b) => {
			A(
				eq(z, v2(a, b)),
				f(a, b)
			)
		})
	})
}

"순서쌍을 위한 setbuilder2. 즉 [$\{f(a, b): g(a, b)\}]이다."
$\left\{#1<<:>>#2\right\}$
cls setbuilder2_v2([(cls, cls) -> cls] f, pr2 g) {
	setbuilder((cls z) => {
		X2((cls a, cls b) => {
			A(
				eq(z, f(a, b)),
				g(a, b)
			)
		})
	})
}

"곱집합(cartesian product)."
$!<prec=300>#1<<\times>>#2$
cls cartesian($A$ cls a, $B$ cls b) {
	setbuilder_v2((cls x, cls y) => {
		A(in(x, a), in(y, b))
	})
}

schema cartesian_in_i($A$ cls a: @12, $B$ cls b: @22, cls x: @11, cls y: @21) {
	in(x, a), in(y, b) |-
		id(in(v2(x, y), cartesian(a, b)))[setbuilder_i((cls z) => {
			X2((cls u, cls v) => {
				A(eq(z, v2(u, v)), A(in(u, a), in(v, b)))
			})
		}, ?)[
			v2_set_i[set_i[@h1], set_i[@h2]],
			Xi2((cls u, cls v) => {
				A(eq(v2(x, y), v2(u, v)), A(in(u, a), in(v, b)))
			}, x, y)[
				Ai[
					eq_reflexive(v2(x, y)),
					Ai[@h1, @h2]
				]
			]
		]]
}

schema cartesian_in_e($A$ cls a: @121, $B$ cls b: @122, cls x: @111, cls y: @112) {
	in(v2(x, y), cartesian(a, b)) |-
		$set_v2_xy = set_i[@h1];
		$set_x = v2_set_e1[$set_v2_xy];
		$set_y = v2_set_e2[$set_v2_xy];
		
		mpX2_X2e_p(?, A(in(x, a), in(y, b)))[
			setbuilder_e((cls z) => {
				X2((cls u, cls v) => {
					A(eq(z, v2(u, v)), A(in(u, a), in(v, b)))
				})
			}, ?)[@h1],
			Ui2[(cls u, cls v) => { cp[A(eq(v2(x, y), v2(u, v)), A(in(u, a), in(v, b))) |-
				$foo = Ae2[@h2];
				$u_in_a = Ae1[$foo];
				$v_in_b = Ae2[$foo];
				$u_is_set = set_i[$u_in_a];
				$v_is_set = set_i[$v_in_b];
				$Ae1h4 = Ae1[@h2];

				Ai[
					in_eq_left_2[$u_in_a, v2_eq_e1[$set_x, $set_y, $u_is_set, $v_is_set, $Ae1h4]],
					in_eq_left_2[$v_in_b, v2_eq_e2[$set_x, $set_y, $u_is_set, $v_is_set, $Ae1h4]]
				]
			] }]
		]
}

schema cartesian_in_e1($A$ cls a: @121, $B$ cls b: @122, cls x: @111, cls y: @112) {
	in(v2(x, y), cartesian(a, b)) |- Ae1[cartesian_in_e[@h1]]
}

schema cartesian_in_e2($A$ cls a: @121, $B$ cls b: @122, cls x: @111, cls y: @112) {
	in(v2(x, y), cartesian(a, b)) |- Ae2[cartesian_in_e[@h1]]
}

"어떤 class가 이항관계이다.

[$R]이 이항관계라 함은 [$R]의 임의 원소가 순서쌍이라는 뜻이다. 정의역(domain)과 치역(image)에 관한 정보는 담지 않도록 한다.

[$V\times V]의 임의 부분집합으로 정의해도 좋을 것이다."
$\left(<<\mathop\mathrm{relation}>> #1\right)$
st is_rel($R$ cls r) {
	Uin(r, (cls z) => {
		X2((cls x, cls y) => {
			eq(z, v2(x, y))
		})
	})
}

"이항관계의 정의역(domain)."
$!<prec=200><<\operatorname{dom}>>#1$
cls rel_dom($R$ cls r) {
	setbuilder((cls x) => {
		X((cls y) => {
			in(v2(x, y), r)
		})
	})
}

"이항관계의 치역(image)."
$!<prec=200><<\operatorname{im}>>#1$
cls rel_im($R$ cls r) {
	setbuilder((cls y) => {
		X((cls x) => {
			in(v2(x, y), r)
		})
	})
}

"어떤 집합에 의한 상(image)."
$#1\mathord{\left[#2\right]}{}^{<<\scriptscriptstyle\dag>>}$
cls rel_im_set($R$ cls r, $A$ cls a) {
	setbuilder((cls y) => {
		Xin(a, (cls x) => {
			in(v2(x, y), r)
		})
	})
}

"이항관계의 역(inverse)."
$!<prec=190>{#1}^{<<-1>>}$
cls rel_inverse(cls x) {
	setbuilder_v2((cls a, cls b) => {
		in(v2(b, a), x)
	})
}

"이항관계의 합성(composition)."
$!<prec=300>#1 <<\circ>> #2$
cls rel_composite(cls x, cls y) {
	setbuilder_v2((cls a, cls c) => {
		X((cls b) => {
			A(
				in(v2(a, b), y),
				in(v2(b, c), x)
			)
		})
	})
}

"이항관계를 위한 U.

[$R]이 이항관계일 때 임의의 [$(a, b)\in R]에 대해 [$f(a, b)]이면, 임의의 [$x\in R]에 대해 [$fx]이다."
schema rel_U(pr f, $R$ cls r: @11) {
	is_rel(r), U2((cls x, cls y) => {
		I(
			in(v2(x, y), r),
			f(v2(x, y))
		)
	}), U2((cls x, cls y) => {
		I(A(f(x), eq(x, y)), f(y))
	}) |-
		id(Uin(r, f))[Ui[(cls z) => {cp[in(z, r) |-
			mpX2_X2e_p(?, f(z))[
				mp[@h4, Ue(?, z)[@h1]],
				Ui2[(cls x, cls y) => {
					cp[eq(z, v2(x, y)) |-
						mp[
							Ai[mp[in_eq_left_1[@h4, @h5], Ue2(?, x, y)[@h2]], eq_symmetric[@h5]],
							Ue2(?, v2(x, y), z)[@h3]
						]]
				}]
			]
		]}]]
}

"곱집합은 이항관계이다."
schema cartesian_is_rel(cls x, cls y) {
	id(is_rel(cartesian(x, y)))[Ui[(cls z) => {
		cp[in(z, cartesian(x, y)) |-
			X2Ae1((cls a, cls b) => {
				eq(z, v2(a, b))
			}, (cls a, cls b) => {
				A(in(a, x), in(b, y))
			})[setbuilder_e[@h1]]]
	}]]
}

schema rel_subset_is_rel(cls x: @11, cls y: @12) {
	subseteq(x, y), is_rel(y) |- id(is_rel(x))[Uin_subset(x, y, (cls z) => {
		X2((cls a, cls b) => {
			eq(z, v2(a, b))
		})
	})[@h1, @h2]]
}

schema cartesian_is_set_1($A$ cls a, $B$ cls b) {
	set(a), set(b) |-
		power_is_set[power_is_set[cup_is_set[@h1, @h2]]]
}

schema cartesian_is_set_21($A$ cls a: @121, $B$ cls b: @122, cls x: @111, cls y: @112) {
	in(v2(x, y), cartesian(a, b)) |-
		$set_v2_xy = set_i[@h1];
		$set_x = v2_set_e1[$set_v2_xy];
		$set_y = v2_set_e2[$set_v2_xy];
		
		$x_in_cup_ab = cup_i1(?, b, ?)[cartesian_in_e1[@h1]];
		$y_in_cup_ab = cup_i2(a, ?, ?)[cartesian_in_e2[@h1]];
		
		$1 = id(in(singleton(x), power(cup(a, b))))[setbuilder_i((cls z) => {subseteq(z, cup(a, b))}, ?)[
			singleton_set_i(x)[$set_x],
			id(subseteq(singleton(x), cup(a, b)))[Ui[(cls z) => { cp[in(z, singleton(x)) |-
				in_eq_left_2[$x_in_cup_ab, Oe1[setbuilder_e[@h2], NNi[$set_x]]]] }]]
		]];
		
		$2 = id(in(doubleton(x, y), power(cup(a, b))))[setbuilder_i((cls z) => {subseteq(z, cup(a, b))}, ?)[
			doubleton_set_i[$set_x, $set_y],
			id(subseteq(doubleton(x, y), cup(a, b)))[Ui[(cls z) => { cp[in(z, doubleton(x, y)) |-
				Oeu[
					doubleton_e[$set_x, $set_y, @h2],
					(eq(z, x) |- in_eq_left_2[$x_in_cup_ab, @h3]),
					(eq(z, y) |- in_eq_left_2[$y_in_cup_ab, @h3])
				]
			] }]]
		]];
		
		id(in(v2(x, y), power(power(cup(a, b)))))[setbuilder_i(
			(cls z) => {subseteq(z, power(cup(a, b)))},
			?
		)[
			v2_set_i[$set_x, $set_y],
			id(subseteq(v2(x, y), power(cup(a, b))))[Ui[(cls z) => { cp[in(z, doubleton(singleton(x), doubleton(x, y))) |-
				Oeu[
					doubleton_e[singleton_set_i[$set_x], doubleton_set_i[$set_x, $set_y], @h2],
					(eq(z, singleton(x)) |- in_eq_left_2[$1, @h3]),
					(eq(z, doubleton(x, y)) |- in_eq_left_2[$2, @h3])
				]
			] }]]
		]]
}

schema cartesian_is_set_2($A$ cls a, $B$ cls b) {
	id(subseteq(cartesian(a, b), power(power(cup(a, b)))))[
		rel_U(is_in(power(power(cup(a, b)))), cartesian(a, b))[
			cartesian_is_rel(a, b),
			Ui2[(cls x, cls y) => {
				cp[cartesian_is_set_21(a, b, x, y)]
			}],
			Ui2[(cls x, cls y) => {
				cp[A(in(x, power(power(cup(a, b)))), eq(x, y)) |-
					in_eq_left_1[Ae1[@h1], Ae2[@h1]]]
			}]
		]
	]
}

"`[Pinter]` 정리 1.51. 곱집합은 집합이다."
schema cartesian_is_set($A$ cls a: @11, $B$ cls b: @21) {
	set(a), set(b) |-
		subset_is_set[
			cartesian_is_set_1(a, b)[@h1, @h2],
			cartesian_is_set_2(a, b)
		]
}

schema rel_composite_associative(cls x, cls y, cls z) {
	is_rel(x), is_rel(y), is_rel(z) |- eq(
		rel_composite(rel_composite(x, y), z),
		rel_composite(x, rel_composite(y, z))
	)
}

"어떤 [$\langle f, A, B\rangle]가 함수이다.

[$f\subseteq A\times B]이고 임의의 [$x\in A]에 대해 [$(x, y)\in f]를 만족하는 유일한 [$y]가 존재한다는 뜻이다."
$<<\mathop\mathrm{function}>>\left(#1: #2 \to #3\right)$
st is_function(cls f, $A$ cls a, $B$ cls b) {
	A(
		subseteq(f, cartesian(a, b)),
		Uin(a, (cls x) => {
			A(
				Xin(b, (cls y) => {
					in(v2(x, y), f)
				}),
				Q((cls y) => {
					in(v2(x, y), f)
				})
			)
		})
	)
}

"매개변수가 하나인 메타함수로 함수를 만든다."
$\left[#1\right]_{<<\in>>#2}$
cls make_fun([cls -> cls] f, $A$ cls a) {
	setbuilder2(
		(cls z) => {
			v2(z, f(z))
		},
		(cls z) => {
			in(z, a)
		}
	)
}

"매개변수가 두 개인 메타함수로 함수를 만든다."
$\left[#1\right]_{<<\in>>#2 \times #3}$
cls make_fun_v2([(cls, cls) -> cls] f, $A$ cls a, $B$ cls b) {
	setbuilder2_v2(
		(cls x, cls y) => {
			v2(v2(x, y), f(x, y))
		},
		(cls x, cls y) => {
			A(in(x, a), in(y, b))
		}
	)
}

schema fun_subseteq_cartesian(cls f: @11, $A$ cls a: @12, $B$ cls b: @13) {
	is_function(f, a, b) |- Ae1[@h1]
}

schema fun_im_Xq(cls f: @11, $A$ cls a: @12, $B$ cls b: @13) {
	is_function(f, a, b) |- Ae2[@h1]
}

schema fun_im_Xq_m(cls f: @11, $A$ cls a: @12, $B$ cls b: @13, cls x: @21) {
	is_function(f, a, b), in(x, a) |-
		mp[@h2, Ue(?, x)[fun_im_Xq[@h1]]]
}

schema fun_im_X(cls f: @11, $A$ cls a: @12, $B$ cls b: @13) {
	is_function(f, a, b) |- id(Uin(a, (cls x) => {Xin(b, (cls y) => {in(v2(x, y), f)})}))[
		Ui[(cls x) => {
			cp[(
				in(x, a) |-
					Ae1[mp[@h2, Ue(?, x)[fun_im_Xq[@h1]]]]
			)]
		}]
	]
}

schema fun_im_X_m(cls f: @11, $A$ cls a: @12, $B$ cls b: @13, cls x: @21) {
	is_function(f, a, b), in(x, a) |-
		mp[@h2, Ue(?, x)[fun_im_X[@h1]]]
}

schema fun_im_Q(cls f: @11, $A$ cls a: @12, $B$ cls b: @13) {
	is_function(f, a, b) |- id(Uin(a, (cls x) => {Q((cls y) => {in(v2(x, y), f)})}))[
		Ui[(cls x) => {
			cp[(
				in(x, a) |-
					Ae2[mp[@h2, Ue(?, x)[fun_im_Xq[@h1]]]]
			)]
		}]
	]
}

schema fun_im_Q_m(cls f: @11, $A$ cls a: @12, $B$ cls b: @13, cls x: @21, $y_1$ cls y1: @312, $y_2$ cls y2: @412) {
	is_function(f, a, b), in(x, a), in(v2(x, y1), f), in(v2(x, y2), f) |-
		mp[Ai[@h3, @h4], Ue2(?, y1, y2)[mp[@h2, Ue(?, x)[fun_im_Q[@h1]]]]]
}

schema fun_is_rel(cls f, $A$ cls a, $B$ cls b) {
	is_function(f, a, b) |- rel_subset_is_rel[
		fun_subseteq_cartesian(f, a, b)[@h1],
		cartesian_is_rel(a, b)
	]
}

schema fun_dom(cls f, $A$ cls a, $B$ cls b) {
	is_function(f, a, b) |- eq(rel_dom(f), a)
}

"함수 호출. [$f]가 함수이고 [$x]가 [$f]의 정의역에 있을 경우 함숫값이 된다. 그러하지 아니할 때는 다음과 같다.

[ul
	[*] [$f]가 함수이고 [$x]가 [$f]의 정의역 밖일 경우 [$\varnothing]이 된다.
	[*] 일반적으로 [$(x, y)\in f]인 [$y]를 전부 합집합 한 것이다.
]"
$#1\mathord{\left(#2\right)}{}^{<<\scriptscriptstyle\dag>>}$
cls fcall(cls f, cls x) {
	bigcup(rel_im_set(f, singleton(x)))
}

schema fcall_def_0(cls f, $A$ cls a, $B$ cls b, cls x, cls y) {
	is_function(f, a, b), in(x, a), in(y, rel_im_set(f, singleton(x))) |-
		mpX_Xe_p(?, in(v2(x, y), f))[
			setbuilder_e[@h3],
			Ui[(cls z) => { cp[A(in(z, singleton(x)), in(v2(z, y), f)) |-
				in_eq_left_1[Ae2[@h4], v2_eq_i[Oe1[setbuilder_e[Ae1[@h4]], NNi[set_i[@h2]]], eq_reflexive(y)]]]
			}]
		]
}

schema fcall_def_1(cls f, $A$ cls a, $B$ cls b, cls x, cls y) {
	is_function(f, a, b), in(x, a), in(y, b), in(v2(x, y), f) |-
		id(in(y, rel_im_set(f, singleton(x))))[setbuilder_i(
			(cls y) => {
				X((cls z) => {A(in(z, singleton(x)), in(v2(z, y), f))})
			}, y
		)[
			set_i[@h3],
			Xi((cls z) => {A(in(z, singleton(x)), in(v2(z, y), f))}, x)[Ai[self_in_singleton[set_i[@h2]], @h4]]
		]]
}

schema fcall_def_2(cls f, $A$ cls a, $B$ cls b, cls x) {
	is_function(f, a, b), in(x, a) |-
			mpX(?, is_in(rel_im_set(f, singleton(x))))[
				fun_im_X_m[@h1, @h2],
				Ui[(cls y) => { cp[A(in(y, b), in(v2(x, y), f)) |-
					fcall_def_1(f, a, b, x, y)[@h1, @h2, Ae1[@h3], Ae2[@h3]]] }]
			]
}

schema fcall_def_3(cls f, $A$ cls a, $B$ cls b, cls x) {
	is_function(f, a, b), in(x, a) |-
		id(Q(is_in(rel_im_set(f, singleton(x)))))[Ui2[($y_1$ cls y1, $y_2$ cls y2) => {
			cp[A(in(y1, rel_im_set(f, singleton(x))), in(y2, rel_im_set(f, singleton(x)))) |-
				fun_im_Q_m[
					@h1, @h2,
					fcall_def_0(f, a, b, x, y1)[@h1, @h2, Ae1[@h3]],
					fcall_def_0(f, a, b, x, y2)[@h1, @h2, Ae2[@h3]]
				]]
		}]]
}

schema fcall_def(cls f, $A$ cls a, $B$ cls b, cls x) {
	is_function(f, a, b), in(x, a) |-
		mpX_Xe_p(?, in(v2(x, fcall(f, x)), f))[
			fcall_def_2(f, a, b, x)[@h1, @h2],
			Ui[(cls y) => {
				cp[in(y, rel_im_set(f, singleton(x))) |-
					in_eq_left_2[
						fcall_def_0(f, a, b, x, y)[@h1, @h2, @h3],
						v2_eq_i[
							eq_reflexive(x),
							bigcup_singleton_is_element[
								id(is_singleton(rel_im_set(f, singleton(x))))[
									XQ_to_Xq[fcall_def_2(f, a, b, x)[@h1, @h2], fcall_def_3(f, a, b, x)[@h1, @h2]]
								],
								@h3
							]
						]
					]]
			}]
		]
}

schema fcall_in_codomain(cls f: @11, $A$ cls a: @12, $B$ cls b: @13, cls x: @21) {
	is_function(f, a, b), in(x, a) |-
		mpX_Xe_p(?, in(fcall(f, x), b))[
			fun_im_X_m[@h1, @h2],
			Ui[(cls y) => { cp[A(in(y, b), in(v2(x, y), f)) |-
				in_eq_left_1[Ae1[@h3], fun_im_Q_m[@h1, @h2, Ae2[@h3], fcall_def(f, a, b, x)[@h1, @h2]]]] }]
		]
}

###########################
##### NATURAL NUMBERS #####
###########################

"따름 순서수(successor ordinal)."
${#1}^{<<+>>}$
cls successor(cls x) {
	cup(x, singleton(x))
}

schema self_in_successor(cls x: @11) {
	set(x) |- id(in(x, successor(x)))[cup_i2(x, ?, ?)[
		self_in_singleton(x)[@h1]
	]]
}

"순서수(ordinal number)로서의 0."
$<<0_\text{ord}>>$
cls ord_zero() {
	emptyset()
}

"순서수(ordinal number)로서의 1. 0의 따름 순서수이다."
$<<1_\text{ord}>>$
cls ord_one() {
	successor(ord_zero())
}

"순서수(ordinal number)로서의 2. 1의 따름 순서수이다."
$<<2_\text{ord}>>$
cls ord_two() {
	successor(ord_one())
}

"따름 순서수는 집합이다."
schema successor_is_set(cls x: @11) {
	set(x) |- id(set(successor(x)))[cup_is_set[
		@h1,
		singleton_set_i[@h1]
	]]
}

"[$x]가 successor set이다."
$\left(<<\operatorname{successor\ set}>> #1\right)$
st is_successor_set(cls x) {
	A(
		in(emptyset(), x),
		U((cls z) => {
			I(
				in(z ,x),
				in(successor(z), x)
			)
		})
	)
}

"무한 공리(axiom of infinity). 즉 successor set 중에는 집합인 것이 있다."
axiomatic schema ax_infinity() {
	X((cls x) => {
		A(
			set(x),
			is_successor_set(x)
		)
	})
}

"자연수 집합. 즉 모든 successor set을 교집합한 것이다."
$<<\omega>>$
cls omega() {
	bigcap(setbuilder((cls z) => {
		is_successor_set(z)
	}))
}

"자연수 집합은 0을 포함한다. `[Pinter]`에 따르면 페아노 공리계 제1공리이다."
schema zero_in_omega() {
	id(in(ord_zero(), omega()))[bigcap_i(setbuilder((cls z) => {
		is_successor_set(z)
	}), ord_zero())[
		ax_emptyset(),
		Ui[(cls z) => {
			cp[
				in(z, setbuilder((cls z) => {is_successor_set(z)})) |-
					Ae1[setbuilder_e[@h1]]
			]
		}]
	]]
}

"`[Pinter]`에 따르면 페아노 공리계 제2공리인 것."
schema successor_in_omega(cls z: @11) {
	in(z, omega()) |-
		id(in(successor(z), omega()))[bigcap_i(setbuilder((cls z) => {is_successor_set(z)}), successor(z))[
			successor_is_set(z)[Xi(contains(z), omega())[@h1]],
			Ui[(cls x) => {
				cp[
					in(x, setbuilder((cls z) => {is_successor_set(z)})) |-
						mp[
							mp[
								@h2,
								Ue(?, x)[bigcap_e(setbuilder((cls z) => {
									is_successor_set(z)
								}), z)[@h1]]
							],
							Ue(?, z)[Ae2[setbuilder_e((cls z) => {is_successor_set(z)}, x)[
								@h2
							]]]
						]
				]
			}]
		]]
}

"[$\omega]는 successor set이다."
schema omega_is_successor_set() {
	id(is_successor_set(omega()))[Ai[
		zero_in_omega(),
		Ui[(cls z) => {
			cp[successor_in_omega(z)]
		}]
	]]
}

"자연수 집합은 집합이다. ax_infinity로부터 유도된다."
schema omega_is_set() {
	mpX_Xe_p(?, set(omega()))[
		ax_infinity(),
		Ui[(cls x) => {
			cp[
				A(set(x), is_successor_set(x)) |-
					id(set(omega()))[subset_is_set[
						Ae1[@h1],
						bigcap_is_smaller[setbuilder_ia((cls z) => {is_successor_set(z)}, ?)[
							@h1
						]]
					]]
			]
		}]
	]
}

"`[Pinter]`에 따르면 페아노 공리계 제3공리인 것."
schema successor_is_not_zero(cls n) {
	in(n, omega()) |-
		id(neq(successor(n), ord_zero()))[
			Niu[
				eq(successor(n), ord_zero()) |-
					Fi[
						in_eq_right_1[
							self_in_successor[set_i[@h1]],
							@h2
						],
						id(Nin(n, ord_zero()))[emptyset_def(n)]
					]
			]
		]
}

st is_recursively_defined($\gamma$ cls g, $A$ cls a, cls c, cls f) {
	A(
		is_function(g, omega(), a),
		A(
			eq(fcall(g, ord_zero()), c),
			Uin(omega(), (cls n) => {
				eq(
					fcall(g, successor(n)),
					fcall(f, fcall(g, n))
				)
			})
		)
	)
}

"`[Pinter]` 6.8에 나오는 [$\mathscr A]."
cls recursion_set($A$ cls a, cls c, cls f) {
	setbuilder(($G$ cls g) => {
		A(
			subseteq(g, cartesian(omega(), a)),
			A(
				in(v2(ord_zero(), c), g),
				Uin(omega(), (cls n) => {
					Uin(a, (cls x) => {
						I(
							in(v2(n, x), g),
							in(v2(successor(n), fcall(f, x)), g)
						)
					})
				})
			)
		)
	})
}

"클래스 [$A] 및 그 원소 [$c\in A] 및 함수 [$f: A\to A]에 대하여,
[ol
	[*] [$\gamma(0) = c,]
	[*] 임의의 [$n\in\omega]에 대하여, [$\gamma(n^+)=f(\gamma(n))]
]
을 만족하는 함수 [$\gamma:\omega\to A]를 만든다. [$c]와 [$f]가 조건을 만족하지 않으면 만들어지지 않는다. `[Pinter]`의 정리 6.8에 등장한다."
cls define_recursively($A$ cls a, cls c, cls f) {
	bigcap(recursion_set(a, c, f))
}

"[$\gamma\in\mathscr A]가 되기 위한 첫 번째 조건이다. 즉 [$\gamma\subseteq\omega\times A]이다.
[$\gamma]가 함수가 되기 위한 첫 번째 조건이기도 하다."
schema recursion_theorem_1($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		id(subseteq(define_recursively(a, c, f), cartesian(omega(), a)))[
			bigcap_is_smaller[id(in(cartesian(omega(), a), recursion_set(a, c, f)))[
				setbuilder_i(($G$ cls g) => {
					A(
						subseteq(g, cartesian(omega(), a)),
						A(
							in(v2(ord_zero(), c), g),
							Uin(omega(), (cls n) => {
								Uin(a, (cls x) => {
									I(
										in(v2(n, x), g),
										in(v2(successor(n), fcall(f, x)), g)
									)
								})
							})
						)
					)
				}, cartesian(omega(), a))[
					cartesian_is_set[
						omega_is_set(),
						@h1
					],
					Ai[
						self_subseteq_self(cartesian(omega(), a)),
						Ai[
							cartesian_in_i[
								zero_in_omega(),
								@h2
							],
							id(Uin(omega(), (cls n) => {
								Uin(a, (cls x) => {
									I(
										in(v2(n, x), cartesian(omega(), a)),
										in(v2(successor(n), fcall(f, x)), cartesian(omega(), a))
									)
								})
							}))[
								Ui((cls n) => {
									I(in(n, omega()), Uin(a, (cls x) => {
										I(
											in(v2(n, x), cartesian(omega(), a)),
											in(v2(successor(n), fcall(f, x)), cartesian(omega(), a))
										)
									}))
								})[(cls n) => {
									cp[
										in(n, omega()) |-
											id(Uin(a, (cls x) => {
												I(
													in(v2(n, x), cartesian(omega(), a)),
													in(v2(successor(n), fcall(f, x)), cartesian(omega(), a))
												)
											}))[
												Ui((cls x) => {
													I(in(x, a), I(
														in(v2(n, x), cartesian(omega(), a)),
														in(v2(successor(n), fcall(f, x)), cartesian(omega(), a))
													))
												})[(cls x) => {
													cp[
														in(x, a) |-
															cp[in(v2(n, x), cartesian(omega(), a)) |-
																cartesian_in_i[
																	successor_in_omega[@h4],
																	fcall_in_codomain[@h3, @h5]
																]]
													]
												}]
											]
									]
								}]
							]
						]
					]
				]
			]]
		]
}

"[$\gamma\in\mathscr A]가 되기 위한 두 번째 조건."
schema recursion_theorem_2($A$ cls a: @11, cls c: @21, cls f: @31) {
	in(c, a) |-
		id(in(v2(ord_zero(), c), define_recursively(a, c, f)))[
			setbuilder_i((cls z) => {
				U(($G$ cls g) => {
					I(in(g, recursion_set(a, c, f)), in(z, g))
				})
			}, v2(ord_zero(), c))[
				v2_set_i[
				set_i[zero_in_omega()],
				set_i[@h1]
			],
				Ui[($G$ cls g) => {
					cp[in(g, recursion_set(a, c, f)) |- Ae1[Ae2[setbuilder_e[@h2]]]]
				}]
			]
		]
}

"[$\gamma\in\mathscr A]가 되기 위한 세 번째 조건."
schema recursion_theorem_3($A$ cls a: @11, cls c: @21, cls f: @31) {
	is_function(f, a, a) |-
		id(Uin(omega(), (cls n) => {
			Uin(a, (cls x) => {
				I(
					in(v2(n, x), define_recursively(a, c, f)),
					in(v2(successor(n), fcall(f, x)), define_recursively(a, c, f))
				)
			})
		}))[Ui[(cls n) => {
			cp[in(n, omega()) |-
				Ui[(cls x) => {
					cp[in(x, a) |-
						cp[in(v2(n, x), define_recursively(a, c, f)) |-
							id(in(v2(successor(n), fcall(f, x)), define_recursively(a, c, f)))[setbuilder_i((cls z) => {
								U(($G$ cls g) => {
									I(in(g, recursion_set(a, c, f)), in(z, g))
								})
							}, v2(successor(n), fcall(f, x)))[
								v2_set_i[
									successor_is_set[set_i[@h2]],
									set_i[fcall_in_codomain[@h1, @h3]]
								],
								mp[
									setbuilder_e[@h4],
									UIm(
										($G$ cls g) => {
											I(in(g, recursion_set(a, c, f)), in(v2(n, x), g))
										},
										($G$ cls g) => {
											I(in(g, recursion_set(a, c, f)), in(v2(successor(n), fcall(f, x)), g))
										}
									)[Ui[($G$ cls g) => {
										I_distribute_left[cp[in(g, recursion_set(a, c, f)) |-
											mp[@h3, Ue(?, x)[mp[
												@h2,
												Ue(?, n)[Ae2[Ae2[setbuilder_e[@h5]]]]
											]]]
										]]
									}]]
								]
							]]]]
				}]]
		}]]
}

"[$\gamma]가 함수가 되기 위한 두 번째 조건."
schema recursion_theorem_4($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		Uin(omega(), (cls x) => {
			Xin(a, (cls y) => {
				in(v2(x, y), define_recursively(a, c, f))
			})
		})
}

"[$\gamma]가 함수가 되기 위한 세 번째 조건."
schema recursion_theorem_5($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		Uin(omega(), (cls x) => {
			Q((cls y) => {
				in(v2(x, y), define_recursively(a, c, f))
			})
		})
}

"[$\gamma:\omega\to A]가 함수이다."
schema recursion_theorem_6($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		id(is_function(define_recursively(a, c, f), omega(), a))[
			Ai[recursion_theorem_1[@h1, @h2, @h3], UinA_i[recursion_theorem_4[@h1, @h2, @h3], recursion_theorem_5[@h1, @h2,@h3]]]
		]
}

"[$\gamma]가 함수이고 재귀적으로 정의된다."
schema recursion_theorem_7($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		is_recursively_defined(define_recursively(a, c, f), a, c, f)
}

"[$\gamma]는 여러 개 있지 않다."
schema recursion_theorem_8($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		Q(($\gamma$ cls g) => {
			is_recursively_defined(g, a, c, f)
		})
}

"재귀 정리(recursion theorem)."
schema recursion_theorem($A$ cls a: @11, cls c: @21, cls f: @31) {
	set(a), in(c, a), is_function(f, a, a) |-
		XQ_to_Xq[
			Xi(($\gamma$ cls g) => {
				is_recursively_defined(g, a, c, f)
			}, define_recursively(a, c, f))[
				recursion_theorem_7(a, c, f)[@h1, @h2, @h3]
			],
			recursion_theorem_8(a, c, f)[@h1, @h2, @h3]
		]
}

"자연수 덧셈."
$!<prec=300>#1<<+_\omega>>#2$
cls omega_add(cls n, cls m) {
	fcall(define_recursively(omega(), n, make_fun(($\gamma$ cls g) => { successor(g) }, omega())), m)
}

"[$1+1=2]이다."
schema one_plus_one_eq_two() {
	eq(omega_add(ord_one(), ord_one()), ord_two())
}