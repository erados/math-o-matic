<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>math-o-matic</title>
		<script src="../dist/math.js"></script>
		<script src="./code.js"></script>
		<script src="./native.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/m42kup@0.2.1/dist/m42kup.min.js"></script>
		<script>
			m42kup.set({
				katex
			});
		</script>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
		<style>
			* {
				tab-size: 4;
			}

			body {
				font: 16px Roboto, sans-serif;
				font-weight: 400;
				-webkit-font-smoothing: antialiased;
				color: #5f6368;
				line-height: 1.5;
				word-break: normal;
				overflow-wrap: break-word;
			}

			h1, h2, h3, h4, h5, h6, a, b, strong, input, textarea, th, .katex {
				color: #202124;
			}

			p {
				margin: 0;
			}

			p + p {
				margin-top: 1em;
			}

			pre {
				white-space: pre-wrap;
			}

			table {
				border: 1px #ccc solid;
				border-collapse: collapse;
				margin: 1em 0;
			}

			table tr td, table tr th {
				padding: .2em .5em;
				border: 1px #ccc solid;
			}

			.block {
				padding: 1em;
				background-color: #fafafa;
				border: 1px #ccc solid;
				border-radius: 3px;
				margin: 1em 0;
			}

			.label {
				font-family: 'Roboto Mono', monospace, monospace;
			}

			.math {
				font-size: 1.2em;
				margin: 1em 0;
			}

			.katex a {
				text-decoration: none;
				color: inherit;
			}

			.katex a[data-blue] > :not(.mspace) {
				background-color: #E3F2FD;
				color: #303F9F;
			}

			.katex a[data-green] > :not(.mspace) {
				background-color: #E8F5E9;
				color: #006064;
			}

			.katex a[data-orange] {
				color: #E65100;
			}

			table.explorer td {
				white-space: nowrap;
			}

			table.explorer td.brb {
				border-right: 3px #222 solid;
				text-align: right;
				width: 1px;
			}

			table.explorer td.bbb {
				border-bottom: 3px #222 solid;
			}

			.red {
				 color: #D32F2F;
			}
		</style>
	</head>
	<body>
		<h1>math-o-matic</h1>
		<a href="https://github.com/logico-philosophical/math-o-matic">repo</a> &middot; <a href="../docs/build/index.html">docs</a>
		<h2>연산자 우선순위</h2>
		현재 연산자 우선순위는 다음과 같습니다.
		<div id="precedence"></div>
		위 표는 자동으로 생성되었습니다.
		<h2>로컬에서 실행하는 방법</h2>
		<p>로컬에서 file 스킴으로 페이지를 불러왔을 경우 CORS 정책에 의해 페이지가 작동하지 않을 수 있습니다. 이때 다음과 같은 해결책이 있습니다.</p>
		<ul>
			<li> 로컬 서버를 통해 접속하기. 이는 npm의 <a href="https://www.npmjs.com/package/http-server">http-server</a> 패키지를 사용하여 할 수 있습니다.
			<li> Chrome의 경우 <code>--allow-file-access-from-files</code> 플래그를 통해 로컬 파일 로드를 가능하게 할 수 있습니다. <a href="https://stackoverflow.com/a/18137280">StackOverflow 링크</a>
		</ul>
		<h2>우상단 reload 버튼에 관하여</h2>
		<p>우상단 reload 버튼은 <a href="./code.js">code.js</a> 파일을 다시 불러와서 목록을 재작성합니다. 단 그 과정에서 에러가 발생하였을 경우 이전 목록이 보존되므로 새로운 코드를 작성할 때 유용하게 사용할 수 있습니다.</p>
		<h2>목록</h2>
		<p>이하의 내용은
			<a href="./code.js">code.js</a> 및
			<a href="./native.js">native.js</a>에 있는 코드를 렌더링 한 것입니다.</p>
		<div style="position:fixed;top:5px;right:5px;z-index:10000;">
			<input id="reload" type="button" value="RELOAD">
		</div>
		<div id="all"></div>
		<script>
			$ = (q, n) => (n || document).querySelector(q);
			$$ = (q, n) => (n || document).querySelectorAll(q);

			var katexOpts = {
				trust: context => {
					if (context.command != '\\href') return false;
					if (context.protocol != '_relative') return false;
					return true;
				}
			}

			var ktx = s => {
				var ret = '';
				try {
					ret = katex.renderToString(s, katexOpts);
				} catch (e) {
					console.error(`Error parsing ${s}`);
					throw Error(e);
				}

				return ret;
			}

			var escapeHtml = s => (s + '').replace(/[&<>"']/g, m => ({
			    '&': '&amp;', '<': '&lt;', '>': '&gt;',
			    '"': '&quot;', "'": '&#39;'
			})[m]);

			var loading = false;

			function load() {
				if (loading) return;
				loading = true;

				try {

				var start, end;

				console.log('--- PARSE START ---');
				start = new Date();
				var parsed;
				try {
					parsed = math.parser.parse(code);
				} catch (e) {
					console.error(e);
					console.error(`Error: ${e.message}\n\tat code.js:${e.location.start.line}:${e.location.start.column}`);
					console.log('--- PARSE FAILED ---');
					return;
				}

				end = new Date();
				console.log(parsed);
				console.log('--- PARSE END ---');
				console.log(`Parse ended in ${end - start} ms`);
				console.log('--- PROCESS START ---');
				start = new Date();

				program = new math.Program();
				program.feed(parsed, native);

				end = new Date();
				console.log(program);
				console.log('--- PROCESS END ---');
				console.log(`Process ended in ${end - start} ms`);
				console.log('--- HTML GENERATION START ---');
				start = new Date();

				var precedenceMap = new Map();

				for (var k in program.scope.defMap) {
					var prec = program.scope.defMap[k].precedence;
					if (prec) {
						if (precedenceMap.has(prec)) {
							precedenceMap.set(prec, precedenceMap.get(prec).concat([k]));
						} else {
							precedenceMap.set(prec, [k]);
						}	
					}
				}

				precedenceMap = [...precedenceMap].sort((a, b) => a[0] - b[0]);

				$('#precedence').innerHTML = `<table>
					<tr><td>우선순위</td><td>연산자</td></tr>
					${precedenceMap.map(([k, v]) => {
						return `<tr><td>${k}</td><td>${v.map(w => {
							return `<a href="#def-${w}">${w}</a>`;
						}).join(', ')}</td></tr>`;
					}).join('')}
				</table>`;

				var arr = {}, r;

				for (var k in program.scope.typedefMap) {
					var v = program.scope.typedefMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="type-${k}" href="#type-${k}"><b>${
							(v.isBaseType ? 'base ' : '')
						}type</b> ${k}</a></p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				for (var k in program.scope.defMap) {
					var v = program.scope.defMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="def-${k}" href="#def-${k}"><b>definition</b> ${k}</a>${v.type.isSimple ? '' : `(${v.params.map(p => p.toSimpleString()).join(', ')})`}</p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				function getProofExplorer(expr) {
					var ctr = 0;

					var DIAMOND = '&#x25C7;',
						DOWN = '&#x25BC;',
						UP = '&#x25B2;';


					var ncols = (function recurse(expr) {
						switch (expr._type) {
							case 'reduction':
								return Math.max(
									...expr.leftargs.map(recurse),
									((expr.subject._type == 'schema' && expr.subject.name)
										|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)
											? 0 : recurse(expr.subject)),
									1
								);
							case 'schema':
							case 'fun':
								return recurse(expr.expr) + 1;
							case 'tee':
								return Math.max(
									...expr.left.map(recurse),
									recurse(expr.right)
								) + 1;
							case 'schemacall':
							case 'funcall':
							default:
								return 1;
						}
					})(expr);

					var html = '<table class="explorer">';
					html += `<tr><th>#</th><th colspan="${ncols}">expr</th><th colspan="2">rule</th></tr>`;

					function getHtml(left, h1, h2, bbb, noctr) {
						var padding = left.length;

						var htmlLeft = left.map(e => `<td class="brb">${e.map(f => ktx(f.toTeXString(true))).join(', ')}</td>`).join('');

						return `<tr><th>${noctr ? '' : ++ctr}</th>${htmlLeft}<td ${bbb ? 'class="bbb"' : ''} colspan="${ncols-padding}">${h1}</td>${h2}</tr>`;
					}

					function getHypNo(hyps, expr) {
						for (var i = 0; i < hyps.length; i++) {
							var [hyp, lineno] = hyps[i];

							if (program.ExpressionResolver.equalsMeta(hyp, expr)) {
								return lineno;
							}
						}

						return false;
					}

					html += (function recurse(expr, left, hyps) {
						var hypno = getHypNo(hyps, expr);

						if (hypno) {
							return getHtml(
								left,
								ktx(expr.toTeXString(true)),
								`<td>${DIAMOND}</td><td>[<b>${hypno}</b>]</td>`
							);
						}

						switch (expr._type) {
							case 'reduction':
								var leftPrinted = false;

								var leftargs = expr.leftargs.map(leftarg => {
									var hypno = getHypNo(hyps, leftarg);

									if (hypno) {
										return [false, hypno];
									}

									if (!leftPrinted) {
										leftPrinted = true;
									} else {
										left = Array(left.length).fill([]);
									}

									return [
										recurse(
											leftarg,
											left,
											hyps
										),
										ctr
									];
								});

								if (leftPrinted) {
									left = Array(left.length).fill([]);
								}

								if ((expr.subject._type == 'schema' && expr.subject.name)
										|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)) {
									return [
										leftargs.map(e => e[0]).filter(e => e).join(''),
										getHtml(
											left,
											ktx(expr.reduced.toTeXString(true)),
											`<td>${DOWN}</td><td>${ktx(expr.subject.toTeXString(true))} [${leftargs.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
										)
									].join('');
								}

								var subject = (() => {
									var hypno = getHypNo(hyps, expr.subject);

									if (hypno) {
										return [false, hypno];
									}

									if (!leftPrinted) {
										leftPrinted = true;
									} else {
										left = Array(left.length).fill([]);
									}

									return [
										recurse(
											expr.subject,
											left,
											hyps
										),
										ctr
									];
								})();

								if (leftPrinted) {
									left = Array(left.length).fill([]);
								}

								return [
									leftargs.map(e => e[0]).filter(e => e).join(''),
									subject[0] || '',
									getHtml(
										left,
										ktx(expr.reduced.toTeXString(true)),
										`<td>${DOWN}</td><td><b>${subject[1]}</b> [${leftargs.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
									)
								].join('');
							case 'schemacall':
								return getHtml(
									left,
									ktx(expr.expanded.toTeXString(true)),
									`<td>${DIAMOND}</td><td>${ktx(expr.toTeXString(true))}</td>`
								);
							case 'funcall':
							case 'typevar':
								return getHtml(
									left,
									ktx(expr.toTeXString(true)),
									'<td colspan="2"><b class="red">not proved</b></td>'
								);
							case 'schema':
							case 'fun':
								if (expr.name) {
									return getHtml(
										left,
										ktx(expr.toTeXString(true, true)),
										`<td>${DIAMOND}</td><td>${ktx(expr.toTeXString(true))}</td>`
									);
								}

								return recurse(
									expr.expr,
									left.concat([expr.params]),
									hyps
								);
							case 'tee':
								var start = ctr + 1;
								var arr = [
									...(
										expr.left.length
											? expr.left.map((e, i, a) => getHtml(
												(i == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
												ktx(e.toTeXString(true)),
												'<td colspan="2">assumption</td>',
												i == a.length - 1
											))
											: [getHtml(
												Array(left.length + 1).fill([]),
												'',
												'<td colspan="2"></td>',
												true,
												true
											)]
									),
									recurse(
										expr.right,
										(expr.left.length == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
										hyps.concat(expr.left.map((e, i) => [e, start + i]))
									)
								];
								var end = ctr;

								return [
									...arr,
									getHtml(
										Array(left.length).fill([]),
										ktx(expr.toTeXString(true)),
										`<td>${UP}</td><td>[<b>${start}</b>&ndash;<b>${end}</b>]</td>`
									)
								].join('');
							default:
								console.error(expr.error(`Unknown type ${expr._type}`));

								return getHtml(
									left,
									ktx(expr.toTeXString(true)),
									'<td colspan="2">???</td>'
								);
						}
					})(expr, [], []);

					html += '</table>';

					return html;
				}

				for (var k in program.scope.schemaMap) {
					var v = program.scope.schemaMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="schema-${k}" href="#schema-${k}"><b>${
							(v.axiomatic ? 'axiomatic ' : '')
							+ (v.native ? 'native ': '')
						}schema</b> ${k}</a>${v.native ? '' : `(${v.params.map(p => p.toSimpleString()).join(', ')})`}</p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`
						

						// + `<pre>${escapeHtml(v)}</pre>`

						+ (
							v.expr
								? v.axiomatic
									? ''
									: '<p class="label"><b>proof explorer</b></p>'
										+ `<p>${getProofExplorer(v.expr)}</p>`
								: ''
						)

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)

						+ (
							v.native || v.params.every(p => !p.guess)
								? ''
								: '<p class="label"><b>guesses</b></p>'
									+ `<ul>${v.params.filter(p => p.guess).map(p => {
										return `<li>${p.name}: @${p.guess}</li>`;
									}).join('')}</ul>`
						)

						+ `</div>`;

					arr[v._id] = r;
				}

				for (var k in program.scope.rulesetMap) {
					var v = program.scope.rulesetMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="ruleset-${k}" href="#ruleset-${k}"><b>${
							(v.axiomatic ? 'axiomatic ' : '')
							+ (v.native ? 'native ' : '')
						}ruleset</b> ${k}</a></p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ (
							v.axiomatic
								? '' : '<p class="label"><b>not proved</b></p>'
						)

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				end = new Date();
				console.log('--- HTML GENERATION END ---');
				console.log(`HTML generation ended in ${end - start} ms`);
				console.log('--- HTML RENDER START ---');
				start = new Date();

				$('#all').innerHTML =
					Object.keys(arr).sort((l, r) => l._id - r._id).map(k => arr[k]).join('');

				[].forEach.call($$('.katex a'), a => {
					var href = a.getAttribute('href');
					var idMatch = href.match(/^#id-([0-9]+)$/);
					var defMatch = href.match(/^#def-.+$/);

					if (idMatch) {
						a.dataset.orange = true;
						a.title = 'id: ' + idMatch[1];
					} else if (defMatch) {
						a.dataset.blue = true;
						a.title = a.getAttribute('href');
					} else {
						a.dataset.green = true;
						a.title = a.getAttribute('href');
					}
				});

				end = new Date();
				console.log('--- HTML RENDER END ---');
				console.log(`HTML render ended in ${end - start} ms`);

				} finally {
					loading = false;
				}
			}

			var reloading = false;

			$('#reload').addEventListener('click', () => {
				if (reloading) return;
				reloading = true;

				$('#reload').value = 'loading...';

				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load', () => {
					eval(xhr.responseText);
					try {
						load();
					} finally {
						$('#reload').value = 'RELOAD';
						reloading = false;
					}
				});
				xhr.addEventListener('error', () => {
					console.log('LOAD FAILED');
					$('#reload').value = 'RELOAD';
					reloading = false;
				});
				xhr.open('GET', './code.js');
				xhr.send();
			});

			load();
		</script>
	</body>
</html>