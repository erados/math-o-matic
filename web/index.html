<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>math-o-matic</title>
		<script src="../dist/math.js"></script>
		<script src="./code.js"></script>
		<script src="./native.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/m42kup@0.2.1/dist/m42kup.min.js"></script>
		<script src="https://unpkg.com/hotkeys-js/dist/hotkeys.min.js"></script>
		<script>
			m42kup.set({
				katex
			});

			$ = (q, n) => (n || document).querySelector(q);
			$$ = (q, n) => (n || document).querySelectorAll(q);
		</script>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
		<style>
			* {
				tab-size: 4;
				box-sizing: border-box;
			}

			body {
				font: 16px Roboto, sans-serif;
				font-weight: 400;
				-webkit-font-smoothing: antialiased;
				color: #5f6368;
				line-height: 1.5;
				word-break: normal;
				overflow-wrap: break-word;
			}

			h1, h2, h3, h4, h5, h6, a, b, strong, input, textarea, th, .katex {
				color: #202124;
			}

			p {
				margin: 0;
			}

			p + p {
				margin-top: 1em;
			}

			pre {
				white-space: pre-wrap;
			}

			table {
				border: 1px #ccc solid;
				border-collapse: collapse;
				margin: 1em 0;
			}

			table tr td, table tr th {
				padding: .2em .5em;
				border: 1px #ccc solid;
			}

			input[type=button], input[type=submit], button {
				background: none;
				border: none;
				border-radius: 3px;
				padding: 1ex 1em;
				cursor: pointer;
			}

			kbd {
				font: .85em 'Roboto Mono', monospace;
				color: #202124;
				border: 1px #ccc solid;
				padding: .1em .3em;
				border-radius: .2em;
			}

			.colored {
				background-color: #202124!important;
				color: #eee;
			}

			.block {
				padding: 1em;
				background-color: #fafafa;
				border: 1px #ccc solid;
				border-radius: 3px;
				margin: 1em 0;
			}

			.label {
				font-family: 'Roboto Mono', monospace, monospace;
			}

			.math {
				font-size: 1.2em;
				margin: 1em 0;
			}

			.katex a {
				text-decoration: none;
				color: inherit;
			}

			.katex a[data-blue] > :not(.mspace) {
				background-color: #E3F2FD;
				color: #303F9F;
			}

			.katex a[data-green] > :not(.mspace) {
				background-color: #E8F5E9;
				color: #006064;
			}

			.katex a[data-orange] {
				color: #E65100;
			}

			table.explorer td {
				white-space: nowrap;
			}

			table.explorer td.brb {
				border-right: 3px #222 solid;
				text-align: right;
				width: 1px;
			}

			table.explorer td.bbb {
				border-bottom: 3px #222 solid;
			}

			.red {
				 color: #D32F2F;
			}

			#search {
				height: 30px;
				vertical-align: middle;
				font: .85em Roboto, sans-serif;
			}

			#reload {
				height: 30px;
				vertical-align: middle;
			}

			#search-dropdown {
				background-color: white;
			}

			#search-dropdown ul {
				margin: 0;
				margin-top: .3em;
				padding: 0;
				border: 1px #666 solid;
			}

			#search-dropdown ul li {
				list-style: none;
			}

			#search-dropdown ul li:hover {
				background-color: #eee;
			}

			#search-dropdown ul li + li {
				border-top: 1px #666 solid;
			}

			#search-dropdown ul li.selected a::before {
				content: '> ';
				display: inline;
				font-weight: bold;
			}

			#search-dropdown ul li a {
				display: block;
				padding: .3em;
				color: #5f6368;
				text-decoration: none;
			}
		</style>
	</head>
	<body>
		<h1>math-o-matic</h1>
		<a href="https://github.com/logico-philosophical/math-o-matic">repo</a> &middot; <a href="../docs/build/index.html">docs</a>
		<h2>개요</h2>
		이 페이지는 math-o-matic으로 만들고 있는 공리계를 보여 줍니다.
		<h2>로컬에서 실행하는 방법</h2>
		<p>로컬에서 file 스킴으로 페이지를 불러왔을 경우 CORS 정책에 의해 페이지가 작동하지 않을 수 있습니다. 이때 다음과 같은 해결책이 있습니다.</p>
		<ul>
			<li> 로컬 서버를 통해 접속하기. 이는 npm의 <a href="https://www.npmjs.com/package/http-server">http-server</a> 패키지를 사용하여 할 수 있습니다.
			<li> Chrome의 경우 <code>--allow-file-access-from-files</code> 플래그를 통해 로컬 파일 로드를 가능하게 할 수 있습니다. <a href="https://stackoverflow.com/a/18137280">StackOverflow 링크</a>
		</ul>
		<h2>핫키</h2>
		<ul>
			<li><kbd>S</kbd>: 검색
			<li><kbd>R</kbd>: 다시 로드
			<li><kbd>&larr;</kbd>, <kbd>J</kbd>: 뒤로가기
			<li><kbd>K</kbd>: 앞으로 가기
		</ul>
		<h2>우상단 컨트롤에 관하여</h2>
		<ul>
			<li>검색창은 <kbd>S</kbd> 키를 눌러 활성화시킬 수 있으며 정의 및 스키마의 검색을 가능하게 합니다. <kbd>Tab</kbd> 및 <kbd>Shift</kbd> + <kbd>Tab</kbd> 및 <kbd>&darr;</kbd> 및 <kbd>&uarr;</kbd> 및 <kbd>Enter</kbd> 및 <kbd>Esc</kbd>를 써서 조작할 수 있으니 시도해 보세요.
			<li>reload 버튼은 <kbd>R</kbd> 키를 눌러 클릭할 수 있으며 <a href="./code.js">code.js</a> 파일을 다시 불러와서 목록을 재작성합니다. 단 그 과정에서 에러가 발생하였을 경우 이전 목록이 보존되므로 새로운 코드를 작성할 때 유용하게 사용할 수 있습니다.
		</ul>
		<h2>연산자 우선순위</h2>
		<div id="precedence">...</div>
		<h2>목록</h2>
		<p>이하의 내용은
			<a href="./code.js">code.js</a> 및
			<a href="./native.js">native.js</a>에 있는 코드를 렌더링 한 것입니다.</p>
		<div id="search-background" style="position:fixed;top:0;bottom:0;left:0;right:0;z-index:5000;display:none;"></div>
		<div style="position:fixed;top:5px;right:5px;z-index:10000;">
			<div>
				<input id="search" type="text" placeholder="search">
				<input id="reload" type="button" class="colored" value="reload" style="text-transform: uppercase;">
			</div>
			<div id="search-dropdown" style="display: none;">
				<ul></ul>
			</div>
			<script>
				(() => {
					hotkeys('s', (evt, handler) => {
						evt.preventDefault();
						$('#search').focus();
					});

					function getList(value) {
						value = value.toLowerCase();

						if (!program) return [];

						return Object.keys(program.scope.defMap).map(n => [n, 'def'])
							.concat(Object.keys(program.scope.schemaMap).map(n => [n, 'schema']))
							.map(([name, type]) => {
								var lowername = name.toLowerCase();

								var pname = 0;
								var matchptrs = [];

								for (var pval = 0; pval < value.length; pval++) {
									while (lowername[pname] != value[pval]) {
										pname++;
										if (pname >= name.length) return false;
									}

									matchptrs.push(pname);
								}

								return {name, type, match: matchptrs};
							}).filter(e => e).sort((a, b) => {
								for (var i = 0; i < a.match.length; i++) {
									if (a.match[i] != b.match[i])
										return a.match[i] - b.match[i];
								}

								return a.name.localeCompare(b.name);
							});
					}

					var listIndex = -1;
					var listlen = 10;
					var list = null;

					$('#search').addEventListener('keydown', evt => {
						if (evt.key == 'Tab'
								|| evt.key == 'ArrowDown'
								|| evt.key == 'ArrowUp') {
							evt.preventDefault();

							var len = Math.min(list.length, listlen);
							var downward = evt.key == 'ArrowDown'
								|| evt.key == 'Tab' && !evt.shiftKey;

							listIndex = !list
								? -1
								: listIndex >= 0
									? (listIndex + (downward ? 1 : len - 1)) % len
									: downward ? 0 : len - 1;

							[].map.call($$('#search-dropdown ul li'), (e, i) => {
								if (listIndex == i) {
									e.classList.add('selected');
								} else {
									e.classList.remove('selected');
								}
							});
						}

						if (evt.key == 'Enter') {
							evt.preventDefault();

							if (listIndex >= 0 || list.length == 1) {
								var {type, name} = list[list.length == 1 ? 0 : listIndex];
								destroy();
								location.href = `#${type}-${name}`;
							}
						}

						if (evt.key == 'Escape') {
							destroy();
						}
					});

					function show() {
						$('#search-dropdown').style.display = 'block';
						$('#search-background').style.display = 'block';

						listIndex = -1;
						[].map.call($$('#search-dropdown ul li'), (e, i) => {
							e.classList.remove('selected');
						});

						update($('#search').value);
					}

					function update(v) {
						listIndex = -1;

						$('#search-dropdown ul').innerHTML =
							!v ? ''
							: (list = getList(v)).slice(0, listlen).map(({name, type, match}) => {
								return `<li><a href="#${type}-${name}">${name.split('').map((n, i) => {
									if (match.includes(i)) return `<b>${n}</b>`;
									return n;
								}).join('')}</a></li>`;
							}).join('');

						$$('#search-dropdown ul li a').forEach(e => e.addEventListener('click', () => {
							$('#search').value = '';
							$('#search-dropdown ul').innerHTML = '';
							$('#search-dropdown').style.display = 'none';
							$('#search-background').style.display = 'none';
						}));
					}

					function dismiss() {
						$('#search-dropdown').style.display = 'none';
						$('#search-background').style.display = 'none';

						listIndex = -1;
						[].map.call($$('#search-dropdown ul li'), (e, i) => {
							e.classList.remove('selected');
						});
					}

					function destroy() {
						$('#search').value = '';
						$('#search-dropdown ul').innerHTML = '';
						$('#search-dropdown').style.display = 'none';
						$('#search-background').style.display = 'none';
						$('#search').blur();
						listIndex = -1;
						list = null;
					}

					$('#search').addEventListener('input', () => {
						update($('#search').value);
					});
					$('#search').addEventListener('focus', show);
					$('#search-background').addEventListener('click', dismiss);
				})();
			</script>
		</div>
		<div id="all"></div>
		<script>
			var katexOpts = {
				trust: context => {
					if (context.command != '\\href') return false;
					if (context.protocol != '_relative') return false;
					return true;
				}
			}

			var ktx = s => {
				var ret = '';
				try {
					ret = katex.renderToString(s, katexOpts);
				} catch (e) {
					console.error(`Error parsing ${s}`);
					throw Error(e);
				}

				return ret;
			}

			var escapeHtml = s => (s + '').replace(/[&<>"']/g, m => ({
			    '&': '&amp;', '<': '&lt;', '>': '&gt;',
			    '"': '&quot;', "'": '&#39;'
			})[m]);

			var loading = false;

			function load() {
				if (loading) return;
				loading = true;

				try {

				var start, end;

				console.log('--- PARSE START ---');
				start = new Date();
				var parsed;
				try {
					parsed = math.parser.parse(code);
				} catch (e) {
					console.error(e);
					console.error(`Error: ${e.message}\n\tat code.js:${e.location.start.line}:${e.location.start.column}`);
					console.log('--- PARSE FAILED ---');
					return;
				}

				end = new Date();
				console.log(parsed);
				console.log('--- PARSE END ---');
				console.log(`Parse ended in ${end - start} ms`);
				console.log('--- PROCESS START ---');
				start = new Date();

				program = new math.Program();
				program.feed(parsed, native);

				end = new Date();
				console.log(program);
				console.log('--- PROCESS END ---');
				console.log(`Process ended in ${end - start} ms`);
				console.log('--- HTML GENERATION START ---');
				start = new Date();

				var precedenceMap = new Map();

				for (var k in program.scope.defMap) {
					var prec = program.scope.defMap[k].precedence;
					if (prec) {
						if (precedenceMap.has(prec)) {
							precedenceMap.set(prec, precedenceMap.get(prec).concat([k]));
						} else {
							precedenceMap.set(prec, [k]);
						}	
					}
				}

				precedenceMap = [...precedenceMap].sort((a, b) => a[0] - b[0]);

				$('#precedence').innerHTML = `
				<p>현재 연산자 우선순위는 다음과 같습니다.</p>

				<table>
					<tr><td>우선순위</td><td>연산자</td></tr>
					${precedenceMap.map(([k, v]) => {
						return `<tr><td>${k}</td><td>${v.map(w => {
							return `<a href="#def-${w}">${w}</a>`;
						}).join(', ')}</td></tr>`;
					}).join('')}
				</table>

				<p>위 표는 자동으로 생성되었습니다.</p>`;

				var arr = {}, r;

				for (var k in program.scope.typedefMap) {
					var v = program.scope.typedefMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="type-${k}" href="#type-${k}"><b>${
							(v.isBaseType ? 'base ' : '')
						}type</b> ${k}</a></p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				for (var k in program.scope.defMap) {
					var v = program.scope.defMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="def-${k}" href="#def-${k}"><b>definition</b> ${k}</a>${v.type.isSimple
								? ''
								: `(${v.params.map(p => p.toSimpleString()).join(', ')})`
									+ `: ${v.type.resolve().to}`
						}</p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				function getProofExplorer(expr) {
					var ctr = 0;

					var DIAMOND = '&#x25C7;',
						DOWN = '&#x25BC;',
						UP = '&#x25B2;';


					var ncols = (function recurse(expr) {
						switch (expr._type) {
							case 'reduction':
								return Math.max(
									...expr.leftargs.map(recurse),
									((expr.subject._type == 'schema' && expr.subject.name)
										|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)
											? 0 : recurse(expr.subject)),
									1
								);
							case 'schema':
							case 'fun':
								return recurse(expr.expr) + 1;
							case 'tee':
								return Math.max(
									...expr.left.map(recurse),
									recurse(expr.right)
								) + 1;
							case 'schemacall':
							case 'funcall':
							default:
								return 1;
						}
					})(expr);

					var html = '<table class="explorer">';
					html += `<tr><th>#</th><th colspan="${ncols}">expr</th><th colspan="2">rule</th></tr>`;

					function getHtml(left, h1, h2, bbb, noctr) {
						var padding = left.length;

						var htmlLeft = left.map(e => `<td class="brb">${e.map(f => ktx(f.toTeXString(true))).join(', ')}</td>`).join('');

						return `<tr><th>${noctr ? '' : ++ctr}</th>${htmlLeft}<td ${bbb ? 'class="bbb"' : ''} colspan="${ncols-padding}">${h1}</td>${h2}</tr>`;
					}

					function getHypNo(hyps, expr) {
						for (var i = 0; i < hyps.length; i++) {
							var [hyp, lineno] = hyps[i];

							if (program.ExpressionResolver.equalsMeta(hyp, expr)) {
								return lineno;
							}
						}

						return false;
					}

					html += (function recurse(expr, left, hyps) {
						var hypno = getHypNo(hyps, expr);

						if (hypno) {
							return getHtml(
								left,
								ktx(expr.toTeXString(true)),
								`<td>${DIAMOND}</td><td>[<b>${hypno}</b>]</td>`
							);
						}

						switch (expr._type) {
							case 'reduction':
								var leftPrinted = false;

								var leftargs = expr.leftargs.map(leftarg => {
									var hypno = getHypNo(hyps, leftarg);

									if (hypno) {
										return [false, hypno];
									}

									if (!leftPrinted) {
										leftPrinted = true;
									} else {
										left = Array(left.length).fill([]);
									}

									return [
										recurse(
											leftarg,
											left,
											hyps
										),
										ctr
									];
								});

								if (leftPrinted) {
									left = Array(left.length).fill([]);
								}

								if ((expr.subject._type == 'schema' && expr.subject.name)
										|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)) {
									return [
										leftargs.map(e => e[0]).filter(e => e).join(''),
										getHtml(
											left,
											ktx(expr.reduced.toTeXString(true)),
											`<td>${DOWN}</td><td>${ktx(expr.subject.toTeXString(true))} [${leftargs.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
										)
									].join('');
								}

								var subject = (() => {
									var hypno = getHypNo(hyps, expr.subject);

									if (hypno) {
										return [false, hypno];
									}

									if (!leftPrinted) {
										leftPrinted = true;
									} else {
										left = Array(left.length).fill([]);
									}

									return [
										recurse(
											expr.subject,
											left,
											hyps
										),
										ctr
									];
								})();

								if (leftPrinted) {
									left = Array(left.length).fill([]);
								}

								return [
									leftargs.map(e => e[0]).filter(e => e).join(''),
									subject[0] || '',
									getHtml(
										left,
										ktx(expr.reduced.toTeXString(true)),
										`<td>${DOWN}</td><td><b>${subject[1]}</b> [${leftargs.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
									)
								].join('');
							case 'schemacall':
								if (expr.schema.name) {
									return getHtml(
										left,
										ktx(expr.expanded.toTeXString(true)),
										`<td>${DIAMOND}</td><td>${ktx(expr.toTeXString(true))}</td>`
									);
								}

								var hypno = getHypNo(hyps, expr.schema);

								if (hypno) {
									return getHtml(
										left,
										ktx(expr.expanded.toTeXString(true)),
										`<td>${DIAMOND}</td><td><b>${hypno}</b> (${expr.args.map(arg => ktx(arg.toTeXString(true))).join(', ')})</td>`
									);
								}

								return getHtml(
									left,
									ktx(expr.expanded.toTeXString(true)),
									'<td colspan="2"><b class="red">not proved</b></td>'
								);
							case 'funcall':
							case 'typevar':
								return getHtml(
									left,
									ktx(expr.toTeXString(true)),
									'<td colspan="2"><b class="red">not proved</b></td>'
								);
							case 'schema':
							case 'fun':
								if (expr.name) {
									return getHtml(
										left,
										ktx(expr.toTeXString(true, true)),
										`<td>${DIAMOND}</td><td>${ktx(expr.toTeXString(true))}</td>`
									);
								}

								return recurse(
									expr.expr,
									left.concat([expr.params]),
									hyps
								);
							case 'tee':
								var start = ctr + 1;
								var arr = [
									...(
										expr.left.length
											? expr.left.map((e, i, a) => getHtml(
												(i == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
												ktx(e.toTeXString(true)),
												'<td colspan="2">assumption</td>',
												i == a.length - 1
											))
											: [getHtml(
												Array(left.length + 1).fill([]),
												'',
												'<td colspan="2"></td>',
												true,
												true
											)]
									),
									recurse(
										expr.right,
										(expr.left.length == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
										hyps.concat(expr.left.map((e, i) => [e, start + i]))
									)
								];
								var end = ctr;

								return [
									...arr,
									getHtml(
										Array(left.length).fill([]),
										ktx(expr.toTeXString(true)),
										`<td>${UP}</td><td>[<b>${start}</b>&ndash;<b>${end}</b>]</td>`
									)
								].join('');
							default:
								console.error(expr.error(`Unknown type ${expr._type}`));

								return getHtml(
									left,
									ktx(expr.toTeXString(true)),
									'<td colspan="2">???</td>'
								);
						}
					})(expr, [], []);

					html += '</table>';

					return html;
				}

				for (var k in program.scope.schemaMap) {
					var v = program.scope.schemaMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="schema-${k}" href="#schema-${k}"><b>${
							(v.axiomatic ? 'axiomatic ' : '')
							+ (v.native ? 'native ': '')
						}schema</b> ${k}</a>${v.native ? '' : `(${v.params.map(p => p.toSimpleString()).join(', ')})`}</p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`
						

						// + `<pre>${escapeHtml(v)}</pre>`

						+ (
							v.expr
								? v.axiomatic
									? ''
									: '<p class="label"><b>proof explorer</b></p>'
										+ `<p>${getProofExplorer(v.expr)}</p>`
								: ''
						)

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)

						+ (
							v.native || v.params.every(p => !p.guess)
								? ''
								: '<p class="label"><b>guesses</b></p>'
									+ `<ul>${v.params.filter(p => p.guess).map(p => {
										return `<li>${p.name}: @${p.guess}</li>`;
									}).join('')}</ul>`
						)

						+ `</div>`;

					arr[v._id] = r;
				}

				for (var k in program.scope.rulesetMap) {
					var v = program.scope.rulesetMap[k];

					r = `<div class="block">`
						+ `<p class="label"><a id="ruleset-${k}" href="#ruleset-${k}"><b>${
							(v.axiomatic ? 'axiomatic ' : '')
							+ (v.native ? 'native ' : '')
						}ruleset</b> ${k}</a></p>`
						+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

						+ (
							v.axiomatic
								? '' : '<p class="label"><b>not proved</b></p>'
						)

						+ '<p class="label"><b>description</b></p>'
						+ (
							v.doc
							? `<p class="description">${m42kup.render(v.doc)}</p>`
							: '<p class="description"><i>No description provided.</i></p>'
						)
						// + `<pre>${escapeHtml(v)}</pre>`
						+ `</div>`;

					arr[v._id] = r;
				}

				end = new Date();
				console.log('--- HTML GENERATION END ---');
				console.log(`HTML generation ended in ${end - start} ms`);
				console.log('--- HTML RENDER START ---');
				start = new Date();

				$('#all').innerHTML =
					Object.keys(arr).sort((l, r) => l._id - r._id).map(k => arr[k]).join('');

				[].forEach.call($$('.katex a'), a => {
					var href = a.getAttribute('href');
					var idMatch = href.match(/^#id-([0-9]+)$/);
					var defMatch = href.match(/^#def-.+$/);

					if (idMatch) {
						a.dataset.orange = true;
						a.title = 'id: ' + idMatch[1];
					} else if (defMatch) {
						a.dataset.blue = true;
						a.title = a.getAttribute('href');
					} else {
						a.dataset.green = true;
						a.title = a.getAttribute('href');
					}
				});

				end = new Date();
				console.log('--- HTML RENDER END ---');
				console.log(`HTML render ended in ${end - start} ms`);

				} finally {
					loading = false;
				}
			}

			var reloading = false;

			hotkeys('r', (evt, handler) => {
				evt.preventDefault();
				reload();
			});

			hotkeys('backspace,j', (evt, handler) => {
				evt.preventDefault();
				history.back();
			});

			hotkeys('k', (evt, handler) => {
				evt.preventDefault();
				history.forward();
			});

			function reload() {
				if (reloading) return;
				reloading = true;

				$('#reload').value = 'reloading...';

				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load', () => {
					try {
						eval(xhr.responseText);
						load();
					} finally {
						$('#reload').value = 'RELOAD';
						reloading = false;
					}
				});
				xhr.addEventListener('error', () => {
					console.log('LOAD FAILED');
					$('#reload').value = 'RELOAD';
					reloading = false;
				});
				xhr.open('GET', './code.js');
				xhr.send();
			}

			$('#reload').addEventListener('click', reload);

			load();
		</script>
	</body>
</html>