<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>M42/math</title>
		<script src="../dist/math.js"></script>
		<script src="./code.js"></script>
		<script src="./native.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/m42kup@0.2.1/dist/m42kup.min.js"></script>
		<script>
			m42kup.set({
				katex
			});
		</script>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
		<style>
			* {
				tab-size: 4;
			}

			body {
				font: 16px Roboto, sans-serif;
				font-weight: 400;
				-webkit-font-smoothing: antialiased;
				color: #5f6368;
				line-height: 1.5;
				word-break: normal;
				overflow-wrap: break-word;
			}

			h1, h2, h3, h4, h5, h6, a, b, strong, input, textarea, th, .katex {
				color: #202124;
			}

			p {
				margin: 0;
			}

			p + p {
				margin-top: 1em;
			}

			pre {
				white-space: pre-wrap;
			}

			table {
				border: 1px #ccc solid;
				border-collapse: collapse;
				margin: 1em 0;
			}

			table tr td, table tr th {
				padding: .2em .5em;
				border: 1px #ccc solid;
			}

			.block {
				padding: 1em;
				background-color: #fafafa;
				border: 1px #ccc solid;
				border-radius: 3px;
				margin: 1em 0;
			}

			.label {
				font-family: 'Roboto Mono', monospace, monospace;
			}

			.math {
				font-size: 1.2em;
				margin: 1em 0;
			}

			.katex a {
				text-decoration: none;
				color: inherit;
			}

			.katex a[data-blue] > :not(.mspace) {
				background-color: #E3F2FD;
				color: #303F9F;
			}

			.katex a[data-green] > :not(.mspace) {
				background-color: #E8F5E9;
				color: #006064;
			}

			.katex a[data-orange] {
				color: #E65100;
			}
		</style>
	</head>
	<body>
		<script type="text/m42kup">
[=M42/math]

[~(href=https://github.com/logico-philosophical/math)repo] [&middot] [~(href=../docs/build/index.html)docs]
		</script>
		<h2>목록</h2>
		<p>이하의 내용은
			<a href="./code.js">code.js</a> 및
			<a href="./native.js">native.js</a>에 있는 코드를 렌더링 한 것입니다.</p>
		<div id="all"></div>
		<script>
			$ = (q, n) => (n || document).querySelector(q);
			$$ = (q, n) => (n || document).querySelectorAll(q);

			var katexOpts = {
				trust: context => {
					if (context.command != '\\href') return false;
					if (context.protocol != '_relative') return false;
					return true;
				}
			}

			var ktx = s => katex.renderToString(s, katexOpts);

			var escapeHtml = s => (s + '').replace(/[&<>"']/g, m => ({
			    '&': '&amp;', '<': '&lt;', '>': '&gt;',
			    '"': '&quot;', "'": '&#39;'
			})[m]);

			[].forEach.call($$('script[type="text/m42kup"]'), $script => {
				var $div = document.createElement('div');
				$div.innerHTML = m42kup.render($script.text);
				$script.parentNode.insertBefore($div, $script);
			});

			(() => {

			var start, end;

			console.log('--- PARSE START ---');
			start = new Date();
			var parsed;
			try {
				parsed = math.parser.parse(code);
			} catch (e) {
				console.error(e);
				console.error(`Error: ${e.message}\n\tat code.js:${e.location.start.line}:${e.location.start.column}`);
				console.log('--- PARSE FAILED ---');
				return;
			}

			end = new Date();
			console.log(parsed);
			console.log('--- PARSE END ---');
			console.log(`Parse ended in ${end - start} ms`);
			console.log('--- PROCESS START ---');
			start = new Date();

			program = new math.Program();
			program.feed(parsed, native);

			end = new Date();
			console.log(program);
			console.log('--- PROCESS END ---');
			console.log(`Process ended in ${end - start} ms`);
			console.log('--- HTML GENERATION START ---');
			start = new Date();

			var arr = {}, r;

			for (var k in program.scope.typedefMap) {
				var v = program.scope.typedefMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="type-${k}" href="#type-${k}"><b>${
						(v.isBaseType ? 'base ' : '')
					}type</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true))}</div>`

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			for (var k in program.scope.defMap) {
				var v = program.scope.defMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="def-${k}" href="#def-${k}"><b>definition</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true))}</div>`

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			function generateExpressionTree(expr) {
				var ctr = 0;

				var html = '<table>';
				html += '<tr><th>#</th><th>expr</th><th>rule</th></tr>'

				html += (function recurse(expr) {
					switch (expr._type) {
						case 'reduction2':
							var args = expr.args.map((arg, i) => {
								return [recurse(expr.args[i]), ctr];
							});

							return [
								args.map(e => e[0]).join(''),
								`<tr><th>${++ctr}</th><td>${ktx(expr.reduced.toTeXString())}</td><td>${ktx(expr.expr2.toTeXString())} [${args.map(e => `<b>${e[1]}</b>`).join(', ')}]</td></tr>`
							].join('');
						case 'rulecall':
							return `<tr><th>${++ctr}</th><td>${ktx(expr.expanded.toTeXString())}</td><td>${ktx(expr.toTeXString())}</td></tr>`;
						default:
							return ktx(expr.toTeXString());
					}
				})(expr);

				html += '</table>';

				return html;
			}

			for (var k in program.scope.ruleMap) {
				var v = program.scope.ruleMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="rule-${k}" href="#rule-${k}"><b>${
						v.axiomatic ? 'axiomatic ' : ''
					}rule</b> ${k}</a>(${v.params.map(p => p.toSimpleString()).join(', ')})</p>`
					+ `<div class="math">${ktx(v.toTeXString(true))}</div>`
					

					// + `<pre>${escapeHtml(v)}</pre>`

					+ (
						v.expr._type == 'tee'
							? v.axiomatic
								? ''
								: '<p class="label"><b>not proved</b></p>'
							: '<p class="label"><b>proof explorer</b></p>'
								+ `<p>${generateExpressionTree(v.expr)}</p>`
					)

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)

					+ `</div>`;

				arr[v._id] = r;
			}

			for (var k in program.scope.linkMap) {
				var v = program.scope.linkMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="link-${k}" href="#link-${k}"><b>${
						(v.axiomatic ? 'axiomatic ' : '')
						+ (v.native ? 'native ': '')
					}link</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true))}</div>`

					+ (
						v.axiomatic
							? '' : '<p class="label"><b>not proved</b></p>'
					)

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			for (var k in program.scope.rulesetMap) {
				var v = program.scope.rulesetMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="ruleset-${k}" href="#ruleset-${k}"><b>${
						(v.axiomatic ? 'axiomatic ' : '')
						+ (v.native ? 'native ' : '')
					}ruleset</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true))}</div>`

					+ (
						v.axiomatic
							? '' : '<p class="label"><b>not proved</b></p>'
					)

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			end = new Date();
			console.log('--- HTML GENERATION END ---');
			console.log(`HTML generation ended in ${end - start} ms`);
			console.log('--- HTML RENDER START ---');
			start = new Date();

			$('#all').innerHTML +=
				Object.keys(arr).sort((l, r) => l._id - r._id).map(k => arr[k]).join('');

			[].forEach.call($$('.katex a'), a => {
				var href = a.getAttribute('href');
				var idMatch = href.match(/^#id-([0-9]+)$/);
				var defMatch = href.match(/^#def-.+$/);

				if (idMatch) {
					a.dataset.orange = true;
					a.title = 'id: ' + idMatch[1];
				} else if (defMatch) {
					a.dataset.blue = true;
					a.title = a.getAttribute('href');
				} else {
					a.dataset.green = true;
					a.title = a.getAttribute('href');
				}
			});

			end = new Date();
			console.log('--- HTML RENDER END ---');
			console.log(`HTML render ended in ${end - start} ms`);

			})();
		</script>
	</body>
</html>