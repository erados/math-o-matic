<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>math-o-matic</title>
		<script src="../dist/math.js"></script>
		<script src="./code.js"></script>
		<script src="./native.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/m42kup@0.2.1/dist/m42kup.min.js"></script>
		<script>
			m42kup.set({
				katex
			});
		</script>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
		<style>
			* {
				tab-size: 4;
			}

			body {
				font: 16px Roboto, sans-serif;
				font-weight: 400;
				-webkit-font-smoothing: antialiased;
				color: #5f6368;
				line-height: 1.5;
				word-break: normal;
				overflow-wrap: break-word;
			}

			h1, h2, h3, h4, h5, h6, a, b, strong, input, textarea, th, .katex {
				color: #202124;
			}

			p {
				margin: 0;
			}

			p + p {
				margin-top: 1em;
			}

			pre {
				white-space: pre-wrap;
			}

			table {
				border: 1px #ccc solid;
				border-collapse: collapse;
				margin: 1em 0;
			}

			table tr td, table tr th {
				padding: .2em .5em;
				border: 1px #ccc solid;
			}

			.block {
				padding: 1em;
				background-color: #fafafa;
				border: 1px #ccc solid;
				border-radius: 3px;
				margin: 1em 0;
			}

			.label {
				font-family: 'Roboto Mono', monospace, monospace;
			}

			.math {
				font-size: 1.2em;
				margin: 1em 0;
			}

			.katex a {
				text-decoration: none;
				color: inherit;
			}

			.katex a[data-blue] > :not(.mspace) {
				background-color: #E3F2FD;
				color: #303F9F;
			}

			.katex a[data-green] > :not(.mspace) {
				background-color: #E8F5E9;
				color: #006064;
			}

			.katex a[data-orange] {
				color: #E65100;
			}

			table.explorer td {
				white-space: nowrap;
			}

			table.explorer td.brb {
				border-right: 3px #222 solid;
				text-align: right;
				width: 1px;
			}

			table.explorer td.bbb {
				border-bottom: 3px #222 solid;
			}

			.red {
				 color: #D32F2F;
			}
		</style>
	</head>
	<body>
		<h1>math-o-matic</h1>
		<a href="https://github.com/logico-philosophical/math-o-matic">repo</a> &middot; <a href="../docs/build/index.html">docs</a>
		<h2>목록</h2>
		<p>이하의 내용은
			<a href="./code.js">code.js</a> 및
			<a href="./native.js">native.js</a>에 있는 코드를 렌더링 한 것입니다.</p>
		<div id="all"></div>
		<script>
			(() => {

			$ = (q, n) => (n || document).querySelector(q);
			$$ = (q, n) => (n || document).querySelectorAll(q);

			var katexOpts = {
				trust: context => {
					if (context.command != '\\href') return false;
					if (context.protocol != '_relative') return false;
					return true;
				}
			}

			var ktx = s => {
				var ret = '';
				try {
					ret = katex.renderToString(s, katexOpts);
				} catch (e) {
					console.error(`Error parsing ${s}`);
					throw Error(e);
				}

				return ret;
			}

			var escapeHtml = s => (s + '').replace(/[&<>"']/g, m => ({
			    '&': '&amp;', '<': '&lt;', '>': '&gt;',
			    '"': '&quot;', "'": '&#39;'
			})[m]);

			var start, end;

			console.log('--- PARSE START ---');
			start = new Date();
			var parsed;
			try {
				parsed = math.parser.parse(code);
			} catch (e) {
				console.error(e);
				console.error(`Error: ${e.message}\n\tat code.js:${e.location.start.line}:${e.location.start.column}`);
				console.log('--- PARSE FAILED ---');
				return;
			}

			end = new Date();
			console.log(parsed);
			console.log('--- PARSE END ---');
			console.log(`Parse ended in ${end - start} ms`);
			console.log('--- PROCESS START ---');
			start = new Date();

			program = new math.Program();
			program.feed(parsed, native);

			end = new Date();
			console.log(program);
			console.log('--- PROCESS END ---');
			console.log(`Process ended in ${end - start} ms`);
			console.log('--- HTML GENERATION START ---');
			start = new Date();

			var arr = {}, r;

			for (var k in program.scope.typedefMap) {
				var v = program.scope.typedefMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="type-${k}" href="#type-${k}"><b>${
						(v.isBaseType ? 'base ' : '')
					}type</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			for (var k in program.scope.defMap) {
				var v = program.scope.defMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="def-${k}" href="#def-${k}"><b>definition</b> ${k}</a>${v.type.isSimple ? '' : `(${v.params.map(p => p.toSimpleString()).join(', ')})`}</p>`
					+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			function getProofExplorer(expr) {
				var ctr = 0;

				var DIAMOND = '&#x25C7;',
					DOWN = '&#x25BC;',
					UP = '&#x25B2;';


				var ncols = (function recurse(expr) {
					switch (expr._type) {
						case 'reduction':
							return Math.max(
								...expr.args.map(recurse),
								((expr.subject._type == 'schema' && expr.subject.name)
									|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)
										? 0 : recurse(expr.subject)),
								1
							);
						case 'schemacall':
						case 'funcall':
							return 1;
						case 'schema':
						case 'fun':
							return recurse(expr.expr) + 1;
						case 'tee':
							return Math.max(
								...expr.left.map(recurse),
								recurse(expr.right)
							) + 1;
						default:
							return 1;
					}
				})(expr);

				var html = '<table class="explorer">';
				html += `<tr><th>#</th><th colspan="${ncols}">expr</th><th colspan="2">rule</th></tr>`;

				function getHtml(left, h1, h2, bbb, noctr) {
					var padding = left.length;

					var htmlLeft = left.map(e => `<td class="brb">${e.map(f => ktx(f.toTeXString(true))).join(', ')}</td>`).join('');

					return `<tr><th>${noctr ? '' : ++ctr}</th>${htmlLeft}<td ${bbb ? 'class="bbb"' : ''} colspan="${ncols-padding}">${h1}</td>${h2}</tr>`;
				}

				function getHypNo(hyps, expr) {
					for (var i = 0; i < hyps.length; i++) {
						var [hyp, lineno] = hyps[i];

						if (program.ExpressionResolver.equalsMeta(hyp, expr)) {
							return lineno;
						}
					}

					return false;
				}

				html += (function recurse(expr, left, hyps) {
					var hypno = getHypNo(hyps, expr);

					if (hypno) {
						return getHtml(
							left,
							ktx(expr.toTeXString(true)),
							`<td>${DIAMOND}</td><td>[<b>${hypno}</b>]</td>`
						);
					}

					switch (expr._type) {
						case 'reduction':
							var leftPrinted = false;

							var args = expr.args.map(arg => {
								var hypno = getHypNo(hyps, arg);

								if (hypno) {
									return [false, hypno];
								}

								if (!leftPrinted) {
									leftPrinted = true;
								} else {
									left = Array(left.length).fill([]);
								}

								return [
									recurse(
										arg,
										left,
										hyps
									),
									ctr
								];
							});

							if (leftPrinted) {
								left = Array(left.length).fill([]);
							}

							if ((expr.subject._type == 'schema' && expr.subject.name)
									|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)) {
								return [
									args.map(e => e[0]).filter(e => e).join(''),
									getHtml(
										left,
										ktx(expr.reduced.toTeXString(true)),
										`<td>${DOWN}</td><td>${ktx(expr.subject.toTeXString(true))} [${args.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
									)
								].join('');
							}

							var subject = (() => {
								var hypno = getHypNo(hyps, expr.subject);

								if (hypno) {
									return [false, hypno];
								}

								if (!leftPrinted) {
									leftPrinted = true;
								} else {
									left = Array(left.length).fill([]);
								}

								return [
									recurse(
										expr.subject,
										left,
										hyps
									),
									ctr
								];
							})();

							return [
								args.map(e => e[0]).filter(e => e).join(''),
								subject[0] || '',
								getHtml(
									left,
									ktx(expr.reduced.toTeXString(true)),
									`<td>${DOWN}</td><td><b>${subject[1]}</b> [${args.map(e => `<b>${e[1]}</b>`).join(', ')}]</td>`
								)
							].join('');
						case 'schemacall':
							return getHtml(
								left,
								ktx(expr.expanded.toTeXString(true)),
								`<td>${DIAMOND}</td><td>${ktx(expr.toTeXString(true))}</td>`
							);
						case 'funcall':
							return getHtml(
								left,
								ktx(expr.toTeXString(true)),
								'<td colspan="2"><b class="red">not proved</b></td>'
							);
						case 'schema':
						case 'fun':
							return recurse(
								expr.expr,
								left.concat([expr.params]),
								hyps
							);
						case 'tee':
							var start = ctr + 1;
							var arr = [
								...(
									expr.left.length
										? expr.left.map((e, i, a) => getHtml(
											(i == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
											ktx(e.toTeXString(true)),
											'<td colspan="2">assumption</td>',
											i == a.length - 1
										))
										: [getHtml(
											Array(left.length + 1).fill([]),
											'',
											'<td colspan="2"></td>',
											true,
											true
										)]
								),
								recurse(
									expr.right,
									(expr.left.length == 0 ? left.concat([[]]) : Array(left.length + 1).fill([])),
									hyps.concat(expr.left.map((e, i) => [e, start + i]))
								)
							];
							var end = ctr;

							return [
								...arr,
								getHtml(
									Array(left.length).fill([]),
									ktx(expr.toTeXString(true)),
									`<td>${UP}</td><td>[<b>${start}</b>&ndash;<b>${end}</b>]</td>`
								)
							].join('');
						default:
							console.error(expr.error(`Unknown type ${expr._type}`));

							return getHtml(
								left,
								ktx(expr.toTeXString(true)),
								'<td colspan="2">???</td>'
							);
					}
				})(expr, [], []);

				html += '</table>';

				return html;
			}

			for (var k in program.scope.schemaMap) {
				var v = program.scope.schemaMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="schema-${k}" href="#schema-${k}"><b>${
						(v.axiomatic ? 'axiomatic ' : '')
						+ (v.native ? 'native ': '')
					}schema</b> ${k}</a>${v.native ? '' : `(${v.params.map(p => p.toSimpleString()).join(', ')})`}</p>`
					+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`
					

					// + `<pre>${escapeHtml(v)}</pre>`

					+ (
						v.expr
							? v.axiomatic
								? ''
								: '<p class="label"><b>proof explorer</b></p>'
									+ `<p>${getProofExplorer(v.expr)}</p>`
							: ''
					)

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)

					+ `</div>`;

				arr[v._id] = r;
			}

			for (var k in program.scope.rulesetMap) {
				var v = program.scope.rulesetMap[k];

				r = `<div class="block">`
					+ `<p class="label"><a id="ruleset-${k}" href="#ruleset-${k}"><b>${
						(v.axiomatic ? 'axiomatic ' : '')
						+ (v.native ? 'native ' : '')
					}ruleset</b> ${k}</a></p>`
					+ `<div class="math">${ktx(v.toTeXString(true, true))}</div>`

					+ (
						v.axiomatic
							? '' : '<p class="label"><b>not proved</b></p>'
					)

					+ '<p class="label"><b>description</b></p>'
					+ (
						v.doc
						? `<p class="description">${m42kup.render(v.doc)}</p>`
						: '<p class="description"><i>No description provided.</i></p>'
					)
					// + `<pre>${escapeHtml(v)}</pre>`
					+ `</div>`;

				arr[v._id] = r;
			}

			end = new Date();
			console.log('--- HTML GENERATION END ---');
			console.log(`HTML generation ended in ${end - start} ms`);
			console.log('--- HTML RENDER START ---');
			start = new Date();

			$('#all').innerHTML +=
				Object.keys(arr).sort((l, r) => l._id - r._id).map(k => arr[k]).join('');

			[].forEach.call($$('.katex a'), a => {
				var href = a.getAttribute('href');
				var idMatch = href.match(/^#id-([0-9]+)$/);
				var defMatch = href.match(/^#def-.+$/);

				if (idMatch) {
					a.dataset.orange = true;
					a.title = 'id: ' + idMatch[1];
				} else if (defMatch) {
					a.dataset.blue = true;
					a.title = a.getAttribute('href');
				} else {
					a.dataset.green = true;
					a.title = a.getAttribute('href');
				}
			});

			end = new Date();
			console.log('--- HTML RENDER END ---');
			console.log(`HTML render ended in ${end - start} ms`);

			})();
		</script>
	</body>
</html>