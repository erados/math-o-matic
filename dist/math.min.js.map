{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Variable.ts","webpack://math/./src/nodes/Fun.ts","webpack://math/./src/nodes/$Variable.ts","webpack://math/./src/ExpressionResolver.ts","webpack://math/./src/nodes/Funcall.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/Reduction.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts","webpack://math/./node_modules/process/browser.js","webpack://math/./src/PegInterface.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","scope","_id","toIndentedString","message","error","Error","replace","tex","precedence","code","match","g1","hyps","length","prec","Array","console","log","my","normalizePrecedence","your","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","Type","super","doc","isBaseType","base","origin","isFunctional","isSimple","functional","from","map","f","some","e","to","resolved","resolve","toSimpleString","join","indent","toTeXString","equals","Variable","type","isParam","guess","isProved","escapeTeX","Fun","isSchema","annotations","axiomatic","params","def$s","expr","parseTeX","variable","proved","repeat","expandMetaAndFuncalls","toTeXStringWithId","funcallToTeXString","arg","makeTeX","$Variable","iscall","a","makecall","fun","ExpressionResolver","substitute","has","left","right","reduced","callee","Map","set","expandCallOnce","callee_","expandMeta","b","recurseWrap","recurse","depth","aHasFunExpr","bHasFunExpr","every","_","placeholders","len","push","nequalscall","nequalstrue","nrecursecall","nrecursetrue","Funcall","resolvedType","paramTypes","argTypes","Tee","$","concat","expanded","MetaType","Reduction","subject","guesses","leftargs","expected","forEach","derefs","tee","query","leftargTypes","lef","that","node","ptr","test","grammar","default","Program","parser","scopeMap","filename","loader","loadModuleInternal","parsed","parse","feed","lines","line","_type","scope2","importMap","hasType","addType","hasVariable","addVariable","addFun","schema","hasSchema","addSchema","reduction","schemacall","metavar","ktx","DIAMOND","theexpr","getSchema","ncols","Math","max","getHtmlLine","h1","h2","options","padding","bbb","rrb","htmlLeft","pop","exprToHtml","expand","tree","getTree","hypnumMap","$Map","num","leftarglines","leftargnums","subjectlines","subjectnum","schemalines","start","$lines","$num","slice","leftlines","rightlines","html","tree2html","newleft","fill","Scope","parent","trace","typedefMap","defMap","schemaMap","hypotheses","baseType","location","child","extend","h","values","hasOwnType","broadcast","getType","filter","hasOwnVariable","getVariable","hasOwnSchema","hasOwn$","has$","get$","StackTrace","stack","process","argv","column","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","runClearTimeout","marker","Item","array","noop","nextTick","arguments","apply","title","browser","env","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","typeObjToString","obj","ftype","typeObjToNestedArr","PI","parentScope","includes","tvo","tv","rettype","expr0","funcall","hypnum","Number","metaexpr","scopeRight","$v","def$","add$","g"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","import Scope from '../Scope';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';\r\n\r\nvar ctr = 0;\r\n\r\nexport type Precedence = boolean | number | [number, number];\r\n\r\nexport default abstract class Node {\r\n\tpublic readonly _id: number;\r\n\tpublic readonly scope: Scope;\r\n\r\n\tpublic type: Type | MetaType;\r\n\tpublic doc: string;\r\n\tpublic tex: string;\r\n\tpublic precedence: Precedence;\r\n\r\n\tpublic static readonly PREC_FUNEXPR = 1000;\r\n\tpublic static readonly PREC_COMMA = 1000;\r\n\tpublic static readonly PREC_COLONEQQ = 100000;\r\n\r\n\tconstructor (scope?: Scope) {\r\n\t\tthis._id = ++ctr;\r\n\t\tthis.scope = scope;\r\n\t}\r\n\r\n\tpublic toString() {\r\n\t\treturn this.toIndentedString(0);\r\n\t}\r\n\r\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\r\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\r\n\r\n\tpublic error(message) {\r\n\t\tif (this.scope) {\r\n\t\t\treturn this.scope.error(message);\r\n\t\t} else {\r\n\t\t\treturn new Error(message);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static escapeTeX(s) {\r\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\r\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\r\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\r\n\t\t\t'}': '\\\\}',\r\n\t\t\t'~': '\\\\textasciitilde',\r\n\t\t\t'^': '\\\\textasciicircum',\r\n\t\t\t'\\\\': '\\\\textbackslash'\r\n\t\t})[m]);\r\n\t}\r\n\r\n\tpublic static parseTeX(tex) {\r\n\t\tvar precedence: Precedence = false;\r\n\r\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\r\n\t\t\tprecedence = g1 * 1;\r\n\t\t\treturn '';\r\n\t\t});\r\n\r\n\t\treturn {precedence, code};\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\r\n\t\tfor (var i = 0; i < hyps.length; i++) {\r\n\t\t\tif (hyps[i] == this) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t* false corresponds to 0.\r\n\t* true corresponds to w * 2.\r\n\t*/\r\n\tpublic static normalizePrecedence(prec: Precedence) {\r\n\t\tif (prec === false) return [0, 0];\r\n\t\tif (prec === true) return [2, 0];\r\n\t\tif (typeof prec == 'number') return [0, prec];\r\n\r\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\r\n\t\t\tconsole.log(prec);\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn prec;\r\n\t}\r\n\r\n\tpublic shouldConsolidate(prec: Precedence) {\r\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\r\n\t\t\tyour = Node.normalizePrecedence(prec || false);\r\n\r\n\t\tif (my[0] == 0 && my[1] == 0) return false;\r\n\r\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\r\n\t}\r\n\r\n\tpublic makeTeX(id, args, prec) {\r\n\t\targs = args || [];\r\n\t\tprec = prec || false;\r\n\t\t\r\n\t\tvar ret = this.tex;\r\n\r\n\t\tif (this.shouldConsolidate(prec)) {\r\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\r\n\t\t}\r\n\r\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\r\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\r\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\r\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\r\n\t\t});\r\n\t}\r\n}","import Node from './Node';\r\n\r\nexport default class Type extends Node {\r\n\tpublic readonly isBaseType: boolean;\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly origin: Type;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: Type;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tthis.doc = o.doc;\r\n\t\tthis.isBaseType = !!o.base;\r\n\r\n\t\tif (o.origin) {\r\n\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\tthis.name = o.name;\r\n\r\n\t\t\tif (!(o.origin instanceof Type))\r\n\t\t\t\tthrow this.error('!(o.origin instanceof Type)');\r\n\r\n\t\t\tthis.isFunctional = o.origin.isFunctional;\r\n\t\t\tthis.isSimple = o.origin.isSimple;\r\n\t\t\tthis.origin = o.origin;\r\n\t\t} else {\r\n\t\t\tif (typeof o.functional != 'boolean')\r\n\t\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\tthis.isFunctional = o.functional;\r\n\t\t\tthis.isSimple = !o.functional;\r\n\r\n\t\t\tif (!o.functional) {\r\n\t\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\t\tthis.name = o.name;\r\n\t\t\t} else {\r\n\t\t\t\tif (o.from.map(f => f instanceof Type).some(e => !e))\r\n\t\t\t\t\tthrow this.error('o.from.map(f => f instanceof Type).some(e => !e)');\r\n\t\t\t\tif (!(o.to instanceof Type))\r\n\t\t\t\t\tthrow this.error('!(o.to instanceof Type)');\r\n\r\n\t\t\t\tthis.from = o.from;\r\n\t\t\t\tthis.to = o.to;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toSimpleString() {\r\n\t\tif (this.name) return this.name;\r\n\r\n\t\tvar resolved = this.resolve();\r\n\r\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent): string {\r\n\t\tif (this.isSimple) return this.name;\r\n\r\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(root?: boolean) {\r\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\r\n\t\tif (!root && this.name) {\r\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\t\t}\r\n\r\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\r\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\r\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\r\n\t}\r\n\r\n\tpublic resolve(): Type {\r\n\t\treturn this.origin ? this.origin.resolve() : this;\r\n\t}\r\n\r\n\tpublic equals(t: object): boolean {\r\n\t\tif (!(t instanceof Type)) return false;\r\n\r\n\t\tif (this.origin) return this.origin.equals(t);\r\n\t\tif (t.origin) return this.equals(t.origin);\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) return this === t;\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (var i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport Node, {Precedence} from './Node';\r\nimport Type from './Type';\r\n\r\ninterface VariableArgumentType {\r\n\tdoc?: string;\r\n\ttex?: string;\r\n\ttype: Type;\r\n\tname: string;\r\n\tisParam: boolean;\r\n\tguess?: string;\r\n}\r\n\r\nexport default class Variable extends Node {\r\n\tpublic readonly isParam: boolean;\r\n\tpublic readonly guess: string;\r\n\tpublic readonly type: Type;\r\n\tpublic readonly name: string;\r\n\r\n\tconstructor ({doc, tex, type, name, isParam, guess}: VariableArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\t\tthis.tex = tex;\r\n\r\n\t\tthis.isParam = !!isParam;\r\n\t\tthis.guess = guess || null;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.type = type;\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps);\r\n\t}\r\n\r\n\t// pr f\r\n\tpublic toSimpleString() {\r\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\r\n\r\n\t\tvar tex = this.tex\r\n\t\t\t|| (\r\n\t\t\t\tthis.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.name)}}`\r\n\t\t\t);\r\n\t\t\r\n\t\treturn `\\\\href{#${id}}{${tex}}`;\r\n\t}\r\n\r\n\tpublic toTeXStringWithId(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.isParam) throw Error('wut');\r\n\r\n\t\tvar id =`id-${this._id}`;\r\n\r\n\t\treturn [\r\n\t\t\t`\\\\htmlId{${id}}{`,\r\n\t\t\tthis.toTeXString(prec, root),\r\n\t\t\t`}`\r\n\t\t].join('');\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\nimport MetaType from './MetaType';\r\nimport ExpressionResolver, { Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Variable from './Variable';\r\nimport $Variable from './$Variable';\r\n\r\ninterface FunArgumentType {\r\n\tisSchema: boolean;\r\n\tannotations: string[];\r\n\taxiomatic?: boolean;\r\n\ttype?: Type | MetaType;\r\n\tname?: string;\r\n\tparams?: (Variable | Fun)[];\r\n\tdef$s?: $Variable[];\r\n\texpr?: Metaexpr;\r\n\tdoc?: string;\r\n\ttex?: string;\r\n}\r\n\r\nexport default class Fun extends Node {\r\n\tpublic readonly isSchema;\r\n\tpublic readonly annotations: string[];\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly params;\r\n\tpublic readonly def$s: $Variable[];\r\n\tpublic readonly expr: Metaexpr;\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly proved: boolean;\r\n\r\n\t/*\r\n\t * name, expr 중 하나 이상 있어야 하고 type, expr 중\r\n\t * 한 개만 있어야 한다.\r\n\t */\r\n\tconstructor ({doc, tex, isSchema, annotations, axiomatic, type, /* nullable */ name, params, def$s, expr}: FunArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\t\tthis.isSchema = isSchema;\r\n\t\tthis.annotations = annotations;\r\n\r\n\t\tif (tex) {\r\n\t\t\tvar {precedence, code} = Node.parseTeX(tex);\r\n\r\n\t\t\tthis.precedence = precedence;\r\n\t\t\tthis.tex = code;\r\n\t\t} else {\r\n\t\t\tthis.precedence = false;\r\n\t\t\tthis.tex = null;\r\n\t\t}\r\n\r\n\t\tif (!name && !expr)\r\n\t\t\tthrow this.error('Anonymous fun cannot be primitive');\r\n\r\n\t\tif (type && expr)\r\n\t\t\tthrow this.error('no');\r\n\r\n\t\tif (!type && !expr)\r\n\t\t\tthrow this.error('Cannot guess the type of a primitive fun');\r\n\r\n\t\tif (name !== null && typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (expr && !(expr.type instanceof Type || expr.type instanceof MetaType)) {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.name = name;\r\n\r\n\t\tif (!(params instanceof Array)\r\n\t\t\t\t|| params.map(e => e instanceof Variable).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tif (expr !== null && !(expr instanceof Node))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.type = type || new (expr.type instanceof Type ? Type : MetaType)({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom: params.map(variable => variable.type),\r\n\t\t\tto: expr.type\r\n\t\t});\r\n\r\n\t\tthis.params = params;\r\n\t\tthis.def$s = def$s || [];\r\n\t\tthis.expr = expr;\r\n\r\n\t\tthis.proved = this.isProved();\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn this.proved\r\n\t\t\t|| super.isProved(hyps)\r\n\t\t\t|| this.axiomatic\r\n\t\t\t|| this.expr && this.expr.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn [\r\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t'\\\\mapsto ',\r\n\t\t\t\tExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(false),\r\n\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\r\n\t\tif (!this.isSchema) {\r\n\t\t\tif (!root)\r\n\t\t\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${Node.escapeTeX(this.name)}}`;\r\n\t\t\r\n\t\t\tif (!this.expr)\r\n\t\t\t\treturn this.funcallToTeXString(this.params, prec);\r\n\t\t\r\n\t\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\r\n\t\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\r\n\t\t} else {\r\n\t\t\tvar id = `schema-${this.proved ? 'p' : 'np'}-${this.name}`;\r\n\t\t\r\n\t\t\tif (!root)\r\n\t\t\t\treturn `\\\\href{#${id}}\\\\mathsf{${Node.escapeTeX(this.name)}}`;\r\n\t\t\r\n\t\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}\\\\mathord{\\\\left(${this.params.map(e => e.toTeXStringWithId(Node.PREC_COMMA) + (e.guess ? `: \\\\texttt{@${e.guess}}` : '')).join(', ')}\\\\right)}:\\\\\\\\\\\\quad`\r\n\t\t\t\t+ ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(true);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic funcallToTeXString(args, prec) {\r\n\t\targs = args.map(arg => {\r\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\r\n\t\t});\r\n\t\r\n\t\tif (this.tex) {\r\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\r\n\t\t}\r\n\t\r\n\t\treturn (\r\n\t\t\t!this.name\r\n\t\t\t\t? this.toTeXString(false)\r\n\t\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? Node.escapeTeX(this.name) : `\\\\mathrm{${Node.escapeTeX(this.name)}}`}}`\r\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\r\n\t}\r\n}","import { Metaexpr } from \"../ExpressionResolver\";\r\nimport Scope from \"../Scope\";\r\nimport MetaType from \"./MetaType\";\r\nimport Node, { Precedence } from \"./Node\";\r\nimport Type from \"./Type\";\r\n\r\ninterface $VariableArgumentType {\r\n    name: string;\r\n    expr: Metaexpr;\r\n}\r\n\r\nexport default class $Variable extends Node {\r\n    public readonly type: Type | MetaType;\r\n    public readonly name: string;\r\n    public readonly expr: Metaexpr;\r\n\r\n    constructor({name, expr}: $VariableArgumentType, scope?: Scope) {\r\n        super(scope);\r\n\r\n        if (!name || !expr) {\r\n            throw this.error('Assertion failed');\r\n        }\r\n\r\n        this.type = expr.type;\r\n        this.name = name;\r\n        this.expr = expr;\r\n    }\r\n\r\n    public isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.expr.isProved(hyps);\r\n\t}\r\n\r\n    public toIndentedString(indent: number, root?: boolean): string {\r\n        return this.name;\r\n    }\r\n    \r\n    public toTeXString(prec?: Precedence, root?: boolean): string {\r\n        return `\\\\mathtt{${Node.escapeTeX(this.name)}}`;\r\n    }\r\n\r\n}","import $Variable from \"./nodes/$Variable\";\r\nimport Reduction from \"./nodes/Reduction\";\r\nimport Fun from \"./nodes/Fun\";\r\nimport Funcall from \"./nodes/Funcall\";\r\nimport Tee from \"./nodes/Tee\";\r\nimport Variable from \"./nodes/Variable\";\r\nimport Type from \"./nodes/Type\";\r\n\r\nexport type Expr0 = Funcall | Fun | Variable;\r\nexport type Metaexpr = Tee | Reduction | Funcall | Fun | $Variable | Expr0;\r\n\r\nfunction iscall(a: Metaexpr): a is Funcall {\r\n\treturn a instanceof Funcall;\r\n}\r\n\r\nfunction makecall(a: Metaexpr, args: Expr0[]): Funcall {\r\n\tif (a instanceof Variable || a instanceof Fun) {\r\n\t\treturn new Funcall({\r\n\t\t\tfun: a,\r\n\t\t\targs\r\n\t\t});\r\n\t}\r\n\r\n\tconsole.log(a);\r\n\tthrow Error();\r\n}\r\n\r\nexport default class ExpressionResolver {\r\n\tpublic static substitute(expr: Metaexpr, map: Map<Variable | Fun, Expr0>): Metaexpr {\r\n\t\tif (expr instanceof Funcall) {\r\n\t\t\treturn new Funcall({\r\n\t\t\t\tfun: ExpressionResolver.substitute(expr.fun, map),\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\targs: expr.args.map(arg => ExpressionResolver.substitute(arg, map))\r\n\t\t\t});\r\n\t\t} else if (expr instanceof Fun) {\r\n\t\t\tif (!expr.expr) return expr;\r\n\r\n\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\tif (expr.name) return expr;\r\n\r\n\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\treturn new Fun({\r\n\t\t\t\tisSchema: expr.isSchema,\r\n\t\t\t\tannotations: expr.annotations,\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ExpressionResolver.substitute(expr.expr, map)\r\n\t\t\t});\r\n\t\t} else if (expr instanceof Variable) {\r\n\t\t\treturn map.get(expr) || expr;\r\n\t\t} else if (expr instanceof Tee) {\r\n\t\t\tvar left = expr.left.map(e => ExpressionResolver.substitute(e, map));\r\n\t\t\tvar right = ExpressionResolver.substitute(expr.right, map);\r\n\r\n\t\t\treturn new Tee({\r\n\t\t\t\tleft, right\r\n\t\t\t});\r\n\t\t} else if (expr instanceof Reduction) {\r\n\t\t\treturn ExpressionResolver.substitute(expr.reduced, map);\r\n\t\t} else if (expr instanceof $Variable) {\r\n\t\t\treturn ExpressionResolver.substitute(expr.expr, map);\r\n\t\t} else {\r\n\t\t\tconsole.log(expr);\r\n\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static call(callee: Metaexpr, args: Expr0[]): Metaexpr {\r\n\t\tif (!(callee instanceof Fun)) {\r\n\t\t\tconsole.log(callee);\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (!callee.expr) {\r\n\t\t\tthrow Error('Cannot call a callable without a body');\r\n\t\t}\r\n\r\n\t\tif (callee.params.length != args.length) {\r\n\t\t\tthrow Error('Illegal arguments length');\r\n\t\t}\r\n\r\n\t\tvar map = new Map();\r\n\r\n\t\tfor (var i = 0; i < callee.params.length; i++) {\r\n\t\t\tmap.set(callee.params[i], args[i]);\r\n\t\t}\r\n\r\n\t\treturn ExpressionResolver.substitute(callee.expr, map);\r\n\t}\r\n\r\n\tpublic static expandCallOnce(expr: Metaexpr): Metaexpr {\r\n\t\tif (!iscall(expr)) {\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (iscall(expr.fun)) {\r\n\t\t\tvar fun = ExpressionResolver.expandCallOnce(expr.fun);\r\n\t\t\treturn makecall(fun, expr.args);\r\n\t\t}\r\n\r\n\t\tvar callee_: Metaexpr = expr.fun;\r\n\r\n\t\twhile (callee_ instanceof $Variable) {\r\n\t\t\tcallee_ = callee_.expr;\r\n\t\t}\r\n\r\n\t\tif (!(callee_ instanceof Fun)) {\r\n\t\t\tthrow Error('Something\\'s wrong');\r\n\t\t}\r\n\r\n\t\tif (!callee_.expr) {\r\n\t\t\tthrow Error('Could not expand');\r\n\t\t}\r\n\r\n\t\treturn ExpressionResolver.call(callee_, expr.args);\r\n\t}\r\n\r\n\t// expand0은 하지 않는다.\r\n\tpublic static expandMeta(expr: Metaexpr): Metaexpr {\r\n\t\tif (expr instanceof Tee) {\r\n\t\t\tvar left = expr.left.map(ExpressionResolver.expandMeta);\r\n\t\t\tvar right = ExpressionResolver.expandMeta(expr.right);\r\n\r\n\t\t\treturn new Tee({left, right});\r\n\t\t} else if (expr instanceof Funcall) {\r\n\t\t\tvar fun = ExpressionResolver.expandMeta(expr.fun),\r\n\t\t\t\targs = expr.args;\r\n\t\t\t\r\n\t\t\t// @ts-ignore\r\n\t\t\tif (!fun.expr || fun.name && !fun.isSchema)\r\n\t\t\t\treturn new Funcall({fun, args});\r\n\r\n\t\t\treturn ExpressionResolver.expandMeta(ExpressionResolver.call(fun, args));\r\n\t\t} else if (expr instanceof Reduction) {\r\n\t\t\treturn ExpressionResolver.expandMeta(expr.reduced);\r\n\t\t} else if (expr instanceof Fun) {\r\n\t\t\tif (!expr.expr) return expr;\r\n\t\t\tif (expr.type instanceof Type && expr.name) return expr;\r\n\r\n\t\t\treturn new Fun({\r\n\t\t\t\tisSchema: expr.isSchema,\r\n\t\t\t\tannotations: expr.annotations,\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ExpressionResolver.expandMeta(expr.expr)\r\n\t\t\t});\r\n\t\t} else if (expr instanceof Variable) {\r\n\t\t\treturn expr;\r\n\t\t} else if (expr instanceof $Variable) {\r\n\t\t\treturn ExpressionResolver.expandMeta(expr.expr);\r\n\t\t} else {\r\n\t\t\tconsole.log(expr);\r\n\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\t// expr0의 이름 없는 funcall까지 풀음.\r\n\tpublic static expandMetaAndFuncalls(expr: Metaexpr) {\r\n\t\tif (expr instanceof Tee) {\r\n\t\t\tvar left = expr.left.map(ExpressionResolver.expandMetaAndFuncalls);\r\n\t\t\tvar right = ExpressionResolver.expandMetaAndFuncalls(expr.right);\r\n\r\n\t\t\treturn new Tee({left, right});\r\n\t\t} else if (expr instanceof Fun) {\r\n\t\t\tif (!expr.expr) return expr;\r\n\t\t\tif (expr.type instanceof Type && expr.name) return expr;\r\n\r\n\t\t\treturn new Fun({\r\n\t\t\t\tisSchema: expr.isSchema,\r\n\t\t\t\tannotations: expr.annotations,\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ExpressionResolver.expandMetaAndFuncalls(expr.expr)\r\n\t\t\t});\r\n\t\t} else if (expr instanceof Funcall) {\r\n\t\t\tvar fun = ExpressionResolver.expandMetaAndFuncalls(expr.fun);\r\n\t\t\tvar args = expr.args.map(ExpressionResolver.expandMetaAndFuncalls);\r\n\r\n\t\t\tif (!fun.expr || fun.name && !fun.isSchema)\r\n\t\t\t\treturn new Funcall({fun, args});\r\n\r\n\t\t\treturn ExpressionResolver.expandMetaAndFuncalls(ExpressionResolver.call(fun, args));\r\n\t\t} else if (expr instanceof Reduction) {\r\n\t\t\treturn ExpressionResolver.expandMetaAndFuncalls(expr.reduced);\r\n\t\t} else if (expr instanceof Variable) {\r\n\t\t\treturn expr;\r\n\t\t} else if (expr instanceof $Variable) {\r\n\t\t\treturn ExpressionResolver.expandMetaAndFuncalls(expr.expr);\r\n\t\t} else {\r\n\t\t\tconsole.log(expr);\r\n\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static nequalscall = 0;\r\n\tpublic static nequalstrue = 0;\r\n\tpublic static nrecursecall = 0;\r\n\tpublic static nrecursetrue = 0;\r\n\r\n\t/*\r\n\t * 스펙 참조.\r\n\t */\r\n\tpublic static equals(a: Metaexpr, b: Metaexpr) {\r\n\t\tfunction recurse(a: Metaexpr, b: Metaexpr, depth: number) {\r\n\t\t\tif (a == b) return true;\r\n\r\n\t\t\tif (!a.type.equals(b.type)) return false;\r\n\r\n\t\t\tif (a instanceof Reduction) {\r\n\t\t\t\treturn recurseWrap(a.reduced, b, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (b instanceof Reduction) {\r\n\t\t\t\treturn recurseWrap(a, b.reduced, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (a instanceof $Variable) {\r\n\t\t\t\treturn recurseWrap(a.expr, b, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (b instanceof $Variable) {\r\n\t\t\t\treturn recurseWrap(a, b.expr, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a) && iscall(b)) {\r\n\t\t\t\tif (iscall(a.fun)) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tExpressionResolver.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (iscall(b.fun)) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ExpressionResolver.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar aHasFunExpr = 'expr' in a.fun && a.fun.expr,\r\n\t\t\t\t\tbHasFunExpr = 'expr' in b.fun && b.fun.expr;\r\n\r\n\t\t\t\tif (a.fun == b.fun || !aHasFunExpr && !bHasFunExpr) {\r\n\t\t\t\t\tif (a.fun != b.fun) return false;\r\n\r\n\t\t\t\t\tif (!aHasFunExpr && !bHasFunExpr) {\r\n\t\t\t\t\t\tfor (var i = 0; i < a.args.length; i++) {\r\n\t\t\t\t\t\t\tif (!recurseWrap(a.args[i], b.args[i], depth + 1)) return false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (a.args.every((_, i) => {\r\n\t\t\t\t\t\treturn recurseWrap(a.args[i], (b as Funcall).args[i], depth + 1);\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (aHasFunExpr) {\r\n\t\t\t\t\treturn recurseWrap(ExpressionResolver.expandCallOnce(a), b, depth + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a, ExpressionResolver.expandCallOnce(b), depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a)) {\r\n\t\t\t\tif (iscall(a.fun)) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tExpressionResolver.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!('expr' in a.fun && a.fun.expr)) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tExpressionResolver.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(b)) {\r\n\t\t\t\tif (iscall(b.fun)) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ExpressionResolver.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!('expr' in b.fun && b.fun.expr)) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\ta, ExpressionResolver.expandCallOnce(b), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (a instanceof Tee) {\r\n\t\t\t\tb = b as Tee;\r\n\r\n\t\t\t\tfor (var i = 0; i < a.left.length; i++) {\r\n\t\t\t\t\tif (!recurseWrap(a.left[i], b.left[i], depth + 1)) return false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a.right, b.right, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (a.type.isFunctional) {\r\n\t\t\t\tvar placeholders = [];\r\n\t\t\t\tvar len = a.type.resolve().from.length;\r\n\r\n\t\t\t\tfor (var i = 0; i < len; i++) {\r\n\t\t\t\t\tplaceholders.push(new Variable({\r\n\t\t\t\t\t\tisParam: true,\r\n\t\t\t\t\t\ttype: a.type.resolve().from[i],\r\n\t\t\t\t\t\tname: '$' + i\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tmakecall(a, placeholders), makecall(b, placeholders), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar recurseWrap = recurse;\r\n\r\n\t\t// function recurseWrap(a, b, depth) {\r\n\t\t// \tER.nrecursecall++;\r\n\r\n\t\t// \tconsole.log(`depth ${depth}\\n${a}\\n\\n${b}`);\r\n\t\t// \tvar ret = recurse(a, b, depth);\r\n\t\t// \tconsole.log(`depth ${depth} → ${ret}`);\r\n\r\n\t\t// \tif (ret) ER.nrecursetrue++;\r\n\r\n\t\t// \treturn ret;\r\n\t\t// }\r\n\r\n\t\tExpressionResolver.nequalscall++;\r\n\t\tvar ret = recurseWrap(a, b, 0);\r\n\t\tif (ret) ExpressionResolver.nequalstrue++;\r\n\t\treturn ret;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Variable from './Variable';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';\r\nimport Scope from '../Scope';\r\nimport Fun from './Fun';\r\nimport { Expr0, Metaexpr } from '../ExpressionResolver';\r\n\r\ninterface FuncallArgumentType {\r\n\tfun: Metaexpr;\r\n\targs: Expr0[];\r\n}\r\n\r\nexport default class Funcall extends Node {\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly fun: Metaexpr;\r\n\tpublic readonly args: Expr0[];\r\n\r\n\tconstructor ({fun, args}: FuncallArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (fun.type.isSimple) {\r\n\t\t\tvar name = 'name' in fun ? fun.name : '<anonymous>';\r\n\t\t\tthrow this.error(`${name} is not callable`);\r\n\t\t}\r\n\r\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\t \r\n\t\tvar resolvedType = fun.type.resolve(),\r\n\t\t\tparamTypes = resolvedType.from,\r\n\t\t\targTypes = args.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\r\n\t\t\t\tthrow this.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.fun = fun;\r\n\t\tthis.type = resolvedType.to;\r\n\t\tthis.args = args;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.fun.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar args: any = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (args.join('').length <= 50) {\r\n\t\t\targs = this.args.map(arg => {\r\n\t\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\targs = args.join(', ');\r\n\t\r\n\t\t\tif ('isSchema' in this.fun && this.fun.isSchema) {\r\n\t\t\t\treturn `${this.fun.name || `(${this.fun})`}(${args})`;\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\r\n\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\r\n\t\t\t\t\t\t: this.fun.name,\r\n\t\t\t\t\t`(${args})`\r\n\t\t\t\t].join('');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\t\t\r\n\t\t\tif ('isSchema' in this.fun && this.fun.isSchema) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tthis.fun.name || `(${this.fun.toIndentedString(indent)})`,\r\n\t\t\t\t\t'(',\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\r\n\t\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\r\n\t\t\t\t\t\t\t: this.fun.name\r\n\t\t\t\t\t) + '(',\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif ('isSchema' in this.fun && this.fun.isSchema) {\r\n\t\t\treturn (\r\n\t\t\t\tthis.fun.name\r\n\t\t\t\t\t? `\\\\href{#schema-${this.fun.proved ? 'p' : 'np'}-${this.fun.name}}{\\\\textsf{${Node.escapeTeX(this.fun.name)}}}`\r\n\t\t\t\t\t: this.fun.toTeXString(false)\r\n\t\t\t) + `\\\\mathord{\\\\left(${this.args.map(arg => {\r\n\t\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t\t}).join(', ')}\\\\right)}`;\r\n\t\t}\r\n\r\n\t\tif (this.fun instanceof Fun)\r\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\r\n\t\t\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t});\r\n\r\n\t\treturn (\r\n\t\t\t!('name' in this.fun && this.fun.name) || this.fun instanceof Variable\r\n\t\t\t\t? this.fun.toTeXString(false)\r\n\t\t\t\t: this.fun.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.fun.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.fun.name)}}`\r\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport MetaType from './MetaType';\r\nimport ExpressionResolver, { Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport $Variable from './$Variable';\r\nimport Type from './Type';\r\n\r\ninterface TeeArgumentType {\r\n\tleft: Metaexpr[];\r\n\tdef$s?: $Variable[];\r\n\tright: Metaexpr;\r\n}\r\n\r\nexport default class Tee extends Node {\r\n\tpublic precedence = Node.PREC_COMMA;\r\n\r\n\tpublic readonly left;\r\n\tpublic readonly def$s: $Variable[];\r\n\tpublic readonly right;\r\n\tpublic readonly type: MetaType;\r\n\r\n\tconstructor ({left, def$s, right}: TeeArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\t\t\r\n\t\tif (!(left instanceof Array\r\n\t\t\t\t&& left.every(l => {\r\n\t\t\t\t\treturn l.type instanceof Type\r\n\t\t\t\t\t\t|| l.type instanceof MetaType;\r\n\t\t\t\t}))) {\r\n\t\t\tconsole.log(left);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $ instanceof $Variable)))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!(right.type instanceof Type || right.type instanceof MetaType)) {\r\n\t\t\tconsole.log(right);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (right.type.isFunctional) {\r\n\t\t\tthrow this.error('RHS of a rule cannot be a schema');\r\n\t\t}\r\n\r\n\t\tthis.left = left;\r\n\t\tthis.def$s = def$s || [];\r\n\t\tthis.right = right;\r\n\t\tthis.type = new MetaType({\r\n\t\t\tfunctional: false,\r\n\t\t\tleft: left.map(e => e.type),\r\n\t\t\tright: right.type\r\n\t\t});\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.right.isProved(hyps.concat(this.left));\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (!this.left.length) {\r\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\r\n\t\t}\r\n\t\r\n\t\treturn [\r\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\r\n\t\t\t'|-',\r\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\t\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\n\r\nexport default class MetaType extends Node {\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly left;\r\n\tpublic readonly right;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: MetaType;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tif (typeof o.functional != 'boolean')\r\n\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\r\n\t\tthis.isFunctional = o.functional;\r\n\t\tthis.isSimple = !o.functional;\r\n\r\n\t\tif (!o.functional) {\r\n\t\t\tif (!(o.left instanceof Array))\r\n\t\t\t\tthrow this.error('left should be an array');\r\n\r\n\t\t\tthis.left = o.left;\r\n\t\t\tthis.right = o.right;\r\n\t\t} else {\r\n\t\t\tif (o.from.some(f => !(f instanceof Type)))\r\n\t\t\t\tthrow this.error('o.from.some(f => !(f instanceof Type))');\r\n\t\t\tif (!(o.to instanceof MetaType))\r\n\t\t\t\tthrow this.error('!(o.to instanceof MetaType)');\r\n\r\n\t\t\tif (o.to.isFunctional)\r\n\t\t\t\tthrow this.error('Functional metatype in functional metatype is not supported');\r\n\r\n\t\t\tthis.from = o.from;\r\n\t\t\tthis.to = o.to;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic resolve() {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number) {\r\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\r\n\r\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tthrow new Error('Method not implemented.');\r\n\t}\r\n\r\n\tpublic equals(t: object): boolean {\r\n\t\tif (!(t instanceof MetaType)) return false;\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) {\r\n\t\t\tif (this.left.length != t.left.length) return false;\r\n\r\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\r\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.right.equals(t.right)) return false;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (let i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Funcall from './Funcall';\r\nimport ExpressionResolver, { Expr0, Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Tee from './Tee';\r\nimport Fun from './Fun';\r\nimport MetaType from './MetaType';\r\n\r\ninterface ReductionArgumentType {\r\n\tsubject: Metaexpr;\r\n\tguesses: Expr0[];\r\n\tleftargs: Metaexpr[];\r\n\texpected: Metaexpr;\r\n}\r\n\r\nexport default class Reduction extends Node {\r\n\tpublic readonly subject: Metaexpr;\r\n\tpublic readonly guesses;\r\n\tpublic readonly leftargs;\r\n\tpublic readonly reduced;\r\n\tpublic readonly type;\r\n\r\n\tconstructor ({subject, guesses, leftargs, expected}: ReductionArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (guesses) {\r\n\t\t\tvar resolvedType = subject.type.resolve(),\r\n\t\t\t\tparamTypes = resolvedType.from,\r\n\t\t\t\targTypes = guesses.map(e => e && e.type);\r\n\r\n\t\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\t\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\t\tif (argTypes[i] && !paramTypes[i].equals(argTypes[i])) {\r\n\t\t\t\t\tthrow this.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (subject instanceof Fun) {\r\n\t\t\tsubject.params.forEach((p, i) => {\r\n\t\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\r\n\t\t\t\t\tthrow this.error(`Argument #${i + 1} could not be guessed`);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t\tvar derefs = subject.params.map((p, i) => {\r\n\t\t\t\tif (guesses && guesses[i]) return guesses[i];\r\n\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tvar tee = ExpressionResolver.expandMeta(subject.expr) as Tee;\r\n\t\r\n\t\t\t\treturn this.query(\r\n\t\t\t\t\tp.guess,\r\n\t\t\t\t\ttee.left,\r\n\t\t\t\t\tleftargs,\r\n\t\t\t\t\ttee.right,\r\n\t\t\t\t\texpected\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\r\n\t\t\tsubject = new Funcall({\r\n\t\t\t\tfun: subject,\r\n\t\t\t\targs: derefs,\r\n\t\t\t}, scope);\r\n\t\t} else if (guesses) {\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\t\t}\r\n\t\r\n\t\tif (!(subject.type instanceof MetaType && subject.type.isSimple))\r\n\t\t\tthrow this.error('Subject is not reducible');\r\n\t\r\n\t\tif (!(leftargs instanceof Array)\r\n\t\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.subject = subject;\r\n\t\tthis.leftargs = leftargs;\r\n\r\n\t\tvar paramTypes = subject.type.left,\r\n\t\t\tleftargTypes = leftargs.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != leftargTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`);\r\n\r\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\r\n\t\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`);\r\n\t\t}\r\n\r\n\t\tthis.type = subject.type.right;\r\n\r\n\t\tvar tee = ExpressionResolver.expandMetaAndFuncalls(subject);\r\n\r\n\t\tif (!(tee instanceof Tee)) {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < tee.left.length; i++) {\r\n\t\t\tif (!ExpressionResolver.equals(tee.left[i], leftargs[i])) {\r\n\t\t\t\tthrow this.error(`LHS #${i + 1} failed to match:\r\n\r\n--- EXPECTED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(tee.left[i])}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(leftargs[i])}\r\n----------------`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (expected) {\r\n\t\t\tif (!ExpressionResolver.equals(tee.right, expected)) {\r\n\t\t\t\tthrow this.error(`RHS failed to match:\r\n\r\n--- EXPECTED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(tee.right)}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(expected)}\r\n----------------`);\r\n\t\t\t}\r\n\r\n\t\t\tthis.reduced = expected;\r\n\t\t} else {\r\n\t\t\tthis.reduced = tee.right;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.subject.isProved(hyps)\r\n\t\t\t\t&& this.leftargs.every(l => l.isProved(hyps));\r\n\t}\r\n\r\n\tpublic query(guess, left, leftargs, right, expected) {\r\n\t\tif (guess.length == 0) throw this.error('wut');\r\n\r\n\t\tvar lef, ret;\r\n\r\n\t\tif (guess[0] == 'r') {\r\n\t\t\tif (!expected) {\r\n\t\t\t\tthrow this.error(`Cannot dereference @${guess}`);\r\n\t\t\t}\r\n\r\n\t\t\tlef = right;\r\n\t\t\tret = expected;\r\n\t\t} else {\r\n\t\t\tif (!(1 <= guess[0] * 1 && guess[0] * 1 <= leftargs.length))\r\n\t\t\t\tthrow this.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\r\n\t\t\tlef = left[guess[0] * 1 - 1];\r\n\t\t\tret = leftargs[guess[0] * 1 - 1];\r\n\t\t}\r\n\r\n\t\tvar that = this;\r\n\r\n\t\treturn (function recurse(guess, lef, node, ptr) {\r\n\t\t\tnode = ExpressionResolver.expandMetaAndFuncalls(node);\r\n\t\t\t\r\n\t\t\tif (guess.length <= ptr) return node;\r\n\r\n\t\t\tif (/[0-9]/.test(guess[ptr])) {\r\n\t\t\t\tvar n = guess[ptr] * 1;\r\n\r\n\t\t\t\tif (lef instanceof Tee && node instanceof Tee) {\r\n\t\t\t\t\tif (lef.left.length != node.left.length) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent length mismatch`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(1 <= n && n <= node.left.length)) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recurse(guess, lef.left[n - 1], node.left[n - 1], ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tif (!lef.fun || !node.fun) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ExpressionResolver.equals(lef.fun, node.fun)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!node.fun.expr) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = ExpressionResolver.expandCallOnce(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.args || !(1 <= n && n <= node.args.length))\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\r\n\t\t\t\treturn recurse(guess, lef.args[n - 1], node.args[n - 1], ptr + 1);\r\n\t\t\t} else if (guess[ptr] == 'r') {\r\n\t\t\t\tif (lef instanceof Tee && node instanceof Tee) {\r\n\t\t\t\t\treturn recurse(guess, lef.right, node.right, ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t}\r\n\r\n\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t})(guess, lef, ret, 1);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar leftargs = this.leftargs.map(arg => {\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (leftargs.join('').length <= 50) {\r\n\t\t\tleftargs = this.leftargs.map(arg => {\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\tleftargs = leftargs.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\tleftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\t'\\t' + leftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\r\n\t}\r\n}","var grammar;\r\n\r\nif (process.env.__webpack__) {\r\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\r\n} else {\r\n\tvar fs = require('fs');\r\n\tvar path = require('path');\r\n\r\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\r\n}\r\n\r\nvar Program = require('./Program').default;\r\n\r\nmodule.exports = {grammar, Program};","export default \"start =\\r\\n\\t_ lines:(a:line _ {return a})* {return lines}\\r\\n\\r\\nline =\\r\\n\\timport\\r\\n\\t/ typedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defschema\\r\\n\\r\\nevaluable =\\r\\n\\t_ e:evaluable_internal _ {return e}\\r\\n\\r\\nevaluable_internal =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defschema\\r\\n\\t/ metaexpr\\r\\n\\r\\nimport =\\r\\n\\t'import' __\\r\\n\\tfilename:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'import',\\r\\n\\t\\t\\tfilename,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ntypedef =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tbase:(\\\"base\\\" __)?\\r\\n\\t\\\"type\\\" __\\r\\n\\torigin:(o:ftype __ {return o})?\\r\\n\\tname:ident _ sem\\r\\n\\t{\\r\\n\\t\\tdoc = doc && doc[0];\\r\\n\\t\\t\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'typedef',\\r\\n\\t\\t\\tdoc,\\r\\n\\t\\t\\tbase: !!base,\\r\\n\\t\\t\\torigin,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefv =\\r\\n\\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschemaparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\tguess:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\tguess,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n \\r\\ndefun =\\r\\n\\tdoc:(documentation __)?\\r\\n\\ttex:(tex __)?\\r\\n\\trettype:type __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\texpr:(\\r\\n\\t\\t\\\"{\\\" _\\r\\n\\t\\texpr:expr0 _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return expr}\\r\\n\\t\\t/ sem {return null}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defun',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\trettype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschema =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tannotations: (a:annotation __ {return a})*\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defschemaparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"{\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\texpr:metaexpr _\\r\\n\\t\\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\tannotations,\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// var[...]\\r\\n// foo(...)[...]\\r\\n// foo[...][...]\\r\\n// (metaexpr)[...]\\r\\n// schema(?, ...)[...]\\r\\nreduction =\\r\\n\\tsubject:(\\r\\n\\t\\tschemacall\\r\\n\\t\\t/ var\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\tguesses:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:('?' {return null} / expr0) _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)?\\r\\n\\tleftargs:(\\r\\n\\t\\t\\\"[\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:metaexpr _\\r\\n\\t\\t\\ttail:(\\\";\\\" _ e:metaexpr _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\"]\\\"\\r\\n\\t\\tb:(\\r\\n\\t\\t\\t_ '[' _\\r\\n\\t\\t\\t'as' __\\r\\n\\t\\t\\tm:metaexpr\\r\\n\\t\\t\\t']'\\r\\n\\t\\t\\t{return m}\\r\\n\\t\\t)?\\r\\n\\t\\t{return {a: a || [], b: b || null}}\\r\\n\\t)+\\r\\n\\t{\\r\\n\\t\\tvar ret = {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject,\\r\\n\\t\\t\\tguesses,\\r\\n\\t\\t\\tleftargs: leftargs[0].a,\\r\\n\\t\\t\\texpected: leftargs[0].b,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor (var i = 1; i < leftargs.length; i++) {\\r\\n\\t\\t\\tret = {\\r\\n\\t\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\t\\tsubject: ret,\\r\\n\\t\\t\\t\\tguesses: null,\\r\\n\\t\\t\\t\\tleftargs: leftargs[i].a,\\r\\n\\t\\t\\t\\texpected: leftargs[i].b,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n\\r\\n// var(...)\\r\\n// (metaexpr)(...)\\r\\nschemacall =\\r\\n\\tschema:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemacall',\\r\\n\\t\\t\\tschema,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// forall(f, g)\\r\\n// (expr0)(f, g)\\r\\nfuncall =\\r\\n\\tschema:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:expr0 _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funcall',\\r\\n\\t\\t\\tschema,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => expr0\\r\\n// (T t) => { expr0 }\\r\\nfunexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\texpr:(\\r\\n\\t\\texpr0\\r\\n\\t\\t/ \\\"{\\\" _ e:expr0 _ \\\"}\\\" {return e}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => metaexpr_internal_1\\r\\n// (T t) => { $foo = ...; metaexpr }\\r\\nschemaexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\tfoo:(\\r\\n\\t\\texpr:metaexpr_internal_1\\r\\n\\t\\t{return {defdollars: [], expr}}\\r\\n\\t\\t/ \\\"{\\\" _\\r\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\t\\texpr:metaexpr _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return {defdollars, expr}}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemaexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: foo.defdollars,\\r\\n\\t\\t\\texpr: foo.expr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nmetaexpr =\\r\\n\\tleft:(\\r\\n\\t\\tl:(\\r\\n\\t\\t\\thead:metaexpr_internal_1 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_1 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)? {return l || []}\\r\\n\\t)\\r\\n\\t\\\"|-\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\tright:metaexpr\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'tee',\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\tleft,\\r\\n\\t\\t\\tright,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_1\\r\\n\\r\\n/*\\r\\n * 다음이 성립하여야 한다.\\r\\n *\\r\\n * - reduction이 schemacall보다 앞이다.\\r\\n * - schemacall이 var보다 앞이다.\\r\\n *\\r\\n */\\r\\nmetaexpr_internal_1 =\\r\\n\\treduction\\r\\n\\t/ schemacall\\r\\n\\t/ var\\r\\n\\t/ schemaexpr\\r\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\r\\n\\r\\nexpr0 =\\r\\n\\tfuncall\\r\\n\\t/ funexpr\\r\\n\\t/ var\\r\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\r\\n\\r\\ndefdollar =\\r\\n\\tname:dollar_ident _\\r\\n\\t'=' _\\r\\n\\texpr:metaexpr _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'def$',\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\r\\ntype =\\r\\n\\tstype\\r\\n\\t/ ftype\\r\\n\\r\\nstype =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: false,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nftype =\\r\\n\\t\\\"[\\\" _\\r\\n\\tfrom:(\\r\\n\\t\\ttype:type {return [type]}\\r\\n\\t\\t/ (\\r\\n\\t\\t\\ttt:(\\r\\n\\t\\t\\t\\t\\\"(\\\" _\\r\\n\\t\\t\\t\\thead: type\\r\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\r\\n\\t\\t\\t\\t_ \\\")\\\"\\r\\n\\t\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t\\t)\\r\\n\\t\\t\\t{return tt}\\r\\n\\t\\t)\\r\\n\\t) _\\r\\n\\t\\\"->\\\" _\\r\\n\\tto:type _\\r\\n\\t\\\"]\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: true,\\r\\n\\t\\t\\tfrom,\\r\\n\\t\\t\\tto,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nvar =\\r\\n\\tat_var\\r\\n\\t/ dollar_var\\r\\n\\t/ plain_var\\r\\n\\r\\nat_var =\\r\\n\\tname:at_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '@',\\r\\n\\t\\t\\tname: name.slice(1),\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndollar_var =\\r\\n\\tname:dollar_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '$',\\r\\n\\t\\t\\tname: name,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nplain_var =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nkeyword =\\r\\n\\t\\\"as\\\"\\r\\n\\t/ \\\"axiomatic\\\"\\r\\n\\t/ \\\"base\\\"\\r\\n\\t/ \\\"import\\\"\\r\\n\\t/ \\\"schema\\\"\\r\\n\\t/ \\\"type\\\";\\r\\n\\r\\nannotation =\\r\\n\\t'@discouraged'\\r\\n\\t/ '@deprecated'\\r\\n\\r\\nident =\\r\\n\\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\\r\\n\\r\\nat_ident =\\r\\n\\t$('@' [a-zA-Z0-9_]+)\\r\\n\\r\\ndollar_ident =\\r\\n\\t$('$' [a-zA-Z0-9_]+)\\r\\n\\r\\ndocumentation =\\r\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ntex =\\r\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ncomment =\\r\\n\\t\\\"#\\\" (!newline .)*\\r\\n\\t/ \\\"//\\\" (!newline .)*\\r\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\r\\n\\r\\nnewline =\\r\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\r\\n\\r\\n// optional whitespace\\r\\n_ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\r\\n\\r\\n// mandatory whitespace\\r\\n__ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\r\\n\\r\\nsem =\\r\\n\\t\\\";\\\"\";","import Scope from './Scope';\r\nimport PegInterface from './PegInterface';\r\nimport ExpressionResolver, { Metaexpr } from './ExpressionResolver';\r\nimport Reduction from './nodes/Reduction';\r\nimport Fun from './nodes/Fun';\r\nimport Tee from './nodes/Tee';\r\nimport Funcall from './nodes/Funcall';\r\nimport Variable from './nodes/Variable';\r\nimport $Variable from './nodes/$Variable';\r\nimport { EvaluableObject, LineObject } from './PegInterfaceDefinitions';\r\n\r\nexport default class Program {\r\n\tpublic scope = new Scope(null);\r\n\tpublic readonly parser;\r\n\tpublic readonly scopeMap: Map<string, Scope> = new Map();\r\n\t\r\n\tconstructor(parser) {\r\n\t\tif (!parser) throw Error('no');\r\n\t\tthis.parser = parser;\r\n\t}\r\n\r\n\tpublic async loadModule(filename, loader): Promise<Scope> {\r\n\t\treturn this.scope = await this.loadModuleInternal(filename, loader);\r\n\t}\r\n\r\n\tprivate async loadModuleInternal(filename, loader): Promise<Scope> {\r\n\t\tif (this.scopeMap.has(filename)) {\r\n\t\t\treturn this.scopeMap.get(filename);\r\n\t\t}\r\n\r\n\t\tvar scope = new Scope(null);\r\n\r\n\t\tvar code = await loader(filename);\r\n\t\tvar parsed = this.parser.parse(code);\r\n\t\tawait this.feed(parsed, scope, loader);\r\n\r\n\t\tthis.scopeMap.set(filename, scope);\r\n\t\treturn scope;\r\n\t}\r\n\r\n\tpublic async feed(lines: LineObject[], scope: Scope=this.scope, loader) {\r\n\t\tfor (var i = 0; i < lines.length; i++) {\r\n\t\t\tvar line = lines[i];\r\n\t\t\t\r\n\t\t\tswitch (line._type) {\r\n\t\t\t\tcase 'import':\r\n\t\t\t\t\tvar scope2 = await this.loadModuleInternal(line.filename, loader);\r\n\t\t\t\t\tscope.importMap.set(line.filename, scope2);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'typedef':\r\n\t\t\t\t\tvar type = PegInterface.type(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasType(type.name)) {\r\n\t\t\t\t\t\tthrow scope.error(`Type ${type.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addType(type);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defv':\r\n\t\t\t\t\tvar variable = PegInterface.variable(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasVariable(variable.name)) {\r\n\t\t\t\t\t\tthrow variable.scope.error(`Definition ${variable.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addVariable(variable);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defun':\r\n\t\t\t\t\tvar fun = PegInterface.fun(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasVariable(fun.name)) {\r\n\t\t\t\t\t\tthrow fun.scope.error(`Definition ${fun.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addFun(fun);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defschema':\r\n\t\t\t\t\tvar schema = PegInterface.schema(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasSchema(schema.name)) {\r\n\t\t\t\t\t\tthrow schema.scope.error(`Schema ${schema.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addSchema(schema);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tpublic evaluate(line: EvaluableObject) {\r\n\t\tswitch (line._type) {\r\n\t\t\tcase 'typedef':\r\n\t\t\t\treturn PegInterface.type(line, this.scope);\r\n\t\t\tcase 'defv':\r\n\t\t\t\treturn PegInterface.variable(line, this.scope);\r\n\t\t\tcase 'defun':\r\n\t\t\t\treturn PegInterface.fun(line, this.scope);\r\n\t\t\tcase 'defschema':\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PegInterface.schema(line, this.scope);\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PegInterface.tee(line, this.scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PegInterface.reduction(line, this.scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PegInterface.schemacall(line, this.scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PegInterface.metavar(line, this.scope);\r\n\t\t\tdefault:\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getProofExplorer(name: string, ktx) {\t\r\n\t\tvar DIAMOND = '&#x25C7;',\r\n\t\t\tDOWN = '&#x25BC;',\r\n\t\t\tUP = '&#x25B2;';\r\n\t\t\r\n\t\tif (!this.scope.hasSchema(name)) {\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t\r\n\t\tvar theexpr = this.scope.getSchema(name);\r\n\t\r\n\t\tvar ncols = (function recurse(expr: Metaexpr) {\r\n\t\t\tif (expr instanceof Reduction) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.leftargs.map(recurse),\r\n\t\t\t\t\t((expr.subject instanceof Fun && expr.subject.name)\r\n\t\t\t\t\t\t|| (expr.subject instanceof Funcall\r\n\t\t\t\t\t\t\t\t&& 'name' in expr.subject.fun\r\n\t\t\t\t\t\t\t\t&& expr.subject.fun.name)\r\n\t\t\t\t\t\t\t? 0 : recurse(expr.subject)),\r\n\t\t\t\t\t1\r\n\t\t\t\t);\r\n\t\t\t} else if (expr instanceof Fun) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\r\n\t\t\t\t\trecurse(expr.expr)\r\n\t\t\t\t) + 1;\r\n\t\t\t} else if (expr instanceof Tee) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.left.map(recurse),\r\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\r\n\t\t\t\t\trecurse(expr.right)\r\n\t\t\t\t) + 1;\r\n\t\t\t} else {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t})(theexpr);\r\n\r\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], options?) {\r\n\t\t\tvar padding = left.length;\r\n\r\n\t\t\tvar {bbb=false, rrb=false} = options || {};\r\n\t\r\n\t\t\tvar htmlLeft = left.map((e, i, a) => `<td class=\"${rrb && i == a.length - 1 ? 'rrb' : 'brb'}\">${e.map(f => ktx(f.toTeXStringWithId(true))).join(', ')}</td>`).join('');\r\n\r\n\t\t\tfor (var i = 0; i < left.length; i++)\r\n\t\t\t\twhile(left[i].length) left[i].pop();\r\n\t\r\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\" ' : ''}colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\r\n\t\t}\r\n\r\n\t\tfunction exprToHtml(expr, expand?) {\r\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\r\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\r\n\t\t\tif (expand) return ktx(ExpressionResolver.expandMetaAndFuncalls(expr).toTeXString(true));\r\n\t\t\t\r\n\t\t\treturn ktx(expr.toTeXString(true));\r\n\t\t}\r\n\r\n\t\tvar ctr = 0;\r\n\r\n\t\tvar tree = (function getTree(\r\n\t\t\t\texpr: Metaexpr,\r\n\t\t\t\thypnumMap: Map<Metaexpr, number>,\r\n\t\t\t\t$Map: Map<Metaexpr, number>) {\r\n\t\t\t\r\n\t\t\tif (hypnumMap.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: hypnumMap.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tif ($Map.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tif (expr instanceof Reduction) {\r\n\t\t\t\tvar leftarglines = [];\r\n\t\t\t\tvar leftargnums = expr.leftargs.map(l => {\r\n\t\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\r\n\t\t\t\t\tif ($Map.has(l)) return $Map.get(l);\r\n\r\n\t\t\t\t\tvar lines = getTree(l, hypnumMap, $Map);\r\n\t\t\t\t\tleftarglines = leftarglines.concat(lines);\r\n\t\t\t\t\treturn lines[lines.length - 1].ctr;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar args = null;\r\n\t\t\t\tvar subjectlines = [];\r\n\t\t\t\tvar subjectnum = hypnumMap.get(expr.subject)\r\n\t\t\t\t\t|| $Map.get(expr.subject)\r\n\t\t\t\t\t|| (expr.subject instanceof Funcall && $Map.has(expr.subject.fun)\r\n\t\t\t\t\t\t? (args = expr.subject.args, $Map.get(expr.subject.fun))\r\n\t\t\t\t\t\t: false)\r\n\t\t\t\t\t|| ((s => s instanceof Fun && s.name\r\n\t\t\t\t\t\t\t|| s instanceof Funcall && 'name' in s.fun && s.fun.name)(expr.subject)\r\n\t\t\t\t\t\t? expr.subject\r\n\t\t\t\t\t\t: (subjectlines = getTree(expr.subject, hypnumMap, $Map))[subjectlines.length-1].ctr);\r\n\r\n\t\t\t\treturn [\r\n\t\t\t\t\t...leftarglines,\r\n\t\t\t\t\t...subjectlines,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_type: 'E',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tsubject: subjectnum,\r\n\t\t\t\t\t\targs,\r\n\t\t\t\t\t\tleftargs: leftargnums,\r\n\t\t\t\t\t\treduced: expr.reduced\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t} else if (expr instanceof Funcall) {\r\n\t\t\t\tif (hypnumMap.has(expr.fun)) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: hypnumMap.get(expr.fun),\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($Map.has(expr.fun)) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: $Map.get(expr.fun),\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tif (expr.fun.isSchema && expr.fun.name) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RCX',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tif (!expr.fun.isSchema) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar schemalines = getTree(expr.fun, hypnumMap, $Map);\r\n\r\n\t\t\t\treturn [\r\n\t\t\t\t\t...schemalines,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t} else if (expr instanceof Variable) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof Fun) {\r\n\t\t\t\tif (expr.isSchema && expr.name && expr != theexpr) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RS',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!expr.expr) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\tvar start = ctr + 1;\r\n\r\n\t\t\t\tvar $lines = [];\r\n\t\t\t\t\r\n\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'V',\r\n\t\t\t\t\t$lines,\r\n\t\t\t\t\tlines: getTree(expr.expr, hypnumMap, $Map),\r\n\t\t\t\t\t// getHtmlLine 함수가 이 배열을 조작하기 때문에\r\n\t\t\t\t\t// shallow copy 해야 한다.\r\n\t\t\t\t\tparams: expr.params.slice(),\r\n\t\t\t\t\tctr: [start ,ctr]\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof Tee) {\r\n\t\t\t\thypnumMap = new Map(hypnumMap);\r\n\t\t\t\tvar leftlines = [];\r\n\r\n\t\t\t\tvar start = ctr + 1;\r\n\r\n\t\t\t\texpr.left.forEach(l => {\r\n\t\t\t\t\thypnumMap.set(l, ++ctr);\r\n\t\t\t\t\tleftlines.push({\r\n\t\t\t\t\t\t_type: 'H',\r\n\t\t\t\t\t\tctr,\r\n\t\t\t\t\t\texpr: l\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\tvar $lines = [];\r\n\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'T',\r\n\t\t\t\t\tleftlines,\r\n\t\t\t\t\t$lines,\r\n\t\t\t\t\trightlines: getTree(expr.right, hypnumMap, $Map),\r\n\t\t\t\t\tctr: [start, ctr]\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof $Variable) {\r\n\t\t\t\tif (!$Map.has(expr)) {\r\n\t\t\t\t\tthrow Error(`${expr.name} is not defined`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\texpr: expr.expr\r\n\t\t\t\t}];\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('Unknown metaexpr', expr);\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: '?',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\t\t})(theexpr, new Map(), new Map());\r\n\r\n\t\tvar html = '<table class=\"explorer\">';\r\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\r\n\t\t\r\n\t\thtml += (function tree2html(lines, left) {\r\n\t\t\treturn lines.map(line => {\r\n\t\t\t\tswitch (line._type) {\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([line.params]))\r\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([line.params]));\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\r\n\r\n\t\t\t\t\t\tvar ret = '';\r\n\r\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\r\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\r\n\r\n\t\t\t\t\t\t\tret += getHtmlLine(\r\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', {bbb: true, rrb: true}\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\r\n\t\t\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\t\t\tnewleft,\r\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t\t\t'assumption',\r\n\t\t\t\t\t\t\t\t\t{bbb: i == a.length - 1, rrb: true}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}).join('');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.$lines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.rightlines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\tcase '?':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'???'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tthrow Error('no');\r\n\t\t\t\t\tcase 'R':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RS':\r\n\t\t\t\t\tcase 'RCX':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RC':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\r\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)}${line.args ? ' (' + line.args.map(a => exprToHtml(a)).join(', ') + ')' : ''} [${line.leftargs.map(a => exprToHtml(a)).join(', ')}]`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'NP':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\t`Unknown type ${line._type}`,\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}).join('');\r\n\t\t})(tree[0].$lines.concat(tree[0].lines), []);\r\n\t\t\r\n\t\thtml += '</table>';\r\n\t\r\n\t\treturn html;\r\n\t}\r\n}","import Type from './nodes/Type';\r\nimport Variable from './nodes/Variable';\r\nimport Fun from './nodes/Fun';\r\nimport StackTrace from './StackTrace';\r\nimport { Metaexpr } from './ExpressionResolver';\r\nimport $Variable from './nodes/$Variable';\r\n\r\nexport type NestedTypeInput = string | NestedTypeInput[];\r\n\r\nexport default class Scope {\r\n\tpublic readonly importMap: Map<string, Scope> = new Map();\r\n\r\n\tpublic readonly typedefMap: Map<string, Type> = new Map();\r\n\tpublic readonly defMap: Map<string, Variable | Fun> = new Map();\r\n\tpublic readonly schemaMap: Map<string, Fun> = new Map();\r\n\tpublic readonly $Map: Map<string, $Variable> = new Map();\r\n\tpublic readonly hypotheses: Metaexpr[] = [];\r\n\r\n\tpublic readonly parent: Scope;\r\n\tpublic readonly root: Scope;\r\n\r\n\tpublic readonly trace: StackTrace;\r\n\tpublic baseType: Type;\r\n\r\n\tconstructor (parent: Scope, trace?: StackTrace) {\r\n\t\tthis.parent = parent;\r\n\t\tthis.root = parent ? parent.root : this;\r\n\r\n\t\tif (trace && !(trace instanceof StackTrace)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.trace = trace || new StackTrace();\r\n\r\n\t\tthis.baseType = parent ? parent.baseType : null;\r\n\t}\r\n\r\n\tpublic extend(type, name, location): Scope {\r\n\t\tvar child = new Scope(this, this.trace.extend(type, name, location));\r\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\r\n\t\treturn child;\r\n\t}\r\n\r\n\tpublic error(message: string): Error {\r\n\t\treturn this.trace.error(message);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.typedefMap.has(name)\r\n\t\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasOwnType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.hasOwnType(name)\r\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\tpublic addType(type: Type): Type {\r\n\t\tif (!(type instanceof Type))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!type.name)\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\r\n\t\tif (this.hasOwnType(type.name))\r\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\r\n\r\n\t\tif (type.isBaseType) {\r\n\t\t\tif (this.baseType) {\r\n\t\t\t\tthrow this.error('A base type already exists');\r\n\t\t\t}\r\n\r\n\t\t\t(function broadcast(scope: Scope) {\r\n\t\t\t\tscope.baseType = type;\r\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\r\n\t\t\t})(this);\r\n\t\t}\r\n\r\n\t\tthis.typedefMap.set(type.name, type);\r\n\t\treturn type;\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic getType(name: NestedTypeInput): Type {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\tif (!this.hasType(name))\r\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\r\n\r\n\t\t\treturn this.typedefMap.has(name)\r\n\t\t\t\t? this.typedefMap.get(name)\r\n\t\t\t\t: (!!this.parent && this.parent.getType(name))\r\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\t\treturn s.hasType(name)\r\n\t\t\t\t\t})[0].getType(name);\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\r\n\t\t\treturn this.getType(e);\r\n\t\t});\r\n\r\n\t\tvar to = this.getType(name[name.length - 1]);\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom,\r\n\t\t\tto\r\n\t\t});\r\n\t}\r\n\r\n\tpublic hasOwnVariable(name: string): boolean {\r\n\t\treturn this.defMap.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnVariable(name));\r\n\t}\r\n\r\n\tpublic hasVariable(name: string): boolean {\r\n\t\treturn this.hasOwnVariable(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasVariable(name));\r\n\t}\r\n\r\n\tpublic addVariable(variable: Variable | Fun): Variable | Fun {\r\n\t\tif (!(variable instanceof Variable))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnVariable(variable.name))\r\n\t\t\tthrow this.error(`Definition ${variable.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(variable.name, variable);\r\n\t\treturn variable;\r\n\t}\r\n\r\n\tpublic addFun(fun: Fun): Fun {\r\n\t\tif (!(fun instanceof Fun))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!fun.name)\r\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\r\n\r\n\t\tif (this.hasOwnVariable(fun.name))\r\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(fun.name, fun);\r\n\t\treturn fun;\r\n\t}\r\n\r\n\tpublic getVariable(name: string): Variable | Fun {\r\n\t\tif (!this.hasVariable(name))\r\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\r\n\r\n\t\treturn this.defMap.has(name)\r\n\t\t\t? this.defMap.get(name)\r\n\t\t\t: (!!this.parent && this.parent.getVariable(name))\r\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\treturn s.hasVariable(name)\r\n\t\t\t\t})[0].getVariable(name);\r\n\t}\r\n\r\n\tpublic hasOwnSchema(name: string): boolean {\r\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnSchema(name));\r\n\t}\r\n\r\n\tpublic hasSchema(name: string): boolean {\r\n\t\treturn this.hasOwnSchema(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\r\n\t}\r\n\r\n\tpublic addSchema(schema: Fun): Fun {\r\n\t\tif (!(schema instanceof Fun))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnSchema(schema.name))\r\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\r\n\r\n\t\tthis.schemaMap.set(schema.name, schema);\r\n\t\treturn schema;\r\n\t}\r\n\r\n\tpublic getSchema(name: string): Variable | Fun {\r\n\t\tif (!this.hasSchema(name))\r\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\r\n\r\n\t\treturn this.schemaMap.has(name)\r\n\t\t\t? this.schemaMap.get(name)\r\n\t\t\t: this.defMap.has(name)\r\n\t\t\t\t? this.defMap.get(name)\r\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name))\r\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\t\treturn s.hasSchema(name)\r\n\t\t\t\t\t})[0].getSchema(name);\r\n\t}\r\n\r\n\tpublic hasOwn$(name: string): boolean {\r\n\t\treturn this.$Map.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwn$(name));\r\n\t}\r\n\r\n\tpublic has$(name: string): boolean {\r\n\t\treturn this.hasOwn$(name)\r\n\t\t\t|| (!!this.parent && this.parent.has$(name));\r\n\t}\r\n\r\n\tpublic add$($: $Variable): $Variable {\r\n\t\tif (!($ instanceof $Variable))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwn$($.name))\r\n\t\t\tthrow this.error(`$ variable ${$.name} has already been declared`);\r\n\r\n\t\tthis.$Map.set($.name, $);\r\n\t\treturn $;\r\n\t}\r\n\r\n\tpublic get$(name: string): $Variable {\r\n\t\tif (!this.has$(name))\r\n\t\t\tthrow this.error(`$ variable ${name} is not defined`);\r\n\r\n\t\treturn this.$Map.has(name)\r\n\t\t\t? this.$Map.get(name)\r\n\t\t\t: (!!this.parent && this.parent.get$(name))\r\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\treturn s.has$(name)\r\n\t\t\t\t})[0].get$(name);\r\n\t}\r\n}","export default class StackTrace {\r\n\tpublic readonly stack: any[];\r\n\r\n\tconstructor (stack?: any[]) {\r\n\t\tthis.stack = stack || [];\r\n\t}\r\n\r\n\tpublic extend(type, name, location): StackTrace {\r\n\t\treturn new StackTrace([[type, name, location]].concat(this.stack));\r\n\t}\r\n\r\n\tpublic error(message: string) {\r\n\t\tvar filename = typeof process != 'undefined' && process.argv[2];\r\n\r\n\t\treturn new Error(\r\n\t\t\tmessage\r\n\t\t\t+ '\\n\\tat '\r\n\t\t\t+ (\r\n\t\t\t\tthis.stack.length\r\n\t\t\t\t\t? this.stack.map(([type, name, location]) => {\r\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${filename || '<unknown>'}:${location.start.line}:${location.start.column})`;\r\n\t\t\t\t\t}).join('\\n\\tat ')\r\n\t\t\t\t\t: `<root> (${filename || '<unknown>'}:1:1)`\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\r\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\r\n * PEG.js의 출력은 여기에서만 처리해야 한다.\r\n */\r\n\r\nimport Type from './nodes/Type';\r\nimport Variable from './nodes/Variable';\r\nimport Tee from './nodes/Tee';\r\nimport Fun from './nodes/Fun';\r\nimport Funcall from './nodes/Funcall';\r\nimport Reduction from './nodes/Reduction';\r\nimport { Expr0, Metaexpr } from './ExpressionResolver';\r\nimport { Def$Object, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject } from './PegInterfaceDefinitions';\r\nimport Scope, { NestedTypeInput } from './Scope';\r\nimport $Variable from './nodes/$Variable';\r\n\r\nfunction typeObjToString(obj: TypeObject): string {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) return (obj as StypeObject).name;\r\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\r\n\t\t\t+ typeObjToString(obj.to) + ']';\r\n}\r\n\r\n/*\r\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\r\n * st\t\t\t\t\t\t-> 'st'\r\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\r\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\r\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\r\n */\r\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) {\r\n\t\tobj = obj as StypeObject;\r\n\r\n\t\tif (!obj.name)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.name;\r\n\t} else {\r\n\t\tif (!obj.from || !obj.to)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\r\n\t\t\t[typeObjToNestedArr(obj.to)]\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction varObjToString(obj: VarObject): string {\r\n\tswitch (obj.type) {\r\n\t\tcase '@':\r\n\t\t\treturn `@${obj.name}`;\r\n\t\tcase '$':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tcase 'normal':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\r\n\t}\r\n}\r\n\r\nexport default class PI {\r\n\tpublic static type(obj: TypedefObject, parentScope: Scope): Type {\r\n\t\tif (obj._type != 'typedef')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\r\n\r\n\t\tvar origin: Type = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\r\n\r\n\t\tvar name: string = obj.name;\r\n\t\tvar doc: string = obj.doc;\r\n\t\tvar base: boolean = obj.base;\r\n\r\n\t\tif (base && origin) {\r\n\t\t\tthrow scope.error('Base type should not be an alias');\r\n\t\t}\r\n\r\n\t\tif (origin) {\r\n\t\t\treturn new Type({\r\n\t\t\t\tname,\r\n\t\t\t\tdoc,\r\n\t\t\t\tbase,\r\n\t\t\t\torigin\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: false,\r\n\t\t\tname,\r\n\t\t\tdoc,\r\n\t\t\tbase\r\n\t\t});\r\n\t}\r\n\r\n\tpublic static variable(obj: DefvObject | VarObject, parentScope: Scope): Variable | Fun {\r\n\t\tif (!['defv', 'var'].includes(obj._type)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('variable', obj.name, obj.location);\r\n\r\n\t\tif (obj._type == 'var') {\r\n\t\t\tif (obj.type != 'normal') {\r\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\r\n\t\t\t}\r\n\r\n\t\t\tif (!scope.hasVariable(obj.name))\r\n\t\t\t\tthrow scope.error(`Undefined identifier ${obj.name}`);\r\n\t\t\treturn scope.getVariable(obj.name);\r\n\t\t}\r\n\r\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\r\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\r\n\r\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\r\n\r\n\t\treturn new Variable({\r\n\t\t\ttype,\r\n\t\t\tisParam: !!obj.isParam,\r\n\t\t\tguess: obj.guess || null,\r\n\t\t\tname: obj.name,\r\n\t\t\tdoc: obj.doc,\r\n\t\t\ttex: obj.tex\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): Fun {\r\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name = null,\r\n\t\t\tdoc = null,\r\n\t\t\ttex = null;\r\n\r\n\t\tif (obj._type == 'defun') {\r\n\t\t\tobj = obj as DefunObject;\r\n\t\t\tname = obj.name;\r\n\t\t\tdoc = obj.doc;\r\n\t\t\ttex = obj.tex;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('fun', name, obj.location);\r\n\r\n\t\tvar type = null;\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.variable(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnVariable(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\r\n\t\t\treturn scope.addVariable(tv);\r\n\t\t});\r\n\t\tvar expr = null;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'defun':\r\n\t\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\r\n\t\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\r\n\r\n\t\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\r\n\r\n\t\t\t\tif (obj.expr) {\r\n\t\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\t\tif (!rettype.equals(expr.type))\r\n\t\t\t\t\t\tthrow scope.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = new Type({\r\n\t\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\t\tfrom: params.map(variable => variable.type),\r\n\t\t\t\t\t\tto: rettype\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\ttype = null;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn new Fun({isSchema: false, annotations: [], name, type, params, expr, doc, tex}, scope);\r\n\t}\r\n\r\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Funcall {\r\n\t\tif (obj._type != 'funcall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar fun = PI.expr0(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(arg => {\r\n\t\t\treturn PI.expr0(arg, scope);\r\n\t\t});\r\n\r\n\t\treturn new Funcall({fun, args}, scope);\r\n\t}\r\n\r\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope): Metaexpr {\r\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PI.tee(obj, scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PI.reduction(obj, scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PI.schemacall(obj, scope);\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PI.schema(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.metavar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\r\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\r\n\t\t\tconsole.log(obj);\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'funcall':\r\n\t\t\t\treturn PI.funcall(obj, scope);\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\treturn PI.fun(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.variable(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Metaexpr {\r\n\t\tif (obj._type != 'var')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj.type) {\r\n\t\t\tcase '@':\r\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\r\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\r\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\r\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn scope.hypotheses[hypnum];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow scope.error(`Unknown selector query @${obj.name}`);\r\n\t\t\tcase '$':\r\n\t\t\t\tif (!scope.has$(obj.name)) {\r\n\t\t\t\t\tthrow scope.error(`${obj.name} is not defined`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn scope.get$(obj.name);\r\n\t\t\tcase 'normal':\r\n\t\t\t\tif (!scope.hasSchema(obj.name))\r\n\t\t\t\t\tthrow scope.error(`Schema ${obj.name} is not defined`);\r\n\r\n\t\t\t\treturn scope.getSchema(obj.name);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static tee(obj: TeeObject, parentScope: Scope): Tee {\r\n\t\tif (obj._type != 'tee')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\r\n\r\n\t\tvar left = obj.left.map(o => PI.metaexpr(o, scope));\r\n\r\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\r\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scopeRight);\r\n\r\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scopeRight.add$($v);\r\n\t\t});\r\n\r\n\t\tvar right = PI.metaexpr(obj.right, scopeRight);\r\n\r\n\t\treturn new Tee({left, def$s, right}, scope);\r\n\t}\r\n\r\n\tpublic static def$(obj: Def$Object, parentScope: Scope): $Variable {\r\n\t\tif (obj._type != 'def$')\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t\r\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\r\n\t\t\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new $Variable({name: obj.name, expr}, scope);\r\n\t}\r\n\r\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope): Fun {\r\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name: string = null,\r\n\t\t\taxiomatic: boolean = false,\r\n\t\t\tdoc: string = null,\r\n\t\t\tannotations: string[] = [];\r\n\r\n\t\tif (obj._type == 'defschema') {\r\n\t\t\tname = obj.name; axiomatic = obj.axiomatic;\r\n\t\t\tdoc = obj.doc; annotations = obj.annotations;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\r\n\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.variable(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnVariable(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\t\t\t\r\n\t\t\treturn scope.addVariable(tv);\r\n\t\t});\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scope);\r\n\r\n\t\t\tif (scope.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scope.add$($v);\r\n\t\t});\r\n\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new Fun({isSchema: true, doc, annotations, axiomatic, name, params, def$s, expr}, scope);\r\n\t}\r\n\r\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope): Funcall {\r\n\t\tif (obj._type != 'schemacall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar fun = PI.metaexpr(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(obj => {\r\n\t\t\treturn PI.expr0(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Funcall({\r\n\t\t\tfun,\r\n\t\t\targs\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope): Reduction {\r\n\t\tif (obj._type != 'reduction')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\r\n\r\n\t\tvar subject = PI.metaexpr(obj.subject, scope);\r\n\r\n\t\tvar guesses = !obj.guesses\r\n\t\t\t? null\r\n\t\t\t: obj.guesses.map(g => {\r\n\t\t\t\treturn g && PI.expr0(g, scope);\r\n\t\t\t});\r\n\r\n\t\tvar leftargs = obj.leftargs.map(obj => {\r\n\t\t\treturn PI.metaexpr(obj, scope);\r\n\t\t});\r\n\r\n\t\tvar expected = obj.expected && PI.metaexpr(obj.expected, scope);\r\n\r\n\t\treturn new Reduction({\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs,\r\n\t\t\texpected\r\n\t\t}, scope);\r\n\t}\r\n}"],"sourceRoot":""}