{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/nodes/Metaexpr.ts","webpack://math/./src/nodes/ObjectType.ts","webpack://math/./src/nodes/Fun.ts","webpack://math/./src/nodes/$Variable.ts","webpack://math/./src/nodes/Variable.ts","webpack://math/./src/nodes/Funcall.ts","webpack://math/./src/nodes/Expr0.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/ObjectFun.ts","webpack://math/./src/nodes/Schema.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Nameable.ts","webpack://math/./src/nodes/Reduction.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/PegInterface.ts","webpack://math/./src/ProofExplorer.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts","webpack://math/./node_modules/process/browser.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","scope","doc","tex","_id","toIndentedString","message","error","Error","replace","precedence","code","match","g1","hyps","length","prec","Array","console","log","my","normalizePrecedence","your","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","EqualsPriority","Metaexpr","type","super","obj","equals","getEqualsPriority","equalsInternal","ObjectType","origin","isFunctional","isBaseType","base","functional","from","map","f","some","e","to","resolved","resolve","toSimpleString","join","indent","isSimple","toTeXString","Fun","annotations","sealed","params","expr","parsed","parseTeX","variable","isProved","ONE","placeholders","types","push","isParam","thisCall","fun","unseal","objCall","Map","set","substitute","$Variable","andFuncalls","expandMeta","FOUR","escapeTeX","Variable","guess","ZERO","Funcall","isNameable","resolvedType","paramTypes","argTypes","arg","callee","isExpandable","expandOnce","THREE","thisIsExpandable","objIsExpandable","every","_","repeat","funcallToTeXString","Expr0","MetaType","left","right","ObjectFun","has","makeTeX","Schema","axiomatic","def$s","_isProvedCache","cache","toTeXStringWithId","Tee","$","concat","lef","TWO","expanded","Type","Reduction","subject","guesses","leftargs","expected","forEach","derefs","tee","query","leftargTypes","leftargsExpanded","reduced","recurse","node","ptr","test","grammar","default","Program","parser","scopeMap","filename","loader","loadModuleInternal","parse","feed","lines","line","_type","scope2","importMap","hasType","addType","hasVariable","addVariable","addFun","schema","hasSchema","addSchema","reduction","schemacall","metavar","ktx","typeObjToString","ftype","typeObjToNestedArr","PI","parentScope","extend","location","getType","includes","getVariable","tvo","tv","hasOwnVariable","rettype","expr0","funcall","hypnum","Number","slice","hypotheses","has$","get$","getSchema","metaexpr","scopeRight","$v","def$","hasOwn$","add$","g","ProofExplorer","DIAMOND","theexpr","ncols","Math","max","getHtmlLine","h1","h2","options","padding","bbb","rrb","htmlLeft","a","pop","exprToHtml","expand","tree","getTree","hypnumMap","$Map","num","leftarglines","leftargnums","subjectlines","subjectnum","schemalines","start","$lines","$num","leftlines","rightlines","html","tree2html","newleft","fill","Scope","parent","trace","typedefMap","defMap","schemaMap","baseType","child","h","values","hasOwnType","broadcast","filter","hasOwnSchema","StackTrace","stack","process","argv","column","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","runClearTimeout","marker","Item","array","noop","nextTick","arguments","apply","title","browser","env","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","import Scope from '../Scope';\r\n\r\nvar ctr = 0;\r\n\r\nexport type Precedence = boolean | number | [number, number];\r\n\r\nexport default abstract class Node {\r\n\tpublic readonly _id: number;\r\n\r\n\tpublic readonly doc: string;\r\n\tpublic readonly tex: string;\r\n\tpublic precedence: Precedence;\r\n\r\n\tpublic static readonly PREC_FUNEXPR = 1000;\r\n\tpublic static readonly PREC_COMMA = 1000;\r\n\tpublic static readonly PREC_COLONEQQ = 100000;\r\n\r\n\tconstructor (scope: Scope, doc: string, tex: string) {\r\n\t\tthis._id = ++ctr;\r\n\t\tthis.doc = doc;\r\n\t\tthis.tex = tex;\r\n\t}\r\n\r\n\tpublic toString() {\r\n\t\treturn this.toIndentedString(0);\r\n\t}\r\n\r\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\r\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\r\n\r\n\tpublic static error(message: string, scope: Scope) {\r\n\t\tif (scope) {\r\n\t\t\treturn scope.error(message);\r\n\t\t} else {\r\n\t\t\treturn new Error(message);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static escapeTeX(s) {\r\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\r\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\r\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\r\n\t\t\t'}': '\\\\}',\r\n\t\t\t'~': '\\\\textasciitilde',\r\n\t\t\t'^': '\\\\textasciicircum',\r\n\t\t\t'\\\\': '\\\\textbackslash'\r\n\t\t})[m]);\r\n\t}\r\n\r\n\tpublic static parseTeX(tex) {\r\n\t\tvar precedence: Precedence = false;\r\n\r\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\r\n\t\t\tprecedence = g1 * 1;\r\n\t\t\treturn '';\r\n\t\t});\r\n\r\n\t\treturn {precedence, code};\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\r\n\t\tfor (var i = 0; i < hyps.length; i++) {\r\n\t\t\tif (hyps[i] == this) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t* false corresponds to 0.\r\n\t* true corresponds to w * 2.\r\n\t*/\r\n\tpublic static normalizePrecedence(prec: Precedence) {\r\n\t\tif (prec === false) return [0, 0];\r\n\t\tif (prec === true) return [2, 0];\r\n\t\tif (typeof prec == 'number') return [0, prec];\r\n\r\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\r\n\t\t\tconsole.log(prec);\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn prec;\r\n\t}\r\n\r\n\tpublic shouldConsolidate(prec: Precedence) {\r\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\r\n\t\t\tyour = Node.normalizePrecedence(prec || false);\r\n\r\n\t\tif (my[0] == 0 && my[1] == 0) return false;\r\n\r\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\r\n\t}\r\n\r\n\tpublic makeTeX(id, args, prec) {\r\n\t\targs = args || [];\r\n\t\tprec = prec || false;\r\n\t\t\r\n\t\tvar ret = this.tex;\r\n\r\n\t\tif (this.shouldConsolidate(prec)) {\r\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\r\n\t\t}\r\n\r\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\r\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\r\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\r\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\r\n\t\t});\r\n\t}\r\n}","import Scope from \"../Scope\";\r\nimport Expr0 from \"./Expr0\";\r\nimport Node from \"./Node\";\r\nimport Type from \"./Type\";\r\nimport Variable from \"./Variable\";\r\n\r\n/**\r\n * 숫자가 큰 것이 우선순위가 높다.\r\n */\r\nexport enum EqualsPriority {\r\n\t/** Variable */\r\n\tZERO,\r\n\t/** Fun */\r\n\tONE,\r\n\t/** Tee */\r\n\tTWO,\r\n\t/** Funcall */\r\n\tTHREE,\r\n\t/** $Variable, Reduction */\r\n\tFOUR\r\n}\r\n\r\nexport default abstract class Metaexpr extends Node {\r\n\tpublic readonly type: Type;\r\n\r\n\tconstructor(scope: Scope, doc: string, tex: string, type: Type) {\r\n\t\tsuper(scope, doc, tex);\r\n\r\n\t\tif (!type) throw Node.error('Assertion failed', scope);\r\n\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\tpublic abstract substitute(map: Map<Variable, Expr0>): Metaexpr;\r\n\r\n\t/**\r\n\t * \r\n\t * @param andFuncalls 이름 없는 Funcall도 푼다.\r\n\t */\r\n\tpublic abstract expandMeta(andFuncalls: boolean): Metaexpr;\r\n\r\n\tpublic equals(obj: Metaexpr): boolean {\r\n\t\tif (this === obj) return true;\r\n\t\tif (!this.type.equals(obj.type)) return false;\r\n\r\n\t\tif (obj.getEqualsPriority() > this.getEqualsPriority())\r\n\t\t\treturn obj.equalsInternal(this);\r\n\t\t\r\n\t\treturn this.equalsInternal(obj);\r\n\t}\r\n\r\n\tprotected abstract getEqualsPriority(): EqualsPriority;\r\n\r\n\tprotected abstract equalsInternal(obj: Metaexpr): boolean;\r\n}","import Nameable from './Nameable';\r\nimport Node from './Node';\r\nimport Type from './Type';\r\n\r\nexport default class ObjectType extends Type implements Nameable {\r\n\r\n\tpublic readonly isBaseType: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly origin: ObjectType;\r\n\tpublic readonly from: ObjectType[];\r\n\tpublic readonly to: ObjectType;\r\n\r\n\tconstructor (o) {\r\n\t\tif (o.origin) {\r\n\t\t\tsuper(null, o.doc, null, o.origin.isFunctional);\r\n\r\n\t\t\tthis.isBaseType = !!o.base;\r\n\r\n\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\r\n\t\t\tthis.name = o.name;\r\n\r\n\t\t\tif (!(o.origin instanceof ObjectType))\r\n\t\t\t\tthrow Node.error('!(o.origin instanceof ObjectType)', null);\r\n\r\n\t\t\tthis.origin = o.origin;\r\n\t\t} else {\r\n\t\t\tsuper(null, o.doc, null, o.functional);\r\n\r\n\t\t\tthis.isBaseType = !!o.base;\r\n\r\n\t\t\tif (typeof o.functional != 'boolean')\r\n\t\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\r\n\r\n\t\t\tif (!o.functional) {\r\n\t\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\r\n\t\t\t\tthis.name = o.name;\r\n\t\t\t} else {\r\n\t\t\t\tif (o.from.map(f => f instanceof ObjectType).some(e => !e))\r\n\t\t\t\t\tthrow Node.error('o.from.map(f => f instanceof ObjectType).some(e => !e)', null);\r\n\t\t\t\tif (!(o.to instanceof ObjectType))\r\n\t\t\t\t\tthrow Node.error('!(o.to instanceof ObjectType)', null);\r\n\r\n\t\t\t\tthis.from = o.from;\r\n\t\t\t\tthis.to = o.to;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toSimpleString() {\r\n\t\tif (this.name) return this.name;\r\n\r\n\t\tvar resolved = this.resolve();\r\n\r\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent): string {\r\n\t\tif (this.isSimple) return this.name;\r\n\r\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(root?: boolean) {\r\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\r\n\t\tif (!root && this.name) {\r\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\t\t}\r\n\r\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\r\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\r\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\r\n\t}\r\n\r\n\tpublic resolve(): ObjectType {\r\n\t\treturn this.origin ? this.origin.resolve() : this;\r\n\t}\r\n\r\n\tpublic equals(t: Type): boolean {\r\n\t\tif (!(t instanceof ObjectType)) return false;\r\n\r\n\t\tif (this.origin) return this.origin.equals(t);\r\n\t\tif (t.origin) return this.equals(t.origin);\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) return this === t;\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (var i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport Expr0 from './Expr0';\r\nimport Funcall from './Funcall';\r\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\r\nimport MetaType from './MetaType';\r\nimport Nameable from './Nameable';\r\nimport Node from './Node';\r\nimport ObjectType from './ObjectType';\r\nimport Type from './Type';\r\nimport Variable from './Variable';\r\n\r\ninterface FunArgumentType {\r\n\tdoc?: string;\r\n\ttex?: string;\r\n\tannotations: string[];\r\n\tsealed: boolean;\r\n\ttype?: Type;\r\n\tname?: string;\r\n\tparams: Variable[];\r\n\texpr?: Metaexpr;\r\n}\r\n\r\nexport default abstract class Fun extends Expr0 implements Nameable {\r\n\r\n\tpublic readonly annotations: string[];\r\n\tpublic readonly sealed: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly params: Variable[];\r\n\tpublic readonly expr: Metaexpr;\r\n\r\n\t/*\r\n\t * name, expr 중 하나 이상 있어야 하고 type, expr 중\r\n\t * 한 개만 있어야 한다.\r\n\t */\r\n\tconstructor ({doc, tex, annotations, sealed, type, name, params, expr}: FunArgumentType, scope?: Scope) {\r\n\t\tif (!name && !expr)\r\n\t\t\tthrow Node.error('Anonymous fun cannot be primitive', scope);\r\n\r\n\t\tif (type && expr)\r\n\t\t\tthrow Node.error('no', scope);\r\n\r\n\t\tif (!type && !expr)\r\n\t\t\tthrow Node.error('Cannot guess the type of a primitive fun', scope);\r\n\t\t\r\n\t\tvar precedence = false;\r\n\r\n\t\tif (tex) {\r\n\t\t\tvar parsed = Node.parseTeX(tex);\r\n\t\t\tprecedence = parsed.precedence;\r\n\t\t\ttex = parsed.code;\r\n\t\t} else {\r\n\t\t\ttex = null;\r\n\t\t}\r\n\t\t\r\n\t\tsuper(\r\n\t\t\tscope, doc, tex,\r\n\t\t\ttype || new (expr.type instanceof ObjectType ? ObjectType : MetaType)({\r\n\t\t\t\tfunctional: true,\r\n\t\t\t\tfrom: params.map(variable => variable.type),\r\n\t\t\t\tto: expr.type as any\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tthis.annotations = annotations;\r\n\t\tthis.sealed = sealed;\r\n\t\tthis.precedence = precedence;\r\n\t\tthis.name = name;\r\n\t\tthis.params = params;\r\n\t\tthis.expr = expr;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.expr && this.expr.isProved(hyps);\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.ONE;\r\n\t}\r\n\t\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\tif (!(this.expr && !this.sealed)\r\n\t\t\t\t&& !(obj instanceof Fun && obj.expr && !obj.sealed)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar placeholders = [];\r\n\t\tvar types = (this.type.resolve() as ObjectType | MetaType).from;\r\n\r\n\t\tfor (var i = 0; i < types.length; i++) {\r\n\t\t\tplaceholders.push(new Variable({\r\n\t\t\t\tisParam: true,\r\n\t\t\t\ttype: types[i],\r\n\t\t\t\tname: '$' + i\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\tvar thisCall = this.expr && !this.sealed\r\n\t\t\t? this.call(placeholders)\r\n\t\t\t: new Funcall({\r\n\t\t\t\tfun: this,\r\n\t\t\t\tunseal: false,\r\n\t\t\t\targs: placeholders\r\n\t\t\t});\r\n\r\n\t\tvar objCall = obj instanceof Fun && obj.expr && !obj.sealed\r\n\t\t\t? obj.call(placeholders)\r\n\t\t\t: new Funcall({\r\n\t\t\t\tfun: obj,\r\n\t\t\t\tunseal: false,\r\n\t\t\t\targs: placeholders\r\n\t\t\t});\r\n\t\t\r\n\t\treturn thisCall.equals(objCall);\r\n\t}\r\n\r\n\tpublic call(args: Expr0[]): Metaexpr {\r\n\t\tif (!this.expr) {\r\n\t\t\tthrow Error('Cannot call a primitive fun');\r\n\t\t}\r\n\r\n\t\tif (this.params.length != args.length) {\r\n\t\t\tthrow Error('Illegal arguments length');\r\n\t\t}\r\n\r\n\t\tvar map: Map<Variable, Expr0> = new Map();\r\n\r\n\t\tfor (var i = 0; i < this.params.length; i++) {\r\n\t\t\tmap.set(this.params[i], args[i]);\r\n\t\t}\r\n\r\n\t\treturn this.expr.substitute(map);\r\n\t}\r\n}\r\n\r\n","import Scope from \"../Scope\";\r\nimport Expr0 from \"./Expr0\";\r\nimport Metaexpr, { EqualsPriority } from \"./Metaexpr\";\r\nimport Nameable from \"./Nameable\";\r\nimport Node, { Precedence } from \"./Node\";\r\nimport Variable from \"./Variable\";\r\n\r\ninterface $VariableArgumentType {\r\n\tname: string;\r\n\texpr: Metaexpr;\r\n}\r\n\r\nexport default class $Variable extends Metaexpr implements Nameable {\r\n\r\n\tpublic readonly name: string;\r\n\tpublic readonly expr: Metaexpr;\r\n\r\n\tconstructor ({name, expr}: $VariableArgumentType, scope?: Scope) {\r\n\t\tsuper(scope, null, null, expr.type);\r\n\r\n\t\tif (!name || !expr) {\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\t\t}\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.expr = expr;\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.expr.isProved(hyps);\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\treturn this.expr.substitute(map);\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\treturn this.expr.expandMeta(andFuncalls);\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.FOUR;\r\n\t}\r\n\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\treturn this.expr.equals(obj);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn this.name;\r\n\t}\r\n\t\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `\\\\mathtt{${Node.escapeTeX(this.name)}}`;\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport Expr0 from './Expr0';\r\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\r\nimport Nameable from './Nameable';\r\nimport Node, { Precedence } from './Node';\r\nimport ObjectType from './ObjectType';\r\n\r\ninterface VariableArgumentType {\r\n\tdoc?: string;\r\n\ttex?: string;\r\n\ttype: ObjectType;\r\n\tname: string;\r\n\tisParam: boolean;\r\n\tguess?: string;\r\n}\r\n\r\nexport default class Variable extends Expr0 implements Nameable {\r\n\t\r\n\tpublic readonly isParam: boolean;\r\n\tpublic readonly guess: string;\r\n\tpublic readonly type: ObjectType;\r\n\tpublic readonly name: string;\r\n\r\n\tconstructor ({doc, tex, type, name, isParam, guess}: VariableArgumentType, scope?: Scope) {\r\n\t\tsuper(scope, doc, tex, type);\r\n\r\n\t\tthis.isParam = !!isParam;\r\n\t\tthis.guess = guess || null;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps);\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\treturn map.get(this) || this;\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.ZERO;\r\n\t}\r\n\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// pr f\r\n\tpublic toSimpleString() {\r\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\r\n\r\n\t\tvar tex = this.tex\r\n\t\t\t|| (\r\n\t\t\t\tthis.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.name)}}`\r\n\t\t\t);\r\n\t\t\r\n\t\treturn `\\\\href{#${id}}{${tex}}`;\r\n\t}\r\n\r\n\tpublic toTeXStringWithId(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.isParam) throw Error('wut');\r\n\r\n\t\tvar id =`id-${this._id}`;\r\n\r\n\t\treturn [\r\n\t\t\t`\\\\htmlId{${id}}{`,\r\n\t\t\tthis.toTeXString(prec, root),\r\n\t\t\t`}`\r\n\t\t].join('');\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport $Variable from './$Variable';\r\nimport Expr0 from './Expr0';\r\nimport Fun from './Fun';\r\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\r\nimport MetaType from './MetaType';\r\nimport { isNameable } from './Nameable';\r\nimport Node, { Precedence } from './Node';\r\nimport ObjectFun from './ObjectFun';\r\nimport ObjectType from './ObjectType';\r\nimport Schema from './Schema';\r\nimport Variable from './Variable';\r\n\r\ninterface FuncallArgumentType {\r\n\tfun: Metaexpr;\r\n\tunseal: boolean;\r\n\targs: Expr0[];\r\n}\r\n\r\nexport default class Funcall extends Expr0 {\r\n\t\r\n\tpublic readonly fun: Metaexpr;\r\n\tpublic readonly unseal: boolean;\r\n\tpublic readonly args: Expr0[];\r\n\r\n\tconstructor ({fun, unseal, args}: FuncallArgumentType, scope?: Scope) {\r\n\t\tif (fun.type.isSimple) {\r\n\t\t\tvar name = isNameable(fun) ? fun.name : '<anonymous>';\r\n\t\t\tthrow Node.error(`${name} is not callable`, scope);\r\n\t\t}\r\n\r\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\t\t\t \r\n\t\tvar resolvedType = fun.type.resolve() as ObjectType | MetaType,\r\n\t\t\tparamTypes = resolvedType.from,\r\n\t\t\targTypes = args.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, scope);\r\n\r\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\r\n\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, scope);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper(scope, null, null, resolvedType.to);\r\n\t\t\r\n\t\tthis.fun = fun;\r\n\t\tthis.unseal = unseal;\r\n\t\tthis.args = args;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.fun.isProved(hyps);\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\treturn new Funcall({\r\n\t\t\tfun: this.fun.substitute(map),\r\n\t\t\tunseal: this.unseal,\r\n\t\t\targs: this.args.map(arg => arg.substitute(map))\r\n\t\t});\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\tvar fun = this.fun.expandMeta(andFuncalls),\r\n\t\t\tunseal = this.unseal,\r\n\t\t\targs = this.args.map(arg => arg.expandMeta(andFuncalls));\r\n\t\t\r\n\t\tif (!(fun instanceof Fun) || !fun.expr || fun.name && !(fun instanceof Schema))\r\n\t\t\treturn new Funcall({fun, unseal, args});\r\n\r\n\t\treturn fun.call(args).expandMeta(andFuncalls);\r\n\t}\r\n\r\n\tpublic isExpandable(): boolean {\r\n\t\tvar callee: Metaexpr = this.fun;\r\n\r\n\t\twhile (callee instanceof $Variable) {\r\n\t\t\tcallee = callee.expr;\r\n\t\t}\r\n\r\n\t\tif (callee instanceof Funcall) {\r\n\t\t\treturn callee.isExpandable();\r\n\t\t}\r\n\r\n\t\tif (!(callee instanceof Fun)) return false;\r\n\r\n\t\treturn callee.expr && !(callee.sealed && !this.unseal);\r\n\t}\r\n\t\r\n\tpublic expandOnce(): Metaexpr {\r\n\t\tif (!this.isExpandable()) {\r\n\t\t\tthrow Error('Cannot expand');\r\n\t\t}\r\n\r\n\t\tvar callee: Metaexpr = this.fun;\r\n\r\n\t\twhile (callee instanceof $Variable) {\r\n\t\t\tcallee = callee.expr;\r\n\t\t}\r\n\r\n\t\tif (callee instanceof Funcall) {\r\n\t\t\treturn new Funcall({\r\n\t\t\t\tfun: callee.expandOnce(),\r\n\t\t\t\tunseal: this.unseal,\r\n\t\t\t\targs: this.args\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!(callee instanceof Fun)) {\r\n\t\t\tthrow Error('Something\\'s wrong');\r\n\t\t}\r\n\r\n\t\treturn callee.call(this.args);\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.THREE;\r\n\t}\r\n\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\tif (!(obj instanceof Funcall)) {\r\n\t\t\tif (!this.isExpandable()) return false;\r\n\r\n\t\t\treturn this.expandOnce().equals(obj);\r\n\t\t}\r\n\r\n\t\tif (this.fun.equals(obj.fun)) {\r\n\t\t\tfor (var i = 0; i < this.args.length; i++) {\r\n\t\t\t\tif (!this.args[i].equals(obj.args[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.fun instanceof Funcall && this.fun.isExpandable()) {\r\n\t\t\treturn this.expandOnce().equals(obj);\r\n\t\t}\r\n\r\n\t\tif (obj.fun instanceof Funcall && obj.fun.isExpandable()) {\r\n\t\t\treturn this.equals(obj.expandOnce());\r\n\t\t}\r\n\r\n\t\tvar thisIsExpandable = this.isExpandable(),\r\n\t\t\tobjIsExpandable = obj.isExpandable();\r\n\t\t\r\n\t\tif (this.fun == obj.fun || !thisIsExpandable && !objIsExpandable) {\r\n\t\t\tif (this.fun != obj.fun) return false;\r\n\r\n\t\t\tif (!thisIsExpandable && !objIsExpandable) {\r\n\t\t\t\tfor (var i = 0; i < this.args.length; i++) {\r\n\t\t\t\t\tif (!this.args[i].equals(obj.args[i])) return false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.args.every((_, i) => {\r\n\t\t\t\treturn this.args[i].equals(obj.args[i]);\r\n\t\t\t})) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (thisIsExpandable) {\r\n\t\t\treturn this.expandOnce().equals(obj);\r\n\t\t}\r\n\r\n\t\treturn this.equals(obj.expandOnce());\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar args: any = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (args.join('').length <= 50) {\r\n\t\t\targs = this.args.map(arg => {\r\n\t\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\targs = args.join(', ');\r\n\t\t\t\r\n\t\t\tif (this.fun instanceof Schema) {\r\n\t\t\t\treturn `${this.fun.name || `(${this.fun})`}(${args})`;\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t!(this.fun instanceof Fun) || !this.fun.name\r\n\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\r\n\t\t\t\t\t\t: this.fun.name,\r\n\t\t\t\t\t`(${args})`\r\n\t\t\t\t].join('');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\t\t\r\n\t\t\tif (this.fun instanceof Schema) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tthis.fun.name || `(${this.fun.toIndentedString(indent)})`,\r\n\t\t\t\t\t'(',\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\r\n\t\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\r\n\t\t\t\t\t\t\t: this.fun.name\r\n\t\t\t\t\t) + '(',\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (this.fun instanceof Schema) {\r\n\t\t\treturn (\r\n\t\t\t\tthis.fun.name\r\n\t\t\t\t\t? `\\\\href{#schema-${this.fun.isProved() ? 'p' : 'np'}-${this.fun.name}}{\\\\textsf{${Node.escapeTeX(this.fun.name)}}}`\r\n\t\t\t\t\t: this.fun.toTeXString(false)\r\n\t\t\t) + `\\\\mathord{\\\\left(${this.args.map(arg => {\r\n\t\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t\t}).join(', ')}\\\\right)}`;\r\n\t\t}\r\n\r\n\t\tif (this.fun instanceof ObjectFun)\r\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\r\n\t\t\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t});\r\n\r\n\t\treturn (\r\n\t\t\t!(isNameable(this.fun) && this.fun.name) || this.fun instanceof Variable\r\n\t\t\t\t? this.fun.toTeXString(false)\r\n\t\t\t\t: this.fun.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.fun.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.fun.name)}}`\r\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\r\n\t}\r\n}","import Metaexpr from \"./Metaexpr\";\r\n\r\nexport default abstract class Expr0 extends Metaexpr {\r\n\t\r\n}","import Node, { Precedence } from './Node';\r\nimport ObjectType from './ObjectType';\r\nimport Type from './Type';\r\n\r\ninterface SimpleMetaTypeArgumentType {\r\n\tfunctional: false;\r\n\tleft: Type[];\r\n\tright: Type;\r\n}\r\n\r\ninterface FunctionalMetaTypeArgumentType {\r\n\tfunctional: true;\r\n\tfrom: ObjectType[];\r\n\tto: MetaType;\r\n}\r\n\r\ntype MetaTypeArgumentType = SimpleMetaTypeArgumentType | FunctionalMetaTypeArgumentType;\r\n\r\nexport default class MetaType extends Type {\r\n\t\r\n\tpublic readonly left: Type[];\r\n\tpublic readonly right: Type;\r\n\tpublic readonly from: ObjectType[];\r\n\tpublic readonly to: MetaType;\r\n\r\n\tconstructor (o: MetaTypeArgumentType) {\r\n\t\tsuper(null, null, null, o.functional);\r\n\r\n\t\tif (typeof o.functional != 'boolean')\r\n\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\r\n\r\n\t\tif (o.functional == false) {\r\n\t\t\tif (!(o.left instanceof Array))\r\n\t\t\t\tthrow Node.error('left should be an array', null);\r\n\r\n\t\t\tthis.left = o.left;\r\n\t\t\tthis.right = o.right;\r\n\t\t} else {\r\n\t\t\tif (o.from.some(f => !(f instanceof ObjectType)))\r\n\t\t\t\tthrow Node.error('o.from.some(f => !(f instanceof ObjectType))', null);\r\n\t\t\tif (!(o.to instanceof MetaType))\r\n\t\t\t\tthrow Node.error('!(o.to instanceof MetaType)', null);\r\n\r\n\t\t\tif (o.to.isFunctional)\r\n\t\t\t\tthrow Node.error('Functional metatype in functional metatype is not supported', null);\r\n\r\n\t\t\tthis.from = o.from;\r\n\t\t\tthis.to = o.to;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic resolve(): MetaType {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number) {\r\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\r\n\r\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tthrow new Error('Method not implemented.');\r\n\t}\r\n\r\n\tpublic equals(t: Type): boolean {\r\n\t\tif (!(t instanceof MetaType)) return false;\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) {\r\n\t\t\tif (this.left.length != t.left.length) return false;\r\n\r\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\r\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.right.equals(t.right)) return false;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (let i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Scope from \"../Scope\";\r\nimport Expr0 from \"./Expr0\";\r\nimport Fun from \"./Fun\";\r\nimport Metaexpr from \"./Metaexpr\";\r\nimport Node, { Precedence } from \"./Node\";\r\nimport ObjectType from \"./ObjectType\";\r\nimport Type from \"./Type\";\r\nimport Variable from \"./Variable\";\r\n\r\ninterface ObjectFunArgumentType {\r\n\tdoc?: string;\r\n\ttex?: string;\r\n\tannotations: string[];\r\n\tsealed: boolean;\r\n\ttype?: Type;\r\n\tname?: string;\r\n\tparams: Variable[];\r\n\texpr?: Expr0;\r\n}\r\n\r\nexport default class ObjectFun extends Fun {\r\n\t\r\n\tconstructor ({doc, tex, annotations, sealed, type, name, params, expr}: ObjectFunArgumentType, scope?: Scope) {\r\n\t\tsuper({doc, tex, annotations, sealed, type, name, params, expr}, scope);\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\tif (!this.expr) return this;\r\n\r\n\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\tif (this.name) return this;\r\n\r\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\tif (this.params.some(e => map.has(e)))\r\n\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\treturn new ObjectFun({\r\n\t\t\tannotations: this.annotations,\r\n\t\t\tsealed: this.sealed,\r\n\t\t\tname: null,\r\n\t\t\tparams: this.params,\r\n\t\t\texpr: this.expr.substitute(map)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\tif (!this.expr) return this;\r\n\t\tif (this.type instanceof ObjectType && this.name) return this;\r\n\r\n\t\treturn new ObjectFun({\r\n\t\t\tannotations: this.annotations,\r\n\t\t\tsealed: this.sealed,\r\n\t\t\tname: null,\r\n\t\t\tparams: this.params,\r\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (this.name) return this.name;\r\n\t\t\r\n\t\treturn [\r\n\t\t\t`ƒ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t'\\\\mapsto ',\r\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\r\n\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\r\n\t\tif (!root)\r\n\t\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${Node.escapeTeX(this.name)}}`;\r\n\t\r\n\t\tif (!this.expr)\r\n\t\t\treturn this.funcallToTeXString(this.params, prec);\r\n\t\r\n\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\r\n\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\r\n\t}\r\n\r\n\tpublic funcallToTeXString(args, prec) {\r\n\t\targs = args.map(arg => {\r\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\r\n\t\t});\r\n\t\r\n\t\tif (this.tex) {\r\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\r\n\t\t}\r\n\t\r\n\t\treturn (\r\n\t\t\t!this.name\r\n\t\t\t\t? this.toTeXString(false)\r\n\t\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? Node.escapeTeX(this.name) : `\\\\mathrm{${Node.escapeTeX(this.name)}}`}}`\r\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\r\n\t}\r\n}","import Scope from \"../Scope\";\r\nimport $Variable from \"./$Variable\";\r\nimport Expr0 from \"./Expr0\";\r\nimport Fun from \"./Fun\";\r\nimport Metaexpr from \"./Metaexpr\";\r\nimport Node, { Precedence } from \"./Node\";\r\nimport ObjectType from \"./ObjectType\";\r\nimport Variable from \"./Variable\";\r\n\r\ninterface SchemaArgumentType {\r\n\tdoc?: string;\r\n\ttex?: string;\r\n\tannotations: string[];\r\n\taxiomatic: boolean;\r\n\tname?: string;\r\n\tparams: Variable[];\r\n\tdef$s: $Variable[];\r\n\texpr: Metaexpr;\r\n}\r\n\r\nexport default class Schema extends Fun {\r\n\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly def$s: $Variable[];\r\n\tprivate _isProvedCache: boolean;\r\n\r\n\tconstructor ({doc, tex, annotations, axiomatic, name, params, def$s, expr}: SchemaArgumentType, scope?: Scope) {\r\n\t\tsuper({doc, tex, annotations, sealed: false, type: null, name, params, expr}, scope);\r\n\t\t\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.def$s = def$s || [];\r\n\t}\r\n\t\r\n\tpublic isProved(hyps?) {\r\n\t\tif (this._isProvedCache) return true;\r\n\r\n\t\tif (!hyps && typeof this._isProvedCache == 'boolean') {\r\n\t\t\treturn this._isProvedCache;\r\n\t\t}\r\n\r\n\t\tvar cache = !hyps;\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\tvar ret = this.axiomatic || super.isProved(hyps);\r\n\t\tif (cache) this._isProvedCache = ret;\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\tif (!this.expr) return this;\r\n\r\n\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\tif (this.name) return this;\r\n\r\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\tif (this.params.some(e => map.has(e)))\r\n\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\treturn new Schema({\r\n\t\t\tannotations: this.annotations,\r\n\t\t\taxiomatic: this.axiomatic,\r\n\t\t\tname: null,\r\n\t\t\tparams: this.params,\r\n\t\t\tdef$s: this.def$s,\r\n\t\t\texpr: this.expr.substitute(map)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\tif (!this.expr) return this;\r\n\t\tif (this.type instanceof ObjectType && this.name) return this;\r\n\r\n\t\treturn new Schema({\r\n\t\t\tannotations: this.annotations,\r\n\t\t\taxiomatic: this.axiomatic,\r\n\t\t\tname: null,\r\n\t\t\tparams: this.params,\r\n\t\t\tdef$s: this.def$s,\r\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\r\n\t\t});\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn [\r\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t\t'\\t' + this.expr.expandMeta(true).toIndentedString(indent + 1),\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\t\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t'\\\\mapsto ',\r\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\r\n\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\t\r\n\t\tvar id = `schema-${this.isProved() ? 'p' : 'np'}-${this.name}`;\r\n\t\r\n\t\tif (!root)\r\n\t\t\treturn `\\\\href{#${id}}\\\\mathsf{${Node.escapeTeX(this.name)}}`;\r\n\t\r\n\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}\\\\mathord{\\\\left(${this.params.map(e => e.toTeXStringWithId(Node.PREC_COMMA) + (e.guess ? `: \\\\texttt{@${e.guess}}` : '')).join(', ')}\\\\right)}:\\\\\\\\\\\\quad`\r\n\t\t\t\t+ this.expr.expandMeta(true).toTeXString(true);\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport $Variable from './$Variable';\r\nimport Expr0 from './Expr0';\r\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\r\nimport MetaType from './MetaType';\r\nimport Node, { Precedence } from './Node';\r\nimport ObjectType from './ObjectType';\r\nimport Variable from './Variable';\r\n\r\ninterface TeeArgumentType {\r\n\tleft: Metaexpr[];\r\n\tdef$s?: $Variable[];\r\n\tright: Metaexpr;\r\n}\r\n\r\nexport default class Tee extends Metaexpr {\r\n\r\n\tpublic readonly left;\r\n\tpublic readonly def$s: $Variable[];\r\n\tpublic readonly right;\r\n\r\n\tconstructor ({left, def$s, right}: TeeArgumentType, scope?: Scope) {\r\n\t\tif (!(left instanceof Array\r\n\t\t\t\t&& left.every(l => {\r\n\t\t\t\t\treturn l.type instanceof ObjectType\r\n\t\t\t\t\t\t|| l.type instanceof MetaType;\r\n\t\t\t\t}))) {\r\n\t\t\tconsole.log(left);\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\t\t}\r\n\r\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $ instanceof $Variable)))\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\r\n\t\tif (!(right.type instanceof ObjectType || right.type instanceof MetaType)) {\r\n\t\t\tconsole.log(right);\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\t\t}\r\n\r\n\t\tif (right.type.isFunctional) {\r\n\t\t\tthrow Node.error('RHS of a rule cannot be a schema', scope);\r\n\t\t}\r\n\r\n\t\tsuper(scope, null, null, new MetaType({\r\n\t\t\tfunctional: false,\r\n\t\t\tleft: left.map(e => e.type),\r\n\t\t\tright: right.type\r\n\t\t}));\r\n\r\n\t\tthis.left = left;\r\n\t\tthis.def$s = def$s || [];\r\n\t\tthis.right = right;\r\n\t\tthis.precedence = Node.PREC_COMMA;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.right.isProved(hyps.concat(this.left));\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\tvar left = this.left.map(e => e.substitute(map));\r\n\t\tvar right = this.right.substitute(map);\r\n\r\n\t\treturn new Tee({\r\n\t\t\tleft, right\r\n\t\t});\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\tvar left = this.left.map(lef => lef.expandMeta(andFuncalls));\r\n\t\tvar right = this.right.expandMeta(andFuncalls);\r\n\r\n\t\treturn new Tee({left, right});\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.TWO;\r\n\t}\r\n\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\tif (!(obj instanceof Tee)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (this.left.length != obj.left.length) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.left.length; i++) {\r\n\t\t\tif (!this.left[i].equals(obj.left[i])) return false;\r\n\t\t}\r\n\r\n\t\treturn this.right.equals(obj.right);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (!this.left.length) {\r\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\r\n\t\t}\r\n\t\r\n\t\treturn [\r\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\r\n\t\t\t'|-',\r\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\t\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar expanded = this.expandMeta(true) as Tee;\r\n\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n}","import Scope from \"../Scope\";\r\nimport Node from \"./Node\";\r\n\r\nexport default abstract class Type extends Node {\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\t\r\n\tpublic abstract equals(t: Type): boolean;\r\n\r\n\tconstructor (scope: Scope, doc: string, tex: string, isFunctional: boolean) {\r\n\t\tsuper(scope, doc, tex);\r\n\t\tthis.isFunctional = isFunctional;\r\n\t\tthis.isSimple = !isFunctional;\r\n\t}\r\n\r\n\tpublic abstract resolve(): Type;\r\n}","export default interface Nameable {\r\n\tname: string;\r\n}\r\n\r\nexport function isNameable(obj: object): obj is Nameable {\r\n\treturn 'name' in obj;\r\n}","import Scope from '../Scope';\r\nimport Expr0 from './Expr0';\r\nimport Fun from './Fun';\r\nimport Funcall from './Funcall';\r\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\r\nimport MetaType from './MetaType';\r\nimport Node, { Precedence } from './Node';\r\nimport ObjectType from './ObjectType';\r\nimport Tee from './Tee';\r\nimport Variable from './Variable';\r\n\r\ninterface ReductionArgumentType {\r\n\tsubject: Metaexpr;\r\n\tguesses: Expr0[];\r\n\tleftargs: Metaexpr[];\r\n\texpected: Metaexpr;\r\n}\r\n\r\nexport default class Reduction extends Metaexpr {\r\n\t\r\n\tpublic readonly subject: Metaexpr;\r\n\tpublic readonly guesses;\r\n\tpublic readonly leftargs: Metaexpr[];\r\n\tpublic readonly reduced: Metaexpr;\r\n\r\n\tconstructor ({subject, guesses, leftargs, expected}: ReductionArgumentType, scope?: Scope) {\r\n\t\tif (guesses) {\r\n\t\t\tlet resolvedType = subject.type.resolve() as ObjectType | MetaType,\r\n\t\t\t\tparamTypes = resolvedType.from,\r\n\t\t\t\targTypes = guesses.map(e => e && e.type);\r\n\r\n\t\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, scope);\r\n\r\n\t\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\t\tif (argTypes[i] && !paramTypes[i].equals(argTypes[i])) {\r\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, scope);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (subject instanceof Fun) {\r\n\t\t\tsubject.params.forEach((p, i) => {\r\n\t\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\r\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} could not be guessed`, scope);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t\tvar derefs = subject.params.map((p, i) => {\r\n\t\t\t\tif (guesses && guesses[i]) return guesses[i];\r\n\r\n\t\t\t\tvar tee = (subject as Fun).expr.expandMeta(false) as Tee;\r\n\t\r\n\t\t\t\treturn Reduction.query(\r\n\t\t\t\t\tp.guess,\r\n\t\t\t\t\ttee.left,\r\n\t\t\t\t\tleftargs,\r\n\t\t\t\t\ttee.right,\r\n\t\t\t\t\texpected,\r\n\t\t\t\t\tscope\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\r\n\t\t\tsubject = new Funcall({\r\n\t\t\t\tfun: subject,\r\n\t\t\t\tunseal: false,\r\n\t\t\t\targs: derefs,\r\n\t\t\t}, scope);\r\n\t\t} else if (guesses) {\r\n\t\t\tthrow Node.error('Something\\'s wrong', scope);\r\n\t\t}\r\n\t\r\n\t\tif (!(subject.type instanceof MetaType && subject.type.isSimple))\r\n\t\t\tthrow Node.error('Subject is not reducible', scope);\r\n\t\r\n\t\tif (!(leftargs instanceof Array)\r\n\t\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\r\n\t\tvar paramTypes = subject.type.left,\r\n\t\t\tleftargTypes = leftargs.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != leftargTypes.length)\r\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`, scope);\r\n\r\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\r\n\t\t\t\tthrow Node.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`, scope);\r\n\t\t}\r\n\r\n\t\tsuper(scope, null, null, subject.type.right);\r\n\r\n\t\tthis.subject = subject;\r\n\t\tthis.leftargs = leftargs;\r\n\r\n\t\tvar tee = subject.expandMeta(true);\r\n\r\n\t\tif (!(tee instanceof Tee)) {\r\n\t\t\tthrow Node.error('Assertion failed', scope);\r\n\t\t}\r\n\r\n\t\tvar leftargsExpanded = leftargs.map(arg => {\r\n\t\t\treturn arg.expandMeta(true);\r\n\t\t});\r\n\r\n\t\tfor (let i = 0; i < tee.left.length; i++) {\r\n\t\t\tif (!tee.left[i].equals(leftargsExpanded[i])) {\r\n\t\t\t\tthrow Node.error(`LHS #${i + 1} failed to match:\r\n\r\n--- EXPECTED ---\r\n${tee.left[i].expandMeta(true)}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${leftargs[i].expandMeta(true)}\r\n----------------`, scope);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (expected) {\r\n\t\t\tif (!tee.right.equals(expected)) {\r\n\t\t\t\tthrow Node.error(`RHS failed to match:\r\n\r\n--- EXPECTED ---\r\n${tee.right.expandMeta(true)}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${expected.expandMeta(true)}\r\n----------------`, scope);\r\n\t\t\t}\r\n\r\n\t\t\tthis.reduced = expected;\r\n\t\t} else {\r\n\t\t\tthis.reduced = tee.right;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.subject.isProved(hyps)\r\n\t\t\t\t&& this.leftargs.every(l => l.isProved(hyps));\r\n\t}\r\n\r\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\r\n\t\treturn this.reduced.substitute(map);\r\n\t}\r\n\r\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\r\n\t\treturn this.reduced.expandMeta(andFuncalls);\r\n\t}\r\n\r\n\tprotected getEqualsPriority(): EqualsPriority {\r\n\t\treturn EqualsPriority.FOUR;\r\n\t}\r\n\r\n\tprotected equalsInternal(obj: Metaexpr): boolean {\r\n\t\treturn this.reduced.equals(obj);\r\n\t}\r\n\r\n\tpublic static query(guess, left, leftargs, right, expected, scope: Scope) {\r\n\t\tif (guess.length == 0) throw Node.error('wut', scope);\r\n\r\n\t\tvar lef, ret;\r\n\r\n\t\tif (guess[0] == 'r') {\r\n\t\t\tif (!expected) {\r\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\t\t\t}\r\n\r\n\t\t\tlef = right;\r\n\t\t\tret = expected;\r\n\t\t} else {\r\n\t\t\tif (!(1 <= guess[0] * 1 && guess[0] * 1 <= leftargs.length))\r\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent index out of range`, scope);\r\n\r\n\t\t\tlef = left[guess[0] * 1 - 1];\r\n\t\t\tret = leftargs[guess[0] * 1 - 1];\r\n\t\t}\r\n\r\n\t\treturn (function recurse(guess, lef: Metaexpr, node: Metaexpr, ptr) {\r\n\t\t\tnode = node.expandMeta(true);\r\n\t\t\t\r\n\t\t\tif (guess.length <= ptr) return node;\r\n\r\n\t\t\tif (/[0-9]/.test(guess[ptr])) {\r\n\t\t\t\tvar n = guess[ptr] * 1;\r\n\r\n\t\t\t\tif (lef instanceof Tee && node instanceof Tee) {\r\n\t\t\t\t\tif (lef.left.length != node.left.length) {\r\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent length mismatch`, scope);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(1 <= n && n <= node.left.length)) {\r\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent index out of range`, scope);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recurse(guess, lef.left[n - 1], node.left[n - 1], ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tif (!(lef instanceof Funcall) || !(node instanceof Funcall)) {\r\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (lef.fun.equals(node.fun)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!node.isExpandable()) {\r\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.expandOnce();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.args || !(1 <= n && n <= node.args.length))\r\n\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\r\n\t\t\t\treturn recurse(guess, lef.args[n - 1], node.args[n - 1], ptr + 1);\r\n\t\t\t} else if (guess[ptr] == 'r') {\r\n\t\t\t\tif (lef instanceof Tee && node instanceof Tee) {\r\n\t\t\t\t\treturn recurse(guess, lef.right, node.right, ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\t\t\t}\r\n\r\n\t\t\tthrow Node.error(`Cannot dereference @${guess}`, scope);\r\n\t\t})(guess, lef, ret, 1);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar leftargs: any = this.leftargs.map(arg => {\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (leftargs.join('').length <= 50) {\r\n\t\t\tleftargs = this.leftargs.map(arg => {\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\tleftargs = leftargs.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\tleftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\t'\\t' + leftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\r\n\t}\r\n}","var grammar;\r\n\r\nif (process.env.__webpack__) {\r\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\r\n} else {\r\n\tvar fs = require('fs');\r\n\tvar path = require('path');\r\n\r\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\r\n}\r\n\r\nvar Program = require('./Program').default;\r\n\r\nmodule.exports = {grammar, Program};","export default \"start =\\r\\n\\t_ lines:(a:line _ {return a})* {return lines}\\r\\n\\r\\nline =\\r\\n\\timport\\r\\n\\t/ typedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defschema\\r\\n\\r\\nevaluable =\\r\\n\\t_ e:evaluable_internal _ {return e}\\r\\n\\r\\nevaluable_internal =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defschema\\r\\n\\t/ metaexpr\\r\\n\\r\\nimport =\\r\\n\\t'import' __\\r\\n\\tfilename:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'import',\\r\\n\\t\\t\\tfilename,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ntypedef =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tbase:(\\\"base\\\" __)?\\r\\n\\t\\\"type\\\" __\\r\\n\\torigin:(o:ftype __ {return o})?\\r\\n\\tname:ident _ sem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'typedef',\\r\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\r\\n\\t\\t\\tbase: !!base,\\r\\n\\t\\t\\torigin,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefv =\\r\\n\\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\r\\n\\t\\t\\ttex: tex ? tex[0] : null,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex ? tex[0] : null,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschemaparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\tguess:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\tguess,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex ? tex[0] : null,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n \\r\\ndefun =\\r\\n\\tdoc:(documentation __)?\\r\\n\\ttex:(tex __)?\\r\\n\\tsealed:('sealed' __)?\\r\\n\\trettype:type __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\texpr:(\\r\\n\\t\\t\\\"{\\\" _\\r\\n\\t\\texpr:expr0 _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return expr}\\r\\n\\t\\t/ sem {return null}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defun',\\r\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\r\\n\\t\\t\\ttex: tex ? tex[0] : null,\\r\\n\\t\\t\\tsealed: !!sealed,\\r\\n\\t\\t\\trettype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschema =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tannotations: (a:annotation __ {return a})*\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defschemaparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"{\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\texpr:metaexpr _\\r\\n\\t\\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\r\\n\\t\\t\\tannotations,\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// var[...]\\r\\n// foo(...)[...]\\r\\n// foo[...][...]\\r\\n// (metaexpr)[...]\\r\\n// schema(?, ...)[...]\\r\\nreduction =\\r\\n\\tsubject:(\\r\\n\\t\\tschemacall\\r\\n\\t\\t/ var\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\tguesses:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:('?' {return null} / expr0) _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)?\\r\\n\\tleftargs:(\\r\\n\\t\\t\\\"[\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:metaexpr _\\r\\n\\t\\t\\ttail:(\\\";\\\" _ e:metaexpr _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\"]\\\"\\r\\n\\t\\tb:(\\r\\n\\t\\t\\t_ '[' _\\r\\n\\t\\t\\t'as' __\\r\\n\\t\\t\\tm:metaexpr\\r\\n\\t\\t\\t']'\\r\\n\\t\\t\\t{return m}\\r\\n\\t\\t)?\\r\\n\\t\\t{return {a: a || [], b: b || null}}\\r\\n\\t)+\\r\\n\\t{\\r\\n\\t\\tvar ret = {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject,\\r\\n\\t\\t\\tguesses,\\r\\n\\t\\t\\tleftargs: leftargs[0].a,\\r\\n\\t\\t\\texpected: leftargs[0].b,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor (var i = 1; i < leftargs.length; i++) {\\r\\n\\t\\t\\tret = {\\r\\n\\t\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\t\\tsubject: ret,\\r\\n\\t\\t\\t\\tguesses: null,\\r\\n\\t\\t\\t\\tleftargs: leftargs[i].a,\\r\\n\\t\\t\\t\\texpected: leftargs[i].b,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n\\r\\n// var(...)\\r\\n// (metaexpr)(...)\\r\\nschemacall =\\r\\n\\tschemaAndUnseal:(\\r\\n\\t\\tschema:var\\r\\n\\t\\tunseal:(_ '+')?\\r\\n\\t\\t{return {schema, unseal: !!unseal}}\\r\\n\\t\\t/ \\\"(\\\" _ schema:metaexpr _ \\\")\\\"\\r\\n\\t\\t{return {schema, unseal: false}}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemacall',\\r\\n\\t\\t\\tschema: schemaAndUnseal.schema,\\r\\n\\t\\t\\tunseal: schemaAndUnseal.unseal,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// forall(f, g)\\r\\n// (expr0)(f, g)\\r\\nfuncall =\\r\\n\\tschemaAndUnseal:(\\r\\n\\t\\tschema:var\\r\\n\\t\\tunseal:(_ '+')?\\r\\n\\t\\t{return {schema, unseal: !!unseal}}\\r\\n\\t\\t/ \\\"(\\\" _ schema:expr0 _ \\\")\\\"\\r\\n\\t\\t{return {schema, unseal: false}}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funcall',\\r\\n\\t\\t\\tschema: schemaAndUnseal.schema,\\r\\n\\t\\t\\tunseal: schemaAndUnseal.unseal,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => expr0\\r\\n// (T t) => { expr0 }\\r\\nfunexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\texpr:(\\r\\n\\t\\texpr0\\r\\n\\t\\t/ \\\"{\\\" _ e:expr0 _ \\\"}\\\" {return e}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => metaexpr_internal_1\\r\\n// (T t) => { $foo = ...; metaexpr }\\r\\nschemaexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\tfoo:(\\r\\n\\t\\texpr:metaexpr_internal_1\\r\\n\\t\\t{return {defdollars: [], expr}}\\r\\n\\t\\t/ \\\"{\\\" _\\r\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\t\\texpr:metaexpr _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return {defdollars, expr}}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemaexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: foo.defdollars,\\r\\n\\t\\t\\texpr: foo.expr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nmetaexpr =\\r\\n\\tleft:(\\r\\n\\t\\tl:(\\r\\n\\t\\t\\thead:metaexpr_internal_1 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_1 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)? {return l || []}\\r\\n\\t)\\r\\n\\t\\\"|-\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\tright:metaexpr\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'tee',\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\tleft,\\r\\n\\t\\t\\tright,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_1\\r\\n\\r\\n/*\\r\\n * 다음이 성립하여야 한다.\\r\\n *\\r\\n * - reduction이 schemacall보다 앞이다.\\r\\n * - schemacall이 var보다 앞이다.\\r\\n *\\r\\n */\\r\\nmetaexpr_internal_1 =\\r\\n\\treduction\\r\\n\\t/ schemacall\\r\\n\\t/ var\\r\\n\\t/ schemaexpr\\r\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\r\\n\\r\\nexpr0 =\\r\\n\\tfuncall\\r\\n\\t/ funexpr\\r\\n\\t/ var\\r\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\r\\n\\r\\ndefdollar =\\r\\n\\tname:dollar_ident _\\r\\n\\t'=' _\\r\\n\\texpr:metaexpr _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'def$',\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\r\\ntype =\\r\\n\\tstype\\r\\n\\t/ ftype\\r\\n\\r\\nstype =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: false,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nftype =\\r\\n\\t\\\"[\\\" _\\r\\n\\tfrom:(\\r\\n\\t\\ttype:type {return [type]}\\r\\n\\t\\t/ (\\r\\n\\t\\t\\ttt:(\\r\\n\\t\\t\\t\\t\\\"(\\\" _\\r\\n\\t\\t\\t\\thead: type\\r\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\r\\n\\t\\t\\t\\t_ \\\")\\\"\\r\\n\\t\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t\\t)\\r\\n\\t\\t\\t{return tt}\\r\\n\\t\\t)\\r\\n\\t) _\\r\\n\\t\\\"->\\\" _\\r\\n\\tto:type _\\r\\n\\t\\\"]\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: true,\\r\\n\\t\\t\\tfrom,\\r\\n\\t\\t\\tto,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nvar =\\r\\n\\tat_var\\r\\n\\t/ dollar_var\\r\\n\\t/ plain_var\\r\\n\\r\\nat_var =\\r\\n\\tname:at_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '@',\\r\\n\\t\\t\\tname: name.slice(1),\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndollar_var =\\r\\n\\tname:dollar_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '$',\\r\\n\\t\\t\\tname: name,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nplain_var =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nkeyword =\\r\\n\\t\\\"as\\\"\\r\\n\\t/ \\\"axiomatic\\\"\\r\\n\\t/ \\\"base\\\"\\r\\n\\t/ \\\"import\\\"\\r\\n\\t/ \\\"schema\\\"\\r\\n\\t/ \\\"sealed\\\"\\r\\n\\t/ \\\"type\\\"\\r\\n\\r\\nannotation =\\r\\n\\t'@discouraged'\\r\\n\\t/ '@deprecated'\\r\\n\\r\\nident =\\r\\n\\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\\r\\n\\r\\nat_ident =\\r\\n\\t$('@' [a-zA-Z0-9_]+)\\r\\n\\r\\ndollar_ident =\\r\\n\\t$('$' [a-zA-Z0-9_]+)\\r\\n\\r\\ndocumentation =\\r\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ntex =\\r\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ncomment =\\r\\n\\t\\\"#\\\" (!newline .)*\\r\\n\\t/ \\\"//\\\" (!newline .)*\\r\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\r\\n\\r\\nnewline =\\r\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\r\\n\\r\\n// optional whitespace\\r\\n_ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\r\\n\\r\\n// mandatory whitespace\\r\\n__ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\r\\n\\r\\nsem =\\r\\n\\t\\\";\\\"\";","import PegInterface from './PegInterface';\r\nimport { EvaluableObject, LineObject } from './PegInterfaceDefinitions';\r\nimport ProofExplorer from './ProofExplorer';\r\nimport Scope from './Scope';\r\n\r\nexport default class Program {\r\n\tpublic scope = new Scope(null);\r\n\tpublic readonly parser;\r\n\tpublic readonly scopeMap: Map<string, Scope> = new Map();\r\n\t\r\n\tconstructor (parser) {\r\n\t\tif (!parser) throw Error('no');\r\n\t\tthis.parser = parser;\r\n\t}\r\n\r\n\tpublic async loadModule(filename, loader): Promise<Scope> {\r\n\t\treturn this.scope = await this.loadModuleInternal(filename, loader);\r\n\t}\r\n\r\n\tprivate async loadModuleInternal(filename, loader): Promise<Scope> {\r\n\t\tif (this.scopeMap.has(filename)) {\r\n\t\t\treturn this.scopeMap.get(filename);\r\n\t\t}\r\n\r\n\t\tvar scope = new Scope(null);\r\n\r\n\t\tvar code = await loader(filename);\r\n\t\tvar parsed = this.parser.parse(code);\r\n\t\tawait this.feed(parsed, scope, loader);\r\n\r\n\t\tthis.scopeMap.set(filename, scope);\r\n\t\treturn scope;\r\n\t}\r\n\r\n\tpublic async feed(lines: LineObject[], scope: Scope=this.scope, loader) {\r\n\t\tfor (var i = 0; i < lines.length; i++) {\r\n\t\t\tvar line = lines[i];\r\n\t\t\t\r\n\t\t\tswitch (line._type) {\r\n\t\t\t\tcase 'import':\r\n\t\t\t\t\tvar scope2 = await this.loadModuleInternal(line.filename, loader);\r\n\t\t\t\t\tscope.importMap.set(line.filename, scope2);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'typedef':\r\n\t\t\t\t\tvar type = PegInterface.type(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasType(type.name)) {\r\n\t\t\t\t\t\tthrow scope.error(`Type ${type.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addType(type);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defv':\r\n\t\t\t\t\tvar variable = PegInterface.variable(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasVariable(variable.name)) {\r\n\t\t\t\t\t\tthrow scope.error(`Definition ${variable.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addVariable(variable);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defun':\r\n\t\t\t\t\tvar fun = PegInterface.fun(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasVariable(fun.name)) {\r\n\t\t\t\t\t\tthrow scope.error(`Definition ${fun.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addFun(fun);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defschema':\r\n\t\t\t\t\tvar schema = PegInterface.schema(line, scope);\r\n\r\n\t\t\t\t\tif (scope.hasSchema(schema.name)) {\r\n\t\t\t\t\t\tthrow scope.error(`Schema ${schema.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.addSchema(schema);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tpublic evaluate(line: EvaluableObject) {\r\n\t\tswitch (line._type) {\r\n\t\t\tcase 'typedef':\r\n\t\t\t\treturn PegInterface.type(line, this.scope);\r\n\t\t\tcase 'defv':\r\n\t\t\t\treturn PegInterface.variable(line, this.scope);\r\n\t\t\tcase 'defun':\r\n\t\t\t\treturn PegInterface.fun(line, this.scope);\r\n\t\t\tcase 'defschema':\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PegInterface.schema(line, this.scope);\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PegInterface.tee(line, this.scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PegInterface.reduction(line, this.scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PegInterface.schemacall(line, this.scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PegInterface.metavar(line, this.scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getProofExplorer(name: string, ktx) {\r\n\t\treturn ProofExplorer.get(this.scope, name, ktx);\r\n\t}\r\n}","/*\r\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\r\n * PEG.js의 출력은 여기에서만 처리해야 한다.\r\n */\r\n\r\nimport $Variable from './nodes/$Variable';\r\nimport Expr0 from './nodes/Expr0';\r\nimport Fun from './nodes/Fun';\r\nimport Funcall from './nodes/Funcall';\r\nimport Metaexpr from './nodes/Metaexpr';\r\nimport ObjectFun from './nodes/ObjectFun';\r\nimport ObjectType from './nodes/ObjectType';\r\nimport Reduction from './nodes/Reduction';\r\nimport Schema from './nodes/Schema';\r\nimport Tee from './nodes/Tee';\r\nimport Variable from './nodes/Variable';\r\nimport { Def$Object, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject } from './PegInterfaceDefinitions';\r\nimport Scope, { NestedTypeInput } from './Scope';\r\n\r\nfunction typeObjToString(obj: TypeObject): string {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) return (obj as StypeObject).name;\r\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\r\n\t\t\t+ typeObjToString(obj.to) + ']';\r\n}\r\n\r\n/*\r\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\r\n * st\t\t\t\t\t\t-> 'st'\r\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\r\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\r\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\r\n */\r\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) {\r\n\t\tobj = obj as StypeObject;\r\n\r\n\t\tif (!obj.name)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.name;\r\n\t} else {\r\n\t\tif (!obj.from || !obj.to)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\r\n\t\t\t[typeObjToNestedArr(obj.to)]\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction varObjToString(obj: VarObject): string {\r\n\tswitch (obj.type) {\r\n\t\tcase '@':\r\n\t\t\treturn `@${obj.name}`;\r\n\t\tcase '$':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tcase 'normal':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\r\n\t}\r\n}\r\n\r\nexport default class PI {\r\n\tpublic static type(obj: TypedefObject, parentScope: Scope): ObjectType {\r\n\t\tif (obj._type != 'typedef')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\r\n\r\n\t\tvar origin: ObjectType = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\r\n\r\n\t\tvar name: string = obj.name;\r\n\t\tvar doc: string = obj.doc;\r\n\t\tvar base: boolean = obj.base;\r\n\r\n\t\tif (base && origin) {\r\n\t\t\tthrow scope.error('Base type should not be an alias');\r\n\t\t}\r\n\r\n\t\tif (origin) {\r\n\t\t\treturn new ObjectType({\r\n\t\t\t\tname,\r\n\t\t\t\tdoc,\r\n\t\t\t\tbase,\r\n\t\t\t\torigin\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn new ObjectType({\r\n\t\t\tfunctional: false,\r\n\t\t\tname,\r\n\t\t\tdoc,\r\n\t\t\tbase\r\n\t\t});\r\n\t}\r\n\r\n\tpublic static variable(obj: DefvObject | VarObject, parentScope: Scope): Variable | Fun {\r\n\t\tif (!['defv', 'var'].includes(obj._type)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('variable', obj.name, obj.location);\r\n\r\n\t\tif (obj._type == 'var') {\r\n\t\t\tif (obj.type != 'normal') {\r\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\r\n\t\t\t}\r\n\r\n\t\t\tif (!scope.hasVariable(obj.name))\r\n\t\t\t\tthrow scope.error(`Undefined identifier ${obj.name}`);\r\n\t\t\treturn scope.getVariable(obj.name);\r\n\t\t}\r\n\r\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\r\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\r\n\r\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\r\n\r\n\t\treturn new Variable({\r\n\t\t\ttype,\r\n\t\t\tisParam: !!obj.isParam,\r\n\t\t\tguess: obj.guess || null,\r\n\t\t\tname: obj.name,\r\n\t\t\tdoc: obj.doc,\r\n\t\t\ttex: obj.tex\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): Fun {\r\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name = null,\r\n\t\t\tdoc = null,\r\n\t\t\ttex = null,\r\n\t\t\tsealed = false;\r\n\r\n\t\tif (obj._type == 'defun') {\r\n\t\t\tobj = obj as DefunObject;\r\n\t\t\tname = obj.name;\r\n\t\t\tdoc = obj.doc;\r\n\t\t\ttex = obj.tex;\r\n\t\t\tsealed = obj.sealed;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('fun', name, obj.location);\r\n\r\n\t\tvar type = null;\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.variable(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnVariable(tv.name))\r\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\r\n\r\n\t\t\treturn scope.addVariable(tv) as Variable;\r\n\t\t});\r\n\t\tvar expr = null;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'defun':\r\n\t\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\r\n\t\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\r\n\r\n\t\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\r\n\r\n\t\t\t\tif (obj.expr) {\r\n\t\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\t\tif (!rettype.equals(expr.type))\r\n\t\t\t\t\t\tthrow scope.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = new ObjectType({\r\n\t\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\t\tfrom: params.map(variable => variable.type),\r\n\t\t\t\t\t\tto: rettype\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\ttype = null;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\tif (!expr && sealed) {\r\n\t\t\tthrow scope.error('Cannot seal a primitive fun');\r\n\t\t}\r\n\r\n\t\treturn new ObjectFun({annotations: [], sealed, type, name, params, expr, doc, tex}, scope);\r\n\t}\r\n\r\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Funcall {\r\n\t\tif (obj._type != 'funcall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar fun = PI.expr0(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(arg => {\r\n\t\t\treturn PI.expr0(arg, scope);\r\n\t\t});\r\n\r\n\t\treturn new Funcall({fun, unseal: obj.unseal, args}, scope);\r\n\t}\r\n\r\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope): Metaexpr {\r\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PI.tee(obj, scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PI.reduction(obj, scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PI.schemacall(obj, scope);\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PI.schema(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.metavar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\r\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\r\n\t\t\tconsole.log(obj);\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'funcall':\r\n\t\t\t\treturn PI.funcall(obj, scope);\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\treturn PI.fun(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.variable(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Metaexpr {\r\n\t\tif (obj._type != 'var')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj.type) {\r\n\t\t\tcase '@':\r\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\r\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\r\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\r\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn scope.hypotheses[hypnum];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow scope.error(`Unknown selector query @${obj.name}`);\r\n\t\t\tcase '$':\r\n\t\t\t\tif (!scope.has$(obj.name)) {\r\n\t\t\t\t\tthrow scope.error(`${obj.name} is not defined`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn scope.get$(obj.name);\r\n\t\t\tcase 'normal':\r\n\t\t\t\tif (!scope.hasSchema(obj.name))\r\n\t\t\t\t\tthrow scope.error(`Schema ${obj.name} is not defined`);\r\n\r\n\t\t\t\treturn scope.getSchema(obj.name);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static tee(obj: TeeObject, parentScope: Scope): Tee {\r\n\t\tif (obj._type != 'tee')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\r\n\r\n\t\tvar left = obj.left.map(o => PI.metaexpr(o, scope));\r\n\r\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\r\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scopeRight);\r\n\r\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scopeRight.add$($v);\r\n\t\t});\r\n\r\n\t\tvar right = PI.metaexpr(obj.right, scopeRight);\r\n\r\n\t\treturn new Tee({left, def$s, right}, scope);\r\n\t}\r\n\r\n\tpublic static def$(obj: Def$Object, parentScope: Scope): $Variable {\r\n\t\tif (obj._type != 'def$')\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t\r\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\r\n\t\t\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new $Variable({name: obj.name, expr}, scope);\r\n\t}\r\n\r\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope): Fun {\r\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name: string = null,\r\n\t\t\taxiomatic: boolean = false,\r\n\t\t\tdoc: string = null,\r\n\t\t\tannotations: string[] = [];\r\n\r\n\t\tif (obj._type == 'defschema') {\r\n\t\t\tname = obj.name; axiomatic = obj.axiomatic;\r\n\t\t\tdoc = obj.doc; annotations = obj.annotations;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\r\n\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.variable(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnVariable(tv.name))\r\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\r\n\t\t\t\r\n\t\t\treturn scope.addVariable(tv) as Variable;\r\n\t\t});\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scope);\r\n\r\n\t\t\tif (scope.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scope.add$($v);\r\n\t\t});\r\n\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new Schema({doc, annotations, axiomatic, name, params, def$s, expr}, scope);\r\n\t}\r\n\r\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope): Funcall {\r\n\t\tif (obj._type != 'schemacall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar fun = PI.metaexpr(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(obj => {\r\n\t\t\treturn PI.expr0(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Funcall({\r\n\t\t\tfun,\r\n\t\t\tunseal: obj.unseal,\r\n\t\t\targs\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope): Reduction {\r\n\t\tif (obj._type != 'reduction')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\r\n\r\n\t\tvar subject = PI.metaexpr(obj.subject, scope);\r\n\r\n\t\tvar guesses = !obj.guesses\r\n\t\t\t? null\r\n\t\t\t: obj.guesses.map(g => {\r\n\t\t\t\treturn g && PI.expr0(g, scope);\r\n\t\t\t});\r\n\r\n\t\tvar leftargs = obj.leftargs.map(obj => {\r\n\t\t\treturn PI.metaexpr(obj, scope);\r\n\t\t});\r\n\r\n\t\tvar expected = obj.expected && PI.metaexpr(obj.expected, scope);\r\n\r\n\t\treturn new Reduction({\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs,\r\n\t\t\texpected\r\n\t\t}, scope);\r\n\t}\r\n}","import $Variable from \"./nodes/$Variable\";\r\nimport Fun from \"./nodes/Fun\";\r\nimport Funcall from \"./nodes/Funcall\";\r\nimport Metaexpr from \"./nodes/Metaexpr\";\r\nimport { isNameable } from \"./nodes/Nameable\";\r\nimport ObjectFun from \"./nodes/ObjectFun\";\r\nimport Reduction from \"./nodes/Reduction\";\r\nimport Schema from \"./nodes/Schema\";\r\nimport Tee from \"./nodes/Tee\";\r\nimport Variable from \"./nodes/Variable\";\r\nimport Scope from \"./Scope\";\r\n\r\nexport default class ProofExplorer {\r\n\tpublic static get(scope: Scope, name: string, ktx) {\r\n\t\tvar DIAMOND = '&#x25C7;',\r\n\t\t\tDOWN = '&#x25BC;',\r\n\t\t\tUP = '&#x25B2;';\r\n\t\t\r\n\t\tif (!scope.hasSchema(name)) {\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t\r\n\t\tvar theexpr = scope.getSchema(name);\r\n\t\r\n\t\tvar ncols = (function recurse(expr: Metaexpr) {\r\n\t\t\tif (expr instanceof Reduction) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.leftargs.map(recurse),\r\n\t\t\t\t\t((expr.subject instanceof Fun && expr.subject.name)\r\n\t\t\t\t\t\t|| (expr.subject instanceof Funcall\r\n\t\t\t\t\t\t\t\t&& isNameable(expr.subject.fun)\r\n\t\t\t\t\t\t\t\t&& expr.subject.fun.name)\r\n\t\t\t\t\t\t\t? 0 : recurse(expr.subject)),\r\n\t\t\t\t\t1\r\n\t\t\t\t);\r\n\t\t\t} else if (expr instanceof Schema) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\r\n\t\t\t\t\trecurse(expr.expr)\r\n\t\t\t\t) + 1;\r\n\t\t\t} else if (expr instanceof ObjectFun) {\r\n\t\t\t\treturn recurse(expr.expr) + 1;\r\n\t\t\t} else if (expr instanceof Tee) {\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\t...expr.left.map(recurse),\r\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\r\n\t\t\t\t\trecurse(expr.right)\r\n\t\t\t\t) + 1;\r\n\t\t\t} else {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t})(theexpr);\r\n\r\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], options?) {\r\n\t\t\tvar padding = left.length;\r\n\r\n\t\t\tvar {bbb=false, rrb=false} = options || {};\r\n\t\r\n\t\t\tvar htmlLeft = left.map((e, i, a) => `<td class=\"${rrb && i == a.length - 1 ? 'rrb' : 'brb'}\">${e.map(f => ktx(f.toTeXStringWithId(true))).join(', ')}</td>`).join('');\r\n\r\n\t\t\tfor (var i = 0; i < left.length; i++)\r\n\t\t\t\twhile(left[i].length) left[i].pop();\r\n\t\r\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\" ' : ''}colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\r\n\t\t}\r\n\r\n\t\tfunction exprToHtml(expr, expand?) {\r\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\r\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\r\n\t\t\tif (expand) return ktx(expr.expandMeta(true).toTeXString(true));\r\n\t\t\t\r\n\t\t\treturn ktx(expr.toTeXString(true));\r\n\t\t}\r\n\r\n\t\tvar ctr = 0;\r\n\r\n\t\tvar tree = (function getTree(\r\n\t\t\t\texpr: Metaexpr,\r\n\t\t\t\thypnumMap: Map<Metaexpr, number>,\r\n\t\t\t\t$Map: Map<Metaexpr, number>) {\r\n\t\t\t\r\n\t\t\tif (hypnumMap.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: hypnumMap.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tif ($Map.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tif (expr instanceof Reduction) {\r\n\t\t\t\tvar leftarglines = [];\r\n\t\t\t\tvar leftargnums = expr.leftargs.map(l => {\r\n\t\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\r\n\t\t\t\t\tif ($Map.has(l)) return $Map.get(l);\r\n\r\n\t\t\t\t\tvar lines = getTree(l, hypnumMap, $Map);\r\n\t\t\t\t\tleftarglines = leftarglines.concat(lines);\r\n\t\t\t\t\treturn lines[lines.length - 1].ctr;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar args = null;\r\n\t\t\t\tvar subjectlines = [];\r\n\t\t\t\tvar subjectnum = hypnumMap.get(expr.subject)\r\n\t\t\t\t\t|| $Map.get(expr.subject)\r\n\t\t\t\t\t|| (expr.subject instanceof Funcall && $Map.has(expr.subject.fun)\r\n\t\t\t\t\t\t? (args = expr.subject.args, $Map.get(expr.subject.fun))\r\n\t\t\t\t\t\t: false)\r\n\t\t\t\t\t|| ((s => s instanceof Fun && s.name\r\n\t\t\t\t\t\t\t|| s instanceof Funcall && isNameable(s.fun) && s.fun.name)(expr.subject)\r\n\t\t\t\t\t\t? expr.subject\r\n\t\t\t\t\t\t: (subjectlines = getTree(expr.subject, hypnumMap, $Map))[subjectlines.length-1].ctr);\r\n\r\n\t\t\t\treturn [\r\n\t\t\t\t\t...leftarglines,\r\n\t\t\t\t\t...subjectlines,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_type: 'E',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tsubject: subjectnum,\r\n\t\t\t\t\t\targs,\r\n\t\t\t\t\t\tleftargs: leftargnums,\r\n\t\t\t\t\t\treduced: expr.reduced\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t} else if (expr instanceof Funcall) {\r\n\t\t\t\tif (hypnumMap.has(expr.fun)) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: hypnumMap.get(expr.fun),\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($Map.has(expr.fun)) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: $Map.get(expr.fun),\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (expr.fun instanceof Schema && expr.fun.name) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RCX',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!(expr.fun instanceof Schema)) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar schemalines = getTree(expr.fun, hypnumMap, $Map);\r\n\r\n\t\t\t\treturn [\r\n\t\t\t\t\t...schemalines,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\r\n\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t} else if (expr instanceof Variable) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof Fun) {\r\n\t\t\t\tif (expr instanceof Schema && expr.name && expr != theexpr) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'RS',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!expr.expr) {\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\tvar start = ctr + 1;\r\n\r\n\t\t\t\tvar $lines = [];\r\n\t\t\t\t\r\n\t\t\t\tif (expr instanceof Schema) {\r\n\t\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'V',\r\n\t\t\t\t\t$lines,\r\n\t\t\t\t\tlines: getTree(expr.expr, hypnumMap, $Map),\r\n\t\t\t\t\t// getHtmlLine 함수가 이 배열을 조작하기 때문에\r\n\t\t\t\t\t// shallow copy 해야 한다.\r\n\t\t\t\t\tparams: expr.params.slice(),\r\n\t\t\t\t\tctr: [start ,ctr]\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof Tee) {\r\n\t\t\t\thypnumMap = new Map(hypnumMap);\r\n\t\t\t\tvar leftlines = [];\r\n\r\n\t\t\t\tvar start = ctr + 1;\r\n\r\n\t\t\t\texpr.left.forEach(l => {\r\n\t\t\t\t\thypnumMap.set(l, ++ctr);\r\n\t\t\t\t\tleftlines.push({\r\n\t\t\t\t\t\t_type: 'H',\r\n\t\t\t\t\t\tctr,\r\n\t\t\t\t\t\texpr: l\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\tvar $lines = [];\r\n\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'T',\r\n\t\t\t\t\tleftlines,\r\n\t\t\t\t\t$lines,\r\n\t\t\t\t\trightlines: getTree(expr.right, hypnumMap, $Map),\r\n\t\t\t\t\tctr: [start, ctr]\r\n\t\t\t\t}];\r\n\t\t\t} else if (expr instanceof $Variable) {\r\n\t\t\t\tif (!$Map.has(expr)) {\r\n\t\t\t\t\tthrow Error(`${expr.name} is not defined`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\texpr: expr.expr\r\n\t\t\t\t}];\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('Unknown metaexpr', expr);\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: '?',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\t\t})(theexpr, new Map(), new Map());\r\n\r\n\t\tvar html = '<table class=\"explorer\">';\r\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\r\n\t\t\r\n\t\thtml += (function tree2html(lines, left) {\r\n\t\t\treturn lines.map(line => {\r\n\t\t\t\tswitch (line._type) {\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([line.params]))\r\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([line.params]));\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\r\n\r\n\t\t\t\t\t\tvar ret = '';\r\n\r\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\r\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\r\n\r\n\t\t\t\t\t\t\tret += getHtmlLine(\r\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', {bbb: true, rrb: true}\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\r\n\t\t\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\t\t\tnewleft,\r\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t\t\t'assumption',\r\n\t\t\t\t\t\t\t\t\t{bbb: i == a.length - 1, rrb: true}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}).join('');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.$lines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.rightlines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\tcase '?':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'???'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tthrow Error('no');\r\n\t\t\t\t\tcase 'R':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RS':\r\n\t\t\t\t\tcase 'RCX':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RC':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\r\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)}${line.args ? ' (' + line.args.map(a => exprToHtml(a)).join(', ') + ')' : ''} [${line.leftargs.map(a => exprToHtml(a)).join(', ')}]`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'NP':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\t`Unknown type ${line._type}`,\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}).join('');\r\n\t\t})(tree[0].$lines.concat(tree[0].lines), []);\r\n\t\t\r\n\t\thtml += '</table>';\r\n\t\r\n\t\treturn html;\r\n\t}\r\n}","import $Variable from './nodes/$Variable';\r\nimport Fun from './nodes/Fun';\r\nimport Metaexpr from './nodes/Metaexpr';\r\nimport ObjectType from './nodes/ObjectType';\r\nimport Variable from './nodes/Variable';\r\nimport StackTrace from './StackTrace';\r\n\r\nexport type NestedTypeInput = string | NestedTypeInput[];\r\n\r\nexport default class Scope {\r\n\tpublic readonly importMap: Map<string, Scope> = new Map();\r\n\r\n\tpublic readonly typedefMap: Map<string, ObjectType> = new Map();\r\n\tpublic readonly defMap: Map<string, Variable | Fun> = new Map();\r\n\tpublic readonly schemaMap: Map<string, Fun> = new Map();\r\n\tpublic readonly $Map: Map<string, $Variable> = new Map();\r\n\tpublic readonly hypotheses: Metaexpr[] = [];\r\n\r\n\tpublic readonly parent: Scope;\r\n\tpublic readonly root: Scope;\r\n\r\n\tpublic readonly trace: StackTrace;\r\n\tpublic baseType: ObjectType;\r\n\r\n\tconstructor (parent: Scope, trace?: StackTrace) {\r\n\t\tthis.parent = parent;\r\n\t\tthis.root = parent ? parent.root : this;\r\n\r\n\t\tif (trace && !(trace instanceof StackTrace)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.trace = trace || new StackTrace();\r\n\r\n\t\tthis.baseType = parent ? parent.baseType : null;\r\n\t}\r\n\r\n\tpublic extend(type, name, location): Scope {\r\n\t\tvar child = new Scope(this, this.trace.extend(type, name, location));\r\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\r\n\t\treturn child;\r\n\t}\r\n\r\n\tpublic error(message: string): Error {\r\n\t\treturn this.trace.error(message);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.typedefMap.has(name)\r\n\t\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasOwnType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.hasOwnType(name)\r\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\tpublic addType(type: ObjectType): ObjectType {\r\n\t\tif (!(type instanceof ObjectType))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!type.name)\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\r\n\t\tif (this.hasOwnType(type.name))\r\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\r\n\r\n\t\tif (type.isBaseType) {\r\n\t\t\tif (this.baseType) {\r\n\t\t\t\tthrow this.error('A base type already exists');\r\n\t\t\t}\r\n\r\n\t\t\t(function broadcast(scope: Scope) {\r\n\t\t\t\tscope.baseType = type;\r\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\r\n\t\t\t})(this);\r\n\t\t}\r\n\r\n\t\tthis.typedefMap.set(type.name, type);\r\n\t\treturn type;\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic getType(name: NestedTypeInput): ObjectType {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\tif (!this.hasType(name))\r\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\r\n\r\n\t\t\treturn this.typedefMap.has(name)\r\n\t\t\t\t? this.typedefMap.get(name)\r\n\t\t\t\t: (!!this.parent && this.parent.getType(name))\r\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\t\treturn s.hasType(name)\r\n\t\t\t\t\t})[0].getType(name);\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\r\n\t\t\treturn this.getType(e);\r\n\t\t});\r\n\r\n\t\tvar to = this.getType(name[name.length - 1]);\r\n\r\n\t\treturn new ObjectType({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom,\r\n\t\t\tto\r\n\t\t});\r\n\t}\r\n\r\n\tpublic hasOwnVariable(name: string): boolean {\r\n\t\treturn this.defMap.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnVariable(name));\r\n\t}\r\n\r\n\tpublic hasVariable(name: string): boolean {\r\n\t\treturn this.hasOwnVariable(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasVariable(name));\r\n\t}\r\n\r\n\tpublic addVariable(variable: Variable | Fun): Variable | Fun {\r\n\t\tif (!(variable instanceof Variable))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnVariable(variable.name))\r\n\t\t\tthrow this.error(`Definition ${variable.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(variable.name, variable);\r\n\t\treturn variable;\r\n\t}\r\n\r\n\tpublic addFun(fun: Fun): Fun {\r\n\t\tif (!(fun instanceof Fun))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!fun.name)\r\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\r\n\r\n\t\tif (this.hasOwnVariable(fun.name))\r\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(fun.name, fun);\r\n\t\treturn fun;\r\n\t}\r\n\r\n\tpublic getVariable(name: string): Variable | Fun {\r\n\t\tif (!this.hasVariable(name))\r\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\r\n\r\n\t\treturn this.defMap.has(name)\r\n\t\t\t? this.defMap.get(name)\r\n\t\t\t: (!!this.parent && this.parent.getVariable(name))\r\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\treturn s.hasVariable(name)\r\n\t\t\t\t})[0].getVariable(name);\r\n\t}\r\n\r\n\tpublic hasOwnSchema(name: string): boolean {\r\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnSchema(name));\r\n\t}\r\n\r\n\tpublic hasSchema(name: string): boolean {\r\n\t\treturn this.hasOwnSchema(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\r\n\t}\r\n\r\n\tpublic addSchema(schema: Fun): Fun {\r\n\t\tif (!(schema instanceof Fun))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnSchema(schema.name))\r\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\r\n\r\n\t\tthis.schemaMap.set(schema.name, schema);\r\n\t\treturn schema;\r\n\t}\r\n\r\n\tpublic getSchema(name: string): Variable | Fun {\r\n\t\tif (!this.hasSchema(name))\r\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\r\n\r\n\t\treturn this.schemaMap.has(name)\r\n\t\t\t? this.schemaMap.get(name)\r\n\t\t\t: this.defMap.has(name)\r\n\t\t\t\t? this.defMap.get(name)\r\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name))\r\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\t\treturn s.hasSchema(name)\r\n\t\t\t\t\t})[0].getSchema(name);\r\n\t}\r\n\r\n\tpublic hasOwn$(name: string): boolean {\r\n\t\treturn this.$Map.has(name)\r\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwn$(name));\r\n\t}\r\n\r\n\tpublic has$(name: string): boolean {\r\n\t\treturn this.hasOwn$(name)\r\n\t\t\t|| (!!this.parent && this.parent.has$(name));\r\n\t}\r\n\r\n\tpublic add$($: $Variable): $Variable {\r\n\t\tif (!($ instanceof $Variable))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwn$($.name))\r\n\t\t\tthrow this.error(`$ variable ${$.name} has already been declared`);\r\n\r\n\t\tthis.$Map.set($.name, $);\r\n\t\treturn $;\r\n\t}\r\n\r\n\tpublic get$(name: string): $Variable {\r\n\t\tif (!this.has$(name))\r\n\t\t\tthrow this.error(`$ variable ${name} is not defined`);\r\n\r\n\t\treturn this.$Map.has(name)\r\n\t\t\t? this.$Map.get(name)\r\n\t\t\t: (!!this.parent && this.parent.get$(name))\r\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\r\n\t\t\t\t\treturn s.has$(name)\r\n\t\t\t\t})[0].get$(name);\r\n\t}\r\n}","export default class StackTrace {\r\n\tpublic readonly stack: any[];\r\n\r\n\tconstructor (stack?: any[]) {\r\n\t\tthis.stack = stack || [];\r\n\t}\r\n\r\n\tpublic extend(type, name, location): StackTrace {\r\n\t\treturn new StackTrace([[type, name, location]].concat(this.stack));\r\n\t}\r\n\r\n\tpublic error(message: string) {\r\n\t\tvar filename = typeof process != 'undefined' && process.argv[2];\r\n\r\n\t\treturn new Error(\r\n\t\t\tmessage\r\n\t\t\t+ '\\n\\tat '\r\n\t\t\t+ (\r\n\t\t\t\tthis.stack.length\r\n\t\t\t\t\t? this.stack.map(([type, name, location]) => {\r\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${filename || '<unknown>'}:${location.start.line}:${location.start.column})`;\r\n\t\t\t\t\t}).join('\\n\\tat ')\r\n\t\t\t\t\t: `<root> (${filename || '<unknown>'}:1:1)`\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}