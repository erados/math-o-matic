{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/nodes/Metaexpr.ts","webpack://math/./src/nodes/ObjectType.ts","webpack://math/./src/nodes/Fun.ts","webpack://math/./src/nodes/$Variable.ts","webpack://math/./src/nodes/Variable.ts","webpack://math/./src/nodes/Funcall.ts","webpack://math/./src/nodes/ObjectFun.ts","webpack://math/./src/nodes/Expr0.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/Schema.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Nameable.ts","webpack://math/./src/nodes/Reduction.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/PegInterface.ts","webpack://math/./src/ExecutionContext.ts","webpack://math/./src/ProofExplorer.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","trace","doc","tex","_id","toIndentedString","message","error","Error","replace","precedence","code","match","g1","hyps","length","prec","Array","console","log","my","normalizePrecedence","your","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","EqualsPriority","Metaexpr","type","super","andFuncalls","expandMetaCache","expandMetaInternal","obj","context","equals","getEqualsPriority","equalsInternal","ObjectType","origin","isFunctional","isBaseType","base","functional","from","map","f","some","e","to","resolved","resolve","toSimpleString","join","indent","isSimple","toTeXString","Fun","annotations","sealed","params","expr","parsed","parseTeX","variable","isProved","ONE","placeholders","types","push","isParam","thisCall","fun","objCall","Map","set","substitute","$Variable","expandMeta","FOUR","escapeTeX","Variable","guess","ZERO","Funcall","isNameable","resolvedType","paramTypes","argTypes","arg","callee","isExpandable","isCallable","expandOnce","THREE","thisIsExpandable","objIsExpandable","every","_","repeat","funcallToTeXString","ObjectFun","has","uses","makeTeX","Expr0","MetaType","left","right","Schema","axiomatic","def$s","isProvedCache","cache","_context","toTeXStringWithId","Tee","$","concat","lef","TWO","expanded","Type","Reduction","subject","guesses","leftargs","as","forEach","derefs","tee","query","leftargTypes","leftargsExpanded","reduced","parameter","argument","Number","recurse","ptr","test","grammar","default","Program","parser","scopeMap","filename","loader","scope","loadModuleInternal","fileUri","parse","feed","lines","line","_type","scope2","importMap","hasType","addType","hasVariable","addVariable","addFun","schema","hasSchema","addSchema","reduction","schemacall","metavar","ktx","typeObjToString","ftype","typeObjToNestedArr","varObjToString","PI","parentScope","extend","location","getType","includes","getVariable","tvo","tv","hasOwnVariable","rettype","expr0","funcall","hypnum","slice","hypotheses","has$","get$","getSchema","metaexpr","scopeRight","$v","def$","hasOwn$","add$","oldContext","using","g","ExecutionContext","usingList","ProofExplorer","DIAMOND","theexpr","ncols","Math","max","getHtmlLine","h1","h2","options","padding","bbb","rrb","htmlLeft","a","pop","exprToHtml","expand","tree","getTree","hypnumMap","$Map","num","leftarglines","leftargnums","subjectlines","subjectnum","schemalines","start","$lines","$num","leftlines","rightlines","html","tree2html","newleft","fill","Scope","parent","typedefMap","defMap","schemaMap","baseType","child","h","values","hasOwnType","broadcast","filter","hasOwnSchema","StackTrace","stack","element","column"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","import StackTrace from '../StackTrace';\n\nvar ctr = 0;\n\nexport type Precedence = boolean | number | [number, number];\n\nexport default abstract class Node {\n\tpublic readonly _id: number;\n\n\tpublic readonly trace: StackTrace;\n\tpublic readonly doc: string;\n\tpublic readonly tex: string;\n\tpublic precedence: Precedence;\n\n\tpublic static readonly PREC_FUNEXPR = 1000;\n\tpublic static readonly PREC_COMMA = 1000;\n\tpublic static readonly PREC_COLONEQQ = 100000;\n\n\tconstructor (trace: StackTrace, doc: string, tex: string) {\n\t\tthis._id = ++ctr;\n\t\tthis.trace = trace;\n\t\tthis.doc = doc;\n\t\tthis.tex = tex;\n\t}\n\n\tpublic toString() {\n\t\treturn this.toIndentedString(0);\n\t}\n\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\n\n\tpublic error(message: string) {\n\t\treturn Node.error(message, this.trace);\n\t}\n\n\tpublic static error(message: string, trace: StackTrace) {\n\t\tif (trace) {\n\t\t\treturn trace.error(message);\n\t\t} else {\n\t\t\treturn new Error(message);\n\t\t}\n\t}\n\n\tpublic static escapeTeX(s) {\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\n\t\t\t'}': '\\\\}',\n\t\t\t'~': '\\\\textasciitilde',\n\t\t\t'^': '\\\\textasciicircum',\n\t\t\t'\\\\': '\\\\textbackslash'\n\t\t})[m]);\n\t}\n\n\tpublic static parseTeX(tex) {\n\t\tvar precedence: Precedence = false;\n\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\n\t\t\tprecedence = g1 * 1;\n\t\t\treturn '';\n\t\t});\n\n\t\treturn {precedence, code};\n\t}\n\n\tpublic isProved(hyps?): boolean {\n\t\thyps = hyps || [];\n\n\t\tfor (var i = 0; i < hyps.length; i++) {\n\t\t\tif (hyps[i] == this) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t* false corresponds to 0.\n\t* true corresponds to w * 2.\n\t*/\n\tpublic static normalizePrecedence(prec: Precedence) {\n\t\tif (prec === false) return [0, 0];\n\t\tif (prec === true) return [2, 0];\n\t\tif (typeof prec == 'number') return [0, prec];\n\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\n\t\t\tconsole.log(prec);\n\t\t\tthrow Error('wut');\n\t\t}\n\n\t\treturn prec;\n\t}\n\n\tpublic shouldConsolidate(prec: Precedence) {\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\n\t\t\tyour = Node.normalizePrecedence(prec || false);\n\n\t\tif (my[0] == 0 && my[1] == 0) return false;\n\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\n\t}\n\n\tpublic makeTeX(id, args, prec) {\n\t\targs = args || [];\n\t\tprec = prec || false;\n\t\t\n\t\tvar ret = this.tex;\n\n\t\tif (this.shouldConsolidate(prec)) {\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\n\t\t}\n\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\n\t\t});\n\t}\n}","import ExecutionContext from \"../ExecutionContext\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Node from \"./Node\";\nimport Type from \"./Type\";\nimport Variable from \"./Variable\";\n\n/**\n * 숫자가 큰 것이 우선순위가 높다.\n */\nexport enum EqualsPriority {\n\t/** Variable */\n\tZERO,\n\t/** Fun */\n\tONE,\n\t/** Tee */\n\tTWO,\n\t/** Funcall */\n\tTHREE,\n\t/** $Variable, Reduction */\n\tFOUR\n}\n\nexport default abstract class Metaexpr extends Node {\n\t\n\tpublic readonly type: Type;\n\tprivate expandMetaCache: Metaexpr;\n\n\tconstructor(trace: StackTrace, doc: string, tex: string, type: Type) {\n\t\tsuper(trace, doc, tex);\n\n\t\tif (!type) throw Node.error('Assertion failed', trace);\n\n\t\tthis.type = type;\n\t}\n\n\tpublic abstract substitute(map: Map<Variable, Expr0>): Metaexpr;\n\n\t/**\n\t * \n\t * @param andFuncalls 이름 없는 Funcall도 푼다.\n\t */\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\n\t\tif (this.expandMetaCache) return this.expandMetaCache;\n\t\treturn this.expandMetaCache = this.expandMetaInternal(andFuncalls);\n\t}\n\n\tpublic abstract expandMetaInternal(andFuncalls: boolean): Metaexpr;\n\n\tpublic equals(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\tif (this === obj) return true;\n\t\tif (!this.type.equals(obj.type)) return false;\n\n\t\tif (obj.getEqualsPriority() > this.getEqualsPriority())\n\t\t\treturn obj.equalsInternal(this, context);\n\t\t\n\t\treturn this.equalsInternal(obj, context);\n\t}\n\n\tprotected abstract getEqualsPriority(): EqualsPriority;\n\n\tprotected abstract equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean;\n}","import Nameable from './Nameable';\nimport Node from './Node';\nimport Type from './Type';\n\nexport default class ObjectType extends Type implements Nameable {\n\n\tpublic readonly isBaseType: boolean;\n\tpublic readonly name: string;\n\tpublic readonly origin: ObjectType;\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: ObjectType;\n\n\tconstructor (o) {\n\t\tif (o.origin) {\n\t\t\tsuper(null, o.doc, null, o.origin.isFunctional);\n\n\t\t\tthis.isBaseType = !!o.base;\n\n\t\t\tif (typeof o.name != 'string')\n\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\n\t\t\tthis.name = o.name;\n\n\t\t\tif (!(o.origin instanceof ObjectType))\n\t\t\t\tthrow Node.error('!(o.origin instanceof ObjectType)', null);\n\n\t\t\tthis.origin = o.origin;\n\t\t} else {\n\t\t\tsuper(null, o.doc, null, o.functional);\n\n\t\t\tthis.isBaseType = !!o.base;\n\n\t\t\tif (typeof o.functional != 'boolean')\n\t\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\n\n\t\t\tif (!o.functional) {\n\t\t\t\tif (typeof o.name != 'string')\n\t\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\n\t\t\t\tthis.name = o.name;\n\t\t\t} else {\n\t\t\t\tif (o.from.map(f => f instanceof ObjectType).some(e => !e))\n\t\t\t\t\tthrow Node.error('o.from.map(f => f instanceof ObjectType).some(e => !e)', null);\n\t\t\t\tif (!(o.to instanceof ObjectType))\n\t\t\t\t\tthrow Node.error('!(o.to instanceof ObjectType)', null);\n\n\t\t\t\tthis.from = o.from;\n\t\t\t\tthis.to = o.to;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toSimpleString() {\n\t\tif (this.name) return this.name;\n\n\t\tvar resolved = this.resolve();\n\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\n\t}\n\n\tpublic toIndentedString(indent): string {\n\t\tif (this.isSimple) return this.name;\n\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\n\t}\n\n\tpublic toTeXString(root?: boolean) {\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\n\n\t\tif (!root && this.name) {\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\n\t\t}\n\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\n\t}\n\n\tpublic resolve(): ObjectType {\n\t\treturn this.origin ? this.origin.resolve() : this;\n\t}\n\n\tpublic equals(t: Type): boolean {\n\t\tif (!(t instanceof ObjectType)) return false;\n\n\t\tif (this.origin) return this.origin.equals(t);\n\t\tif (t.origin) return this.equals(t.origin);\n\n\t\tif (this.isSimple != t.isSimple) return false;\n\n\t\tif (this.isSimple) return this === t;\n\n\t\tif (this.from.length != t.from.length) return false;\n\n\t\tfor (var i = 0; i < this.from.length; i++)\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\n\n\t\treturn this.to.equals(t.to);\n\t}\n}","import Expr0 from './Expr0';\nimport Nameable from './Nameable';\n\nexport default abstract class Fun extends Expr0 implements Nameable {\n\n\tpublic readonly annotations: string[];\n\tpublic readonly sealed: boolean;\n\tpublic readonly name: string;\n\tpublic readonly params: Variable[];\n\tpublic readonly expr: Metaexpr;\n\n\t/*\n\t * name, expr 중 하나 이상 있어야 하고 type, expr 중\n\t * 한 개만 있어야 한다.\n\t */\n\tconstructor ({doc, tex, annotations, sealed, type, name, params, expr}: FunArgumentType, trace: StackTrace) {\n\t\tif (!name && !expr)\n\t\t\tthrow Node.error('Anonymous fun cannot be primitive', trace);\n\n\t\tif (type && expr)\n\t\t\tthrow Node.error('no', trace);\n\n\t\tif (!type && !expr)\n\t\t\tthrow Node.error('Cannot guess the type of a primitive fun', trace);\n\t\t\n\t\tvar precedence = false;\n\n\t\tif (tex) {\n\t\t\tvar parsed = Node.parseTeX(tex);\n\t\t\tprecedence = parsed.precedence;\n\t\t\ttex = parsed.code;\n\t\t} else {\n\t\t\ttex = null;\n\t\t}\n\t\t\n\t\tsuper(\n\t\t\ttrace, doc, tex,\n\t\t\ttype || new (expr.type instanceof ObjectType ? ObjectType : MetaType)({\n\t\t\t\tfunctional: true,\n\t\t\t\tfrom: params.map(variable => variable.type),\n\t\t\t\tto: expr.type as any\n\t\t\t})\n\t\t);\n\n\t\tthis.annotations = annotations;\n\t\tthis.sealed = sealed;\n\t\tthis.precedence = precedence;\n\t\tthis.name = name;\n\t\tthis.params = params;\n\t\tthis.expr = expr;\n\t}\n\n\tpublic isProved(hyps?) {\n\t\thyps = hyps || [];\n\t\t\n\t\treturn super.isProved(hyps)\n\t\t\t|| this.expr && this.expr.isProved(hyps);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.ONE;\n\t}\n\t\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\tif (!(this.expr && !this.sealed)\n\t\t\t\t&& !(obj instanceof Fun && obj.expr && !obj.sealed)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar placeholders = [];\n\t\tvar types = (this.type.resolve() as ObjectType | MetaType).from;\n\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tplaceholders.push(new Variable({\n\t\t\t\tisParam: true,\n\t\t\t\ttype: types[i],\n\t\t\t\tname: '$' + i\n\t\t\t}, this.trace));\n\t\t}\n\n\t\tvar thisCall = this.expr && !this.sealed\n\t\t\t? this.call(placeholders)\n\t\t\t: new Funcall({\n\t\t\t\tfun: this,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\n\t\tvar objCall = obj instanceof Fun && obj.expr && !obj.sealed\n\t\t\t? obj.call(placeholders)\n\t\t\t: new Funcall({\n\t\t\t\tfun: obj,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\t\t\n\t\treturn thisCall.equals(objCall, context);\n\t}\n\n\tpublic abstract isCallable(context: ExecutionContext): boolean;\n\n\tpublic call(args: Expr0[]): Metaexpr {\n\t\tif (!this.expr) {\n\t\t\tthrow Error('Cannot call a primitive fun');\n\t\t}\n\n\t\tif (this.params.length != args.length) {\n\t\t\tthrow Error('Illegal arguments length');\n\t\t}\n\n\t\tvar map: Map<Variable, Expr0> = new Map();\n\n\t\tfor (var i = 0; i < this.params.length; i++) {\n\t\t\tmap.set(this.params[i], args[i]);\n\t\t}\n\n\t\treturn this.expr.substitute(map);\n\t}\n}\n\nimport Funcall from './Funcall';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport Node from './Node';\nimport ObjectType from './ObjectType';\nimport Type from './Type';\nimport Variable from './Variable';\nimport StackTrace from '../StackTrace';\nimport ExecutionContext from '../ExecutionContext';\n\ninterface FunArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\tannotations: string[];\n\tsealed: boolean;\n\ttype?: Type;\n\tname?: string;\n\tparams: Variable[];\n\texpr?: Metaexpr;\n}","import ExecutionContext from \"../ExecutionContext\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Metaexpr, { EqualsPriority } from \"./Metaexpr\";\nimport Nameable from \"./Nameable\";\nimport Node, { Precedence } from \"./Node\";\nimport Variable from \"./Variable\";\n\ninterface $VariableArgumentType {\n\tname: string;\n\texpr: Metaexpr;\n}\n\nexport default class $Variable extends Metaexpr implements Nameable {\n\n\tpublic readonly name: string;\n\tpublic readonly expr: Metaexpr;\n\n\tconstructor ({name, expr}: $VariableArgumentType, trace: StackTrace) {\n\t\tsuper(trace, null, null, expr.type);\n\n\t\tif (!name || !expr) {\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tpublic isProved(hyps?): boolean {\n\t\thyps = hyps || [];\n\t\t\n\t\treturn super.isProved(hyps)\n\t\t\t|| this.expr.isProved(hyps);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn this.expr.substitute(map);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this.expr.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FOUR;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\treturn this.expr.equals(obj, context);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn this.name;\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `\\\\mathtt{${Node.escapeTeX(this.name)}}`;\n\t}\n}","import ExecutionContext from '../ExecutionContext';\nimport StackTrace from '../StackTrace';\nimport Expr0 from './Expr0';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport Nameable from './Nameable';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\n\ninterface VariableArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\ttype: ObjectType;\n\tname: string;\n\tisParam: boolean;\n\tguess?: string;\n}\n\nexport default class Variable extends Expr0 implements Nameable {\n\t\n\tpublic readonly isParam: boolean;\n\tpublic readonly guess: string;\n\tpublic readonly type: ObjectType;\n\tpublic readonly name: string;\n\n\tconstructor ({doc, tex, type, name, isParam, guess}: VariableArgumentType, trace: StackTrace) {\n\t\tsuper(trace, doc, tex, type);\n\n\t\tthis.isParam = !!isParam;\n\t\tthis.guess = guess || null;\n\n\t\tif (typeof name != 'string')\n\t\t\tthrow Node.error('Assertion failed', trace);\n\n\t\tthis.name = name;\n\t}\n\n\tpublic isProved(hyps) {\n\t\thyps = hyps || [];\n\t\n\t\treturn super.isProved(hyps);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn map.get(this) || this;\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this;\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.ZERO;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\treturn false;\n\t}\n\n\t// pr f\n\tpublic toSimpleString() {\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\n\n\t\tvar tex = this.tex\n\t\t\t|| (\n\t\t\t\tthis.name.length == 1\n\t\t\t\t\t? Node.escapeTeX(this.name)\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.name)}}`\n\t\t\t);\n\t\t\n\t\treturn `\\\\href{#${id}}{${tex}}`;\n\t}\n\n\tpublic toTeXStringWithId(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.isParam) throw Error('wut');\n\n\t\tvar id =`id-${this._id}`;\n\n\t\treturn [\n\t\t\t`\\\\htmlId{${id}}{`,\n\t\t\tthis.toTeXString(prec, root),\n\t\t\t`}`\n\t\t].join('');\n\t}\n}","import ExecutionContext from '../ExecutionContext';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport { isNameable } from './Nameable';\nimport Node, { Precedence } from './Node';\nimport ObjectFun from './ObjectFun';\nimport ObjectType from './ObjectType';\nimport Schema from './Schema';\nimport Variable from './Variable';\n\ninterface FuncallArgumentType {\n\tfun: Metaexpr;\n\targs: Expr0[];\n}\n\nexport default class Funcall extends Expr0 {\n\t\n\tpublic readonly fun: Metaexpr;\n\tpublic readonly args: Expr0[];\n\n\tconstructor ({fun, args}: FuncallArgumentType, trace: StackTrace) {\n\t\tif (fun.type.isSimple) {\n\t\t\tvar name = isNameable(fun) ? fun.name : '<anonymous>';\n\t\t\tthrow Node.error(`${name} is not callable`, trace);\n\t\t}\n\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t\t \n\t\tvar resolvedType = fun.type.resolve() as ObjectType | MetaType,\n\t\t\tparamTypes = resolvedType.from,\n\t\t\targTypes = args.map(e => e.type);\n\n\t\tif (paramTypes.length != argTypes.length)\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\n\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t}\n\t\t}\n\n\t\tsuper(trace, null, null, resolvedType.to);\n\t\t\n\t\tthis.fun = fun;\n\t\tthis.args = args;\n\t}\n\n\tpublic isProved(hyps?) {\n\t\thyps = hyps || [];\n\t\n\t\treturn super.isProved(hyps) || this.fun.isProved(hyps);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn new Funcall({\n\t\t\tfun: this.fun.substitute(map),\n\t\t\targs: this.args.map(arg => arg.substitute(map))\n\t\t}, this.trace);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tvar fun = this.fun.expandMeta(andFuncalls),\n\t\t\targs = this.args.map(arg => arg.expandMeta(andFuncalls));\n\t\t\n\t\tif (!(fun instanceof Fun) || !fun.expr || fun.name && !(fun instanceof Schema))\n\t\t\treturn new Funcall({fun, args}, this.trace);\n\n\t\treturn fun.call(args).expandMeta(andFuncalls);\n\t}\n\n\tpublic isExpandable(context: ExecutionContext): boolean {\n\t\tvar callee: Metaexpr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\treturn callee.isExpandable(context);\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) return false;\n\n\t\treturn callee.isCallable(context);\n\t}\n\t\n\tpublic expandOnce(context: ExecutionContext): Metaexpr {\n\t\tif (!this.isExpandable(context)) {\n\t\t\tthrow Error('Cannot expand');\n\t\t}\n\n\t\tvar callee: Metaexpr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\treturn new Funcall({\n\t\t\t\tfun: callee.expandOnce(context),\n\t\t\t\targs: this.args\n\t\t\t}, this.trace);\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\treturn callee.call(this.args);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.THREE;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\tif (!(obj instanceof Funcall)) {\n\t\t\tif (!this.isExpandable(context)) return false;\n\n\t\t\treturn this.expandOnce(context).equals(obj, context);\n\t\t}\n\n\t\tif (this.fun.equals(obj.fun, context)) {\n\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\tif (!this.args[i].equals(obj.args[i], context)) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.fun instanceof Funcall && this.fun.isExpandable(context)) {\n\t\t\treturn this.expandOnce(context).equals(obj, context);\n\t\t}\n\n\t\tif (obj.fun instanceof Funcall && obj.fun.isExpandable(context)) {\n\t\t\treturn this.equals(obj.expandOnce(context), context);\n\t\t}\n\n\t\tvar thisIsExpandable = this.isExpandable(context),\n\t\t\tobjIsExpandable = obj.isExpandable(context);\n\t\t\n\t\tif (this.fun == obj.fun || !thisIsExpandable && !objIsExpandable) {\n\t\t\tif (this.fun != obj.fun) return false;\n\n\t\t\tif (!thisIsExpandable && !objIsExpandable) {\n\t\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\t\tif (!this.args[i].equals(obj.args[i], context)) return false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (this.args.every((_, i) => {\n\t\t\t\treturn this.args[i].equals(obj.args[i], context);\n\t\t\t})) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (thisIsExpandable) {\n\t\t\treturn this.expandOnce(context).equals(obj, context);\n\t\t}\n\n\t\treturn this.equals(obj.expandOnce(context), context);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar args: any = this.args.map(arg => {\n\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (args.join('').length <= 50) {\n\t\t\targs = this.args.map(arg => {\n\t\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\targs = args.join(', ');\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn `${this.fun.name || `(${this.fun})`}(${args})`;\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t!(this.fun instanceof Fun) || !this.fun.name\n\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t: this.fun.name,\n\t\t\t\t\t`(${args})`\n\t\t\t\t].join('');\n\t\t\t}\n\t\t} else {\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn [\n\t\t\t\t\tthis.fun.name || `(${this.fun.toIndentedString(indent)})`,\n\t\t\t\t\t'(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t(\n\t\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\n\t\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t\t: this.fun.name\n\t\t\t\t\t) + '(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (this.fun instanceof Schema) {\n\t\t\treturn (\n\t\t\t\tthis.fun.name\n\t\t\t\t\t? `\\\\href{#schema-${this.fun.isProved() ? 'p' : 'np'}-${this.fun.name}}{\\\\textsf{${Node.escapeTeX(this.fun.name)}}}`\n\t\t\t\t\t: this.fun.toTeXString(false)\n\t\t\t) + `\\\\mathord{\\\\left(${this.args.map(arg => {\n\t\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\n\t\t\t}).join(', ')}\\\\right)}`;\n\t\t}\n\n\t\tif (this.fun instanceof ObjectFun)\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\n\t\t\n\t\tvar args = this.args.map(arg => {\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\n\t\t});\n\n\t\treturn (\n\t\t\t!(isNameable(this.fun) && this.fun.name) || this.fun instanceof Variable\n\t\t\t\t? this.fun.toTeXString(false)\n\t\t\t\t: this.fun.name.length == 1\n\t\t\t\t\t? Node.escapeTeX(this.fun.name)\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.fun.name)}}`\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}","import ExecutionContext from \"../ExecutionContext\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Metaexpr from \"./Metaexpr\";\nimport Node, { Precedence } from \"./Node\";\nimport ObjectType from \"./ObjectType\";\nimport Type from \"./Type\";\nimport Variable from \"./Variable\";\n\ninterface ObjectFunArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\tannotations: string[];\n\tsealed: boolean;\n\ttype?: Type;\n\tname?: string;\n\tparams: Variable[];\n\texpr?: Expr0;\n}\n\nexport default class ObjectFun extends Fun {\n\t\n\tconstructor ({doc, tex, annotations, sealed, type, name, params, expr}: ObjectFunArgumentType, trace: StackTrace) {\n\t\tsuper({doc, tex, annotations, sealed, type, name, params, expr}, trace);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (!this.expr) return this;\n\n\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\n\t\tif (this.name) return this;\n\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new ObjectFun({\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new ObjectFun({\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(context: ExecutionContext): boolean {\n\t\treturn this.expr && (!this.sealed || context.uses(this));\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (this.name) return this.name;\n\t\t\n\t\treturn [\n\t\t\t`ƒ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\n\t\tif (!root)\n\t\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${Node.escapeTeX(this.name)}}`;\n\t\n\t\tif (!this.expr)\n\t\t\treturn this.funcallToTeXString(this.params, prec);\n\t\n\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\n\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\n\t}\n\n\tpublic funcallToTeXString(args, prec) {\n\t\targs = args.map(arg => {\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\n\t\t});\n\t\n\t\tif (this.tex) {\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\n\t\t}\n\t\n\t\treturn (\n\t\t\t!this.name\n\t\t\t\t? this.toTeXString(false)\n\t\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? Node.escapeTeX(this.name) : `\\\\mathrm{${Node.escapeTeX(this.name)}}`}}`\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}","import Metaexpr from \"./Metaexpr\";\n\nexport default abstract class Expr0 extends Metaexpr {\n\t\n}","import Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Type from './Type';\n\ninterface SimpleMetaTypeArgumentType {\n\tfunctional: false;\n\tleft: Type[];\n\tright: Type;\n}\n\ninterface FunctionalMetaTypeArgumentType {\n\tfunctional: true;\n\tfrom: ObjectType[];\n\tto: MetaType;\n}\n\ntype MetaTypeArgumentType = SimpleMetaTypeArgumentType | FunctionalMetaTypeArgumentType;\n\nexport default class MetaType extends Type {\n\t\n\tpublic readonly left: Type[];\n\tpublic readonly right: Type;\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: MetaType;\n\n\tconstructor (o: MetaTypeArgumentType) {\n\t\tsuper(null, null, null, o.functional);\n\n\t\tif (typeof o.functional != 'boolean')\n\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\n\n\t\tif (o.functional == false) {\n\t\t\tif (!(o.left instanceof Array))\n\t\t\t\tthrow Node.error('left should be an array', null);\n\n\t\t\tthis.left = o.left;\n\t\t\tthis.right = o.right;\n\t\t} else {\n\t\t\tif (o.from.some(f => !(f instanceof ObjectType)))\n\t\t\t\tthrow Node.error('o.from.some(f => !(f instanceof ObjectType))', null);\n\t\t\tif (!(o.to instanceof MetaType))\n\t\t\t\tthrow Node.error('!(o.to instanceof MetaType)', null);\n\n\t\t\tif (o.to.isFunctional)\n\t\t\t\tthrow Node.error('Functional metatype in functional metatype is not supported', null);\n\n\t\t\tthis.from = o.from;\n\t\t\tthis.to = o.to;\n\t\t}\n\t}\n\n\tpublic resolve(): MetaType {\n\t\treturn this;\n\t}\n\n\tpublic toIndentedString(indent: number) {\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\n\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tpublic equals(t: Type): boolean {\n\t\tif (!(t instanceof MetaType)) return false;\n\n\t\tif (this.isSimple != t.isSimple) return false;\n\n\t\tif (this.isSimple) {\n\t\t\tif (this.left.length != t.left.length) return false;\n\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\n\t\t\t}\n\n\t\t\tif (!this.right.equals(t.right)) return false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.from.length != t.from.length) return false;\n\n\t\tfor (let i = 0; i < this.from.length; i++)\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\n\n\t\treturn this.to.equals(t.to);\n\t}\n}","import Fun from \"./Fun\";\n\nexport default class Schema extends Fun {\n\n\tpublic readonly axiomatic: boolean;\n\tpublic readonly using: ObjectFun[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly context: ExecutionContext;\n\tprivate isProvedCache: boolean;\n\n\tconstructor ({doc, tex, annotations, axiomatic, name, params, context, def$s, expr}: SchemaArgumentType, trace: StackTrace) {\n\t\tif (!expr) {\n\t\t\tthrow Node.error('wut', trace);\n\t\t}\n\n\t\tsuper({doc, tex, annotations, sealed: false, type: null, name, params, expr}, trace);\n\t\t\n\t\tthis.axiomatic = axiomatic;\n\t\tthis.def$s = def$s || [];\n\t\tthis.context = context;\n\t}\n\t\n\tpublic isProved(hyps?) {\n\t\tif (this.isProvedCache) return true;\n\n\t\tif (!hyps && typeof this.isProvedCache == 'boolean') {\n\t\t\treturn this.isProvedCache;\n\t\t}\n\n\t\tvar cache = !hyps;\n\t\thyps = hyps || [];\n\t\t\n\t\tvar ret = this.axiomatic || super.isProved(hyps);\n\t\tif (cache) this.isProvedCache = ret;\n\t\treturn ret;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (!this.expr) return this;\n\n\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\n\t\tif (this.name) return this;\n\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new Schema({\n\t\t\tannotations: this.annotations,\n\t\t\taxiomatic: this.axiomatic,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new Schema({\n\t\t\tannotations: this.annotations,\n\t\t\taxiomatic: this.axiomatic,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(_context: ExecutionContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn [\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.expandMeta(true).toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\t\t\n\t\tvar id = `schema-${this.isProved() ? 'p' : 'np'}-${this.name}`;\n\t\n\t\tif (!root)\n\t\t\treturn `\\\\href{#${id}}\\\\mathsf{${Node.escapeTeX(this.name)}}`;\n\t\n\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}\\\\mathord{\\\\left(${this.params.map(e => e.toTeXStringWithId(Node.PREC_COMMA) + (e.guess ? `: \\\\texttt{@${e.guess}}` : '')).join(', ')}\\\\right)}:\\\\\\\\\\\\quad`\n\t\t\t\t+ this.expr.expandMeta(true).toTeXString(true);\n\t}\n}\n\nimport $Variable from \"./$Variable\";\nimport Expr0 from \"./Expr0\";\nimport Metaexpr from \"./Metaexpr\";\nimport Node, { Precedence } from \"./Node\";\nimport ObjectType from \"./ObjectType\";\nimport Variable from \"./Variable\";\nimport ObjectFun from \"./ObjectFun\";\nimport StackTrace from \"../StackTrace\";\nimport ExecutionContext from \"../ExecutionContext\";\n\ninterface SchemaArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\tannotations: string[];\n\taxiomatic: boolean;\n\tname?: string;\n\tparams: Variable[];\n\tcontext: ExecutionContext;\n\tdef$s: $Variable[];\n\texpr: Metaexpr;\n}","import ExecutionContext from '../ExecutionContext';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Expr0 from './Expr0';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Variable from './Variable';\n\ninterface TeeArgumentType {\n\tleft: Metaexpr[];\n\tdef$s?: $Variable[];\n\tright: Metaexpr;\n}\n\nexport default class Tee extends Metaexpr {\n\n\tpublic readonly left: Metaexpr[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly right: Metaexpr;\n\n\tconstructor ({left, def$s, right}: TeeArgumentType, trace: StackTrace) {\n\t\tif (!(left instanceof Array\n\t\t\t\t&& left.every(l => {\n\t\t\t\t\treturn l.type instanceof ObjectType\n\t\t\t\t\t\t|| l.type instanceof MetaType;\n\t\t\t\t}))) {\n\t\t\tconsole.log(left);\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $ instanceof $Variable)))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\n\t\tif (!(right.type instanceof ObjectType || right.type instanceof MetaType)) {\n\t\t\tconsole.log(right);\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tif (right.type.isFunctional) {\n\t\t\tthrow Node.error('RHS of a rule cannot be a schema', trace);\n\t\t}\n\n\t\tsuper(trace, null, null, new MetaType({\n\t\t\tfunctional: false,\n\t\t\tleft: left.map(e => e.type),\n\t\t\tright: right.type\n\t\t}));\n\n\t\tthis.left = left;\n\t\tthis.def$s = def$s || [];\n\t\tthis.right = right;\n\t\tthis.precedence = Node.PREC_COMMA;\n\t}\n\n\tpublic isProved(hyps?) {\n\t\thyps = hyps || [];\n\t\n\t\treturn super.isProved(hyps) || this.right.isProved(hyps.concat(this.left));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tvar left = this.left.map(e => e.substitute(map));\n\t\tvar right = this.right.substitute(map);\n\n\t\treturn new Tee({\n\t\t\tleft, right\n\t\t}, this.trace);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tvar left = this.left.map(lef => lef.expandMeta(andFuncalls));\n\t\tvar right = this.right.expandMeta(andFuncalls);\n\n\t\treturn new Tee({left, right}, this.trace);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.TWO;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\tif (!(obj instanceof Tee)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tif (this.left.length != obj.left.length) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tfor (var i = 0; i < this.left.length; i++) {\n\t\t\tif (!this.left[i].equals(obj.left[i], context)) return false;\n\t\t}\n\n\t\treturn this.right.equals(obj.right, context);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (!this.left.length) {\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\n\t\t}\n\t\n\t\treturn [\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\n\t\t\t'|-',\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar expanded = this.expandMeta(true) as Tee;\n\n\t\treturn [\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t].join('');\n\t}\n}","import StackTrace from \"../StackTrace\";\nimport Node from \"./Node\";\n\nexport default abstract class Type extends Node {\n\tpublic readonly isFunctional: boolean;\n\tpublic readonly isSimple: boolean;\n\t\n\tpublic abstract equals(t: Type): boolean;\n\n\tconstructor (trace: StackTrace, doc: string, tex: string, isFunctional: boolean) {\n\t\tsuper(trace, doc, tex);\n\t\tthis.isFunctional = isFunctional;\n\t\tthis.isSimple = !isFunctional;\n\t}\n\n\tpublic abstract resolve(): Type;\n}","export default interface Nameable {\n\tname: string;\n}\n\nexport function isNameable(obj: object): obj is Nameable {\n\treturn 'name' in obj;\n}","import ExecutionContext from '../ExecutionContext';\nimport StackTrace from '../StackTrace';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Funcall from './Funcall';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Tee from './Tee';\nimport Variable from './Variable';\n\ninterface ReductionArgumentType {\n\tsubject: Metaexpr;\n\tguesses: Expr0[];\n\tleftargs: Metaexpr[];\n\tas: Metaexpr;\n}\n\nexport default class Reduction extends Metaexpr {\n\t\n\tpublic readonly subject: Metaexpr;\n\tpublic readonly guesses: Expr0[];\n\tpublic readonly leftargs: Metaexpr[];\n\tpublic readonly reduced: Metaexpr;\n\n\tconstructor ({subject, guesses, leftargs, as}: ReductionArgumentType, context: ExecutionContext, trace: StackTrace) {\n\t\tif (guesses) {\n\t\t\tlet resolvedType = subject.type.resolve() as ObjectType | MetaType,\n\t\t\t\tparamTypes = resolvedType.from,\n\t\t\t\targTypes = guesses.map(e => e && e.type);\n\n\t\t\tif (paramTypes.length != argTypes.length)\n\t\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\t\tif (argTypes[i] && !paramTypes[i].equals(argTypes[i])) {\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (subject instanceof Fun) {\n\t\t\tsubject.params.forEach((p, i) => {\n\t\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} could not be guessed`, trace);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar derefs = subject.params.map((p, i) => {\n\t\t\t\tif (guesses && guesses[i]) return guesses[i];\n\n\t\t\t\tvar tee = (subject as Fun).expr.expandMeta(false) as Tee;\n\t\n\t\t\t\treturn Reduction.query(\n\t\t\t\t\tp.guess,\n\t\t\t\t\ttee.left, leftargs,\n\t\t\t\t\ttee.right, as,\n\t\t\t\t\tcontext, trace\n\t\t\t\t);\n\t\t\t});\n\t\n\t\t\tsubject = new Funcall({\n\t\t\t\tfun: subject,\n\t\t\t\targs: derefs,\n\t\t\t}, trace);\n\t\t} else if (guesses) {\n\t\t\tthrow Node.error('Something\\'s wrong', trace);\n\t\t}\n\t\n\t\tif (!(subject.type instanceof MetaType && subject.type.isSimple))\n\t\t\tthrow Node.error('Subject is not reducible', trace);\n\t\n\t\tif (!(leftargs instanceof Array)\n\t\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\n\t\tvar paramTypes = subject.type.left,\n\t\t\tleftargTypes = leftargs.map(e => e.type);\n\n\t\tif (paramTypes.length != leftargTypes.length)\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`, trace);\n\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\n\t\t\t\tthrow Node.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`, trace);\n\t\t}\n\n\t\tsuper(trace, null, null, subject.type.right);\n\n\t\tthis.subject = subject;\n\t\tthis.leftargs = leftargs;\n\n\t\tvar tee = subject.expandMeta(true);\n\n\t\tif (!(tee instanceof Tee)) {\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tvar leftargsExpanded = leftargs.map(arg => {\n\t\t\treturn arg.expandMeta(true);\n\t\t});\n\n\t\tfor (let i = 0; i < tee.left.length; i++) {\n\t\t\tif (!tee.left[i].equals(leftargsExpanded[i], context)) {\n\t\t\t\tthrow Node.error(`LHS #${i + 1} failed to match:\n\n--- EXPECTED ---\n${tee.left[i].expandMeta(true)}\n----------------\n\n--- RECEIVED ---\n${leftargs[i].expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\t\t}\n\n\t\tif (as) {\n\t\t\tif (!tee.right.equals(as, context)) {\n\t\t\t\tthrow Node.error(`RHS failed to match:\n\n--- EXPECTED ---\n${tee.right.expandMeta(true)}\n----------------\n\n--- RECEIVED (from [as ...]) ---\n${as.expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\n\t\t\tthis.reduced = as;\n\t\t} else {\n\t\t\tthis.reduced = tee.right;\n\t\t}\n\t}\n\n\tpublic isProved(hyps?): boolean {\n\t\thyps = hyps || [];\n\t\t\n\t\treturn super.isProved(hyps)\n\t\t\t|| this.subject.isProved(hyps)\n\t\t\t\t&& this.leftargs.every(l => l.isProved(hyps));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn this.reduced.substitute(map);\n\t}\n\n\tpublic expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this.reduced.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FOUR;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): boolean {\n\t\treturn this.reduced.equals(obj, context);\n\t}\n\n\tpublic static query(\n\t\t\tguess: string,\n\t\t\tleft: Metaexpr[], leftargs: Metaexpr[],\n\t\t\tright: Metaexpr, as: Metaexpr,\n\t\t\tcontext: ExecutionContext, trace: StackTrace) {\n\t\tif (guess.length == 0) throw Node.error('wut', trace);\n\n\t\tvar parameter: Metaexpr, argument: Metaexpr;\n\n\t\tif (guess[0] == 'r') {\n\t\t\tif (!as) {\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: expected output is not given`, trace);\n\t\t\t}\n\n\t\t\tparameter = right;\n\t\t\targument = as;\n\t\t} else {\n\t\t\tvar n = Number(guess[0]);\n\n\t\t\tif (!(1 <= n && n <= leftargs.length))\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent index out of range`, trace);\n\n\t\t\tparameter = left[n - 1];\n\t\t\targument = leftargs[n - 1];\n\t\t}\n\n\t\treturn (function recurse(\n\t\t\t\tguess: string, ptr: number,\n\t\t\t\tparameter: Metaexpr, argument: Metaexpr) {\n\t\t\targument = argument.expandMeta(true);\n\t\t\t\n\t\t\tif (guess.length <= ptr) return argument;\n\n\t\t\tif (/[0-9]/.test(guess[ptr])) {\n\t\t\t\tvar n = Number(guess[ptr]);\n\n\t\t\t\tif (parameter instanceof Tee && argument instanceof Tee) {\n\t\t\t\t\tif (parameter.left.length != argument.left.length) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent length mismatch`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(1 <= n && n <= argument.left.length)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}: antecedent index out of range`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn recurse(guess, ptr + 1, parameter.left[n - 1], argument.left[n - 1]);\n\t\t\t\t}\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(parameter instanceof Funcall) || !(argument instanceof Funcall)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameter.fun.equals(argument.fun, context)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!argument.isExpandable(context)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\targument = argument.expandOnce(context);\n\t\t\t\t}\n\n\t\t\t\tif (!argument.args || !(1 <= n && n <= argument.args.length))\n\t\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, trace);\n\n\t\t\t\treturn recurse(guess, ptr + 1, parameter.args[n - 1], argument.args[n - 1]);\n\t\t\t} else if (guess[ptr] == 'r') {\n\t\t\t\tif (parameter instanceof Tee && argument instanceof Tee) {\n\t\t\t\t\treturn recurse(guess, ptr + 1, parameter.right, argument.right);\n\t\t\t\t}\n\n\t\t\t\tthrow Node.error(`Cannot dereference @${guess}`, trace);\n\t\t\t}\n\n\t\t\tthrow Node.error(`Cannot dereference @${guess}`, trace);\n\t\t})(guess, 1, parameter, argument);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar leftargs: any = this.leftargs.map(arg => {\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (leftargs.join('').length <= 50) {\n\t\t\tleftargs = this.leftargs.map(arg => {\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\tleftargs = leftargs.join(', ');\n\t\n\t\t\treturn [\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t\tleftargs,\n\t\t\t\t']'\n\t\t\t].join('');\n\t\t}\n\t\telse {\n\t\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\n\t\n\t\t\treturn [\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t\t'\\t' + leftargs,\n\t\t\t\t']'\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t}\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\n\t}\n}","var grammar;\n\nif (process.env.__webpack__) {\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\n} else {\n\tvar fs = require('fs');\n\tvar path = require('path');\n\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\n}\n\nvar Program = require('./Program').default;\n\nmodule.exports = {grammar, Program};","export default \"start =\\n\\t_ lines:(a:line _ {return a})* {return lines}\\n\\nline =\\n\\timport\\n\\t/ typedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\nevaluable =\\n\\t_ e:evaluable_internal _ {return e}\\n\\nevaluable_internal =\\n\\ttypedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\t/ metaexpr\\n\\nimport =\\n\\t'import' __\\n\\tfilename:ident _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'import',\\n\\t\\t\\tfilename,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ntypedef =\\n\\tdoc:(documentation __)?\\n\\tbase:(\\\"base\\\" __)?\\n\\t\\\"type\\\" __\\n\\torigin:(o:ftype __ {return o})?\\n\\tname:ident _ sem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'typedef',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\tbase: !!base,\\n\\t\\t\\torigin,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefv =\\n\\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: false,\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschemaparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\tguess:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tguess,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n \\ndefun =\\n\\tdoc:(documentation __)?\\n\\ttex:(tex __)?\\n\\tsealed:('sealed' __)?\\n\\trettype:type __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\texpr:(\\n\\t\\t\\\"{\\\" _\\n\\t\\texpr:expr0 _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return expr}\\n\\t\\t/ sem {return null}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defun',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\tsealed: !!sealed,\\n\\t\\t\\trettype,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschema =\\n\\tdoc:(documentation __)?\\n\\tannotations: (a:annotation __ {return a})*\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\n\\t\\\"schema\\\" __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defschemaparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\tusing:(\\n\\t\\t'using' __\\n\\t\\tx:(\\n\\t\\t\\thead:ident _\\n\\t\\t\\ttail:(',' _ n:ident _ {return n})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)\\n\\t\\t{return x}\\n\\t)?\\n\\t\\\"{\\\" _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\texpr:metaexpr _\\n\\t\\\"}\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defschema',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\tannotations,\\n\\t\\t\\taxiomatic: !!axiomatic,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\tusing: using || [],\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// var[...]\\n// foo(...)[...]\\n// foo[...][...]\\n// (metaexpr)[...]\\n// schema(?, ...)[...]\\nreduction =\\n\\tsubject:(\\n\\t\\tschemacall\\n\\t\\t/ var\\n\\t\\t/ \\\"(\\\" _\\n\\t\\te:metaexpr _\\n\\t\\t\\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\tguesses:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:('?' {return null} / expr0) _\\n\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)?\\n\\tleftargs:(\\n\\t\\t\\\"[\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:metaexpr _\\n\\t\\t\\ttail:(\\\";\\\" _ e:metaexpr _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\"]\\\"\\n\\t\\tb:(\\n\\t\\t\\t_ '[' _\\n\\t\\t\\t'as' __\\n\\t\\t\\tm:metaexpr\\n\\t\\t\\t']'\\n\\t\\t\\t{return m}\\n\\t\\t)?\\n\\t\\t{return {a: a || [], b: b || null}}\\n\\t)+\\n\\t{\\n\\t\\tvar ret = {\\n\\t\\t\\t_type: 'reduction',\\n\\t\\t\\tsubject,\\n\\t\\t\\tguesses,\\n\\t\\t\\tleftargs: leftargs[0].a,\\n\\t\\t\\tas: leftargs[0].b,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\n\\t\\tfor (var i = 1; i < leftargs.length; i++) {\\n\\t\\t\\tret = {\\n\\t\\t\\t\\t_type: 'reduction',\\n\\t\\t\\t\\tsubject: ret,\\n\\t\\t\\t\\tguesses: null,\\n\\t\\t\\t\\tleftargs: leftargs[i].a,\\n\\t\\t\\t\\tas: leftargs[i].b,\\n\\t\\t\\t\\tlocation: location()\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t}\\n\\n// var(...)\\n// (metaexpr)(...)\\nschemacall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemacall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// forall(f, g)\\n// (expr0)(f, g)\\nfuncall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _\\n\\t\\te:expr0 _\\n\\t\\t\\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funcall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => expr0\\n// (T t) => { expr0 }\\nfunexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\texpr:(\\n\\t\\texpr0\\n\\t\\t/ \\\"{\\\" _ e:expr0 _ \\\"}\\\" {return e}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => metaexpr_internal_1\\n// (T t) => { $foo = ...; metaexpr }\\nschemaexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\tfoo:(\\n\\t\\texpr:metaexpr_internal_1\\n\\t\\t{return {defdollars: [], expr}}\\n\\t\\t/ \\\"{\\\" _\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\n\\t\\texpr:metaexpr _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return {defdollars, expr}}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemaexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\tdef$s: foo.defdollars,\\n\\t\\t\\texpr: foo.expr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nmetaexpr =\\n\\tleft:(\\n\\t\\tl:(\\n\\t\\t\\thead:metaexpr_internal_1 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_1 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)? {return l || []}\\n\\t)\\n\\t\\\"|-\\\" _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\tright:metaexpr\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'tee',\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\tleft,\\n\\t\\t\\tright,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\t/ metaexpr_internal_1\\n\\n/*\\n * 다음이 성립하여야 한다.\\n *\\n * - reduction이 schemacall보다 앞이다.\\n * - schemacall이 var보다 앞이다.\\n *\\n */\\nmetaexpr_internal_1 =\\n\\treduction\\n\\t/ schemacall\\n\\t/ var\\n\\t/ schemaexpr\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\n\\nexpr0 =\\n\\tfuncall\\n\\t/ funexpr\\n\\t/ var\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\n\\ndefdollar =\\n\\tname:dollar_ident _\\n\\t'=' _\\n\\texpr:metaexpr _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'def$',\\n\\t\\t\\tname,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\t}\\n\\ntype =\\n\\tstype\\n\\t/ ftype\\n\\nstype =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: false,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nftype =\\n\\t\\\"[\\\" _\\n\\tfrom:(\\n\\t\\ttype:type {return [type]}\\n\\t\\t/ (\\n\\t\\t\\ttt:(\\n\\t\\t\\t\\t\\\"(\\\" _\\n\\t\\t\\t\\thead: type\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\n\\t\\t\\t\\t_ \\\")\\\"\\n\\t\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t\\t)\\n\\t\\t\\t{return tt}\\n\\t\\t)\\n\\t) _\\n\\t\\\"->\\\" _\\n\\tto:type _\\n\\t\\\"]\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: true,\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nvar =\\n\\tat_var\\n\\t/ dollar_var\\n\\t/ plain_var\\n\\nat_var =\\n\\tname:at_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '@',\\n\\t\\t\\tname: name.slice(1),\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndollar_var =\\n\\tname:dollar_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '$',\\n\\t\\t\\tname: name,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nplain_var =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: 'normal',\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nkeyword =\\n\\t'as'\\n\\t/ 'axiomatic'\\n\\t/ 'base'\\n\\t/ 'import'\\n\\t/ 'schema'\\n\\t/ 'sealed'\\n\\t/ 'type'\\n\\t/ 'using'\\n\\nannotation =\\n\\t'@discouraged'\\n\\t/ '@deprecated'\\n\\nident =\\n\\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\\n\\nat_ident =\\n\\t$('@' [a-zA-Z0-9_]+)\\n\\ndollar_ident =\\n\\t$('$' [a-zA-Z0-9_]+)\\n\\ndocumentation =\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\n\\t\\treturn b\\n\\t}\\n\\ntex =\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\n\\t\\treturn b\\n\\t}\\n\\ncomment =\\n\\t\\\"#\\\" (!newline .)*\\n\\t/ \\\"//\\\" (!newline .)*\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\n\\nnewline =\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\n\\n// optional whitespace\\n_ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\n\\n// mandatory whitespace\\n__ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\n\\nsem =\\n\\t\\\";\\\"\";","import PegInterface from './PegInterface';\nimport { EvaluableObject, LineObject } from './PegInterfaceDefinitions';\nimport ProofExplorer from './ProofExplorer';\nimport Scope from './Scope';\n\ninterface LoaderReturnType {\n\tfileUri?: string;\n\tcode: string;\n}\n\ntype LoaderType = (packageName: string) => (LoaderReturnType | Promise<LoaderReturnType>);\n\nexport default class Program {\n\tpublic scope: Scope;\n\tpublic readonly parser;\n\tpublic readonly scopeMap: Map<string, Scope> = new Map();\n\t\n\tconstructor (parser) {\n\t\tif (!parser) throw Error('no');\n\t\tthis.parser = parser;\n\t}\n\n\tpublic async loadModule(filename: string, loader: LoaderType): Promise<Scope> {\n\t\treturn this.scope = await this.loadModuleInternal(filename, loader);\n\t}\n\n\tprivate async loadModuleInternal(filename: string, loader: LoaderType): Promise<Scope> {\n\t\tif (this.scopeMap.has(filename)) {\n\t\t\treturn this.scopeMap.get(filename);\n\t\t}\n\n\t\tvar {fileUri, code} = await loader(filename);\n\n\t\tvar scope = new Scope(fileUri, null);\n\t\tvar parsed = this.parser.parse(code);\n\n\t\tawait this.feed(parsed, scope, loader);\n\n\t\tthis.scopeMap.set(filename, scope);\n\t\treturn scope;\n\t}\n\n\tpublic async feed(lines: LineObject[], scope: Scope=this.scope, loader) {\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tswitch (line._type) {\n\t\t\t\tcase 'import':\n\t\t\t\t\tvar scope2 = await this.loadModuleInternal(line.filename, loader);\n\t\t\t\t\tscope.importMap.set(line.filename, scope2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'typedef':\n\t\t\t\t\tvar type = PegInterface.type(line, scope);\n\n\t\t\t\t\tif (scope.hasType(type.name)) {\n\t\t\t\t\t\tthrow scope.error(`Type ${type.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addType(type);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defv':\n\t\t\t\t\tvar variable = PegInterface.variable(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(variable.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${variable.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addVariable(variable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defun':\n\t\t\t\t\tvar fun = PegInterface.fun(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(fun.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${fun.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addFun(fun);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defschema':\n\t\t\t\t\tvar schema = PegInterface.schema(line, scope, null);\n\n\t\t\t\t\tif (scope.hasSchema(schema.name)) {\n\t\t\t\t\t\tthrow scope.error(`Schema ${schema.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addSchema(schema);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic evaluate(line: EvaluableObject) {\n\t\tvar scope = new Scope('<repl>', this.scope);\n\n\t\tswitch (line._type) {\n\t\t\tcase 'typedef':\n\t\t\t\treturn PegInterface.type(line, scope);\n\t\t\tcase 'defv':\n\t\t\t\treturn PegInterface.variable(line, scope);\n\t\t\tcase 'defun':\n\t\t\t\treturn PegInterface.fun(line, scope);\n\t\t\tcase 'defschema':\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PegInterface.schema(line, scope, null);\n\t\t\tcase 'tee':\n\t\t\t\treturn PegInterface.tee(line, scope, null);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PegInterface.reduction(line, scope, null);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PegInterface.schemacall(line, scope, null);\n\t\t\tcase 'var':\n\t\t\t\treturn PegInterface.metavar(line, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t}\n\t}\n\n\tpublic getProofExplorer(name: string, ktx) {\n\t\treturn ProofExplorer.get(this.scope, name, ktx);\n\t}\n}","/*\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\n * PEG.js의 출력은 여기에서만 처리해야 한다.\n */\n\nimport ExecutionContext from './ExecutionContext';\nimport $Variable from './nodes/$Variable';\nimport Expr0 from './nodes/Expr0';\nimport Fun from './nodes/Fun';\nimport Funcall from './nodes/Funcall';\nimport Metaexpr from './nodes/Metaexpr';\nimport ObjectFun from './nodes/ObjectFun';\nimport ObjectType from './nodes/ObjectType';\nimport Reduction from './nodes/Reduction';\nimport Schema from './nodes/Schema';\nimport Tee from './nodes/Tee';\nimport Variable from './nodes/Variable';\nimport { Def$Object, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject } from './PegInterfaceDefinitions';\nimport Scope, { NestedTypeInput } from './Scope';\n\nfunction typeObjToString(obj: TypeObject): string {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) return (obj as StypeObject).name;\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\n\t\t\t+ typeObjToString(obj.to) + ']';\n}\n\n/*\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\n * st\t\t\t\t\t\t-> 'st'\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\n */\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) {\n\t\tobj = obj as StypeObject;\n\n\t\tif (!obj.name)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.name;\n\t} else {\n\t\tif (!obj.from || !obj.to)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\n\t\t\t[typeObjToNestedArr(obj.to)]\n\t\t);\n\t}\n}\n\nfunction varObjToString(obj: VarObject): string {\n\tswitch (obj.type) {\n\t\tcase '@':\n\t\t\treturn `@${obj.name}`;\n\t\tcase '$':\n\t\t\treturn `${obj.name}`;\n\t\tcase 'normal':\n\t\t\treturn `${obj.name}`;\n\t\tdefault:\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\n\t}\n}\n\nexport default class PI {\n\tpublic static type(obj: TypedefObject, parentScope: Scope): ObjectType {\n\t\tif (obj._type != 'typedef')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\n\n\t\tvar origin: ObjectType = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\n\n\t\tvar name: string = obj.name;\n\t\tvar doc: string = obj.doc;\n\t\tvar base: boolean = obj.base;\n\n\t\tif (base && origin) {\n\t\t\tthrow scope.error('Base type should not be an alias');\n\t\t}\n\n\t\tif (origin) {\n\t\t\treturn new ObjectType({\n\t\t\t\tname,\n\t\t\t\tdoc,\n\t\t\t\tbase,\n\t\t\t\torigin\n\t\t\t});\n\t\t}\n\n\t\treturn new ObjectType({\n\t\t\tfunctional: false,\n\t\t\tname,\n\t\t\tdoc,\n\t\t\tbase\n\t\t});\n\t}\n\n\tpublic static variable(obj: DefvObject | VarObject, parentScope: Scope): Variable | Fun {\n\t\tif (!['defv', 'var'].includes(obj._type)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tvar scope = parentScope.extend('variable', obj.name, obj.location);\n\n\t\tif (obj._type == 'var') {\n\t\t\tif (obj.type != 'normal') {\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\n\t\t\t}\n\n\t\t\tif (!scope.hasVariable(obj.name))\n\t\t\t\tthrow scope.error(`Undefined identifier ${varObjToString(obj)}`);\n\t\t\treturn scope.getVariable(obj.name);\n\t\t}\n\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\n\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\n\n\t\treturn new Variable({\n\t\t\ttype,\n\t\t\tisParam: !!obj.isParam,\n\t\t\tguess: obj.guess || null,\n\t\t\tname: obj.name,\n\t\t\tdoc: obj.doc,\n\t\t\ttex: obj.tex\n\t\t}, scope.trace);\n\t}\n\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): ObjectFun {\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar name = null,\n\t\t\tdoc = null,\n\t\t\ttex = null,\n\t\t\tsealed = false;\n\n\t\tif (obj._type == 'defun') {\n\t\t\tobj = obj as DefunObject;\n\t\t\tname = obj.name;\n\t\t\tdoc = obj.doc;\n\t\t\ttex = obj.tex;\n\t\t\tsealed = obj.sealed;\n\t\t}\n\n\t\tvar scope = parentScope.extend('fun', name, obj.location);\n\n\t\tvar type = null;\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\n\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\n\t\t\treturn scope.addVariable(tv) as Variable;\n\t\t});\n\t\tvar expr = null;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'defun':\n\t\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\n\t\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\n\n\t\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\n\n\t\t\t\tif (obj.expr) {\n\t\t\t\t\texpr = PI.expr0(obj.expr, scope);\n\t\t\t\t\tif (!rettype.equals(expr.type))\n\t\t\t\t\t\tthrow scope.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\n\t\t\t\t} else {\n\t\t\t\t\ttype = new ObjectType({\n\t\t\t\t\t\tfunctional: true,\n\t\t\t\t\t\tfrom: params.map(variable => variable.type),\n\t\t\t\t\t\tto: rettype\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'funexpr':\n\t\t\t\texpr = PI.expr0(obj.expr, scope);\n\t\t\t\ttype = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\n\t\tif (!expr && sealed) {\n\t\t\tthrow scope.error('Cannot seal a primitive fun');\n\t\t}\n\n\t\treturn new ObjectFun({annotations: [], sealed, type, name, params, expr, doc, tex}, scope.trace);\n\t}\n\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Funcall {\n\t\tif (obj._type != 'funcall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.expr0(obj.schema, scope);\n\n\t\tvar args = obj.args.map(arg => {\n\t\t\treturn PI.expr0(arg, scope);\n\t\t});\n\n\t\treturn new Funcall({fun, args}, scope.trace);\n\t}\n\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope, context: ExecutionContext): Metaexpr {\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\n\t\t\tthrow Error('Assertion failed');\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'tee':\n\t\t\t\treturn PI.tee(obj, scope, context);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PI.reduction(obj, scope, context);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PI.schemacall(obj, scope, context);\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PI.schema(obj, scope, context);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.metavar(obj, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\n\t\t\tconsole.log(obj);\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'funcall':\n\t\t\t\treturn PI.funcall(obj, scope);\n\t\t\tcase 'funexpr':\n\t\t\t\treturn PI.fun(obj, scope);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.variable(obj, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Metaexpr {\n\t\tif (obj._type != 'var')\n\t\t\tthrow Error('Assertion failed');\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj.type) {\n\t\t\tcase '@':\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn scope.hypotheses[hypnum];\n\t\t\t\t}\n\n\t\t\t\tthrow scope.error(`Unknown selector query ${varObjToString(obj)}`);\n\t\t\tcase '$':\n\t\t\t\tif (!scope.has$(obj.name)) {\n\t\t\t\t\tthrow scope.error(`${varObjToString(obj)} is not defined`);\n\t\t\t\t}\n\n\t\t\t\treturn scope.get$(obj.name);\n\t\t\tcase 'normal':\n\t\t\t\tif (!scope.hasSchema(obj.name))\n\t\t\t\t\tthrow scope.error(`Schema ${varObjToString(obj)} is not defined`);\n\n\t\t\t\treturn scope.getSchema(obj.name);\n\t\t\tdefault:\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\n\t\t}\n\t}\n\n\tpublic static tee(obj: TeeObject, parentScope: Scope, context: ExecutionContext): Tee {\n\t\tif (obj._type != 'tee')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\n\n\t\tvar left = obj.left.map(o => PI.metaexpr(o, scope, context));\n\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scopeRight, context);\n\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scopeRight.add$($v);\n\t\t});\n\n\t\tvar right = PI.metaexpr(obj.right, scopeRight, context);\n\n\t\treturn new Tee({left, def$s, right}, scope.trace);\n\t}\n\n\tpublic static def$(obj: Def$Object, parentScope: Scope, context: ExecutionContext): $Variable {\n\t\tif (obj._type != 'def$')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\n\t\t\n\t\tvar expr = PI.metaexpr(obj.expr, scope, context);\n\n\t\treturn new $Variable({name: obj.name, expr}, scope.trace);\n\t}\n\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope, oldContext: ExecutionContext): Schema {\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar name = obj._type == 'defschema' ? obj.name : null;\n\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\n\n\t\tvar axiomatic: boolean = false,\n\t\t\tdoc: string = null,\n\t\t\tannotations: string[] = [],\n\t\t\tcontext = oldContext;\n\n\t\tif (obj._type == 'defschema') {\n\t\t\taxiomatic = obj.axiomatic;\n\t\t\tdoc = obj.doc;\n\t\t\tannotations = obj.annotations;\n\n\t\t\tif (oldContext) {\n\t\t\t\tconsole.log(oldContext);\n\t\t\t\tthrow Error('duh');\n\t\t\t}\n\n\t\t\tvar using: ObjectFun[] = obj.using.map(name => {\n\t\t\t\tif (!scope.hasVariable(name)) {\n\t\t\t\t\tthrow scope.error(`Variable ${name} is not defined`);\n\t\t\t\t}\n\n\t\t\t\tvar fun = scope.getVariable(name);\n\n\t\t\t\tif (!(fun instanceof ObjectFun)) {\n\t\t\t\t\tthrow scope.error(`${name} is not a macro`);\n\t\t\t\t}\n\n\t\t\t\treturn fun;\n\t\t\t});\n\n\t\t\tcontext = new ExecutionContext(using);\n\t\t}\n\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\n\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\t\n\t\t\treturn scope.addVariable(tv) as Variable;\n\t\t});\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scope, context);\n\n\t\t\tif (scope.hasOwn$($v.name)) {\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scope.add$($v);\n\t\t});\n\n\t\tvar expr = PI.metaexpr(obj.expr, scope, context);\n\n\t\treturn new Schema({doc, annotations, axiomatic, name, params, context, def$s, expr}, scope.trace);\n\t}\n\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope, context: ExecutionContext): Funcall {\n\t\tif (obj._type != 'schemacall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.metaexpr(obj.schema, scope, context);\n\n\t\tvar args = obj.args.map(obj => {\n\t\t\treturn PI.expr0(obj, scope);\n\t\t});\n\n\t\treturn new Funcall({\n\t\t\tfun,\n\t\t\targs\n\t\t}, scope.trace);\n\t}\n\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope, context: ExecutionContext): Reduction {\n\t\tif (obj._type != 'reduction')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tif (!context) {\n\t\t\tthrow Error('duh');\n\t\t}\n\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\n\n\t\tvar subject = PI.metaexpr(obj.subject, scope, context);\n\n\t\tvar guesses = !obj.guesses\n\t\t\t? null\n\t\t\t: obj.guesses.map(g => {\n\t\t\t\treturn g && PI.expr0(g, scope);\n\t\t\t});\n\n\t\tvar leftargs = obj.leftargs.map(obj => {\n\t\t\treturn PI.metaexpr(obj, scope, context);\n\t\t});\n\n\t\tvar as = obj.as && PI.metaexpr(obj.as, scope, context);\n\n\t\treturn new Reduction({\n\t\t\tsubject,\n\t\t\tguesses,\n\t\t\tleftargs,\n\t\t\tas\n\t\t}, context, scope.trace);\n\t}\n}","import ObjectFun from \"./nodes/ObjectFun\";\n\nexport default class ExecutionContext {\n\n\tpublic readonly usingList: ObjectFun[];\n\n\tconstructor (usingList?: ObjectFun[]) {\n\t\tthis.usingList = usingList || [];\n\t}\n\n\tpublic uses(fun: ObjectFun) {\n\t\treturn this.usingList.includes(fun);\n\t}\n}","import $Variable from \"./nodes/$Variable\";\nimport Fun from \"./nodes/Fun\";\nimport Funcall from \"./nodes/Funcall\";\nimport Metaexpr from \"./nodes/Metaexpr\";\nimport { isNameable } from \"./nodes/Nameable\";\nimport ObjectFun from \"./nodes/ObjectFun\";\nimport Reduction from \"./nodes/Reduction\";\nimport Schema from \"./nodes/Schema\";\nimport Tee from \"./nodes/Tee\";\nimport Variable from \"./nodes/Variable\";\nimport Scope from \"./Scope\";\n\nexport default class ProofExplorer {\n\tpublic static get(scope: Scope, name: string, ktx) {\n\t\tvar DIAMOND = '&#x25C7;',\n\t\t\tDOWN = '&#x25BC;';\n\t\t// var UP = '&#x25B2;';\n\t\t\n\t\tif (!scope.hasSchema(name)) {\n\t\t\tthrow Error('wut');\n\t\t}\n\t\n\t\tvar theexpr = scope.getSchema(name);\n\t\n\t\tvar ncols = (function recurse(expr: Metaexpr) {\n\t\t\tif (expr instanceof Reduction) {\n\t\t\t\treturn Math.max(\n\t\t\t\t\t...expr.leftargs.map(recurse),\n\t\t\t\t\t((expr.subject instanceof Fun && expr.subject.name)\n\t\t\t\t\t\t|| (expr.subject instanceof Funcall\n\t\t\t\t\t\t\t\t&& isNameable(expr.subject.fun)\n\t\t\t\t\t\t\t\t&& expr.subject.fun.name)\n\t\t\t\t\t\t\t? 0 : recurse(expr.subject)),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t} else if (expr instanceof Schema) {\n\t\t\t\treturn Math.max(\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\n\t\t\t\t\trecurse(expr.expr)\n\t\t\t\t) + 1;\n\t\t\t} else if (expr instanceof ObjectFun) {\n\t\t\t\treturn recurse(expr.expr) + 1;\n\t\t\t} else if (expr instanceof Tee) {\n\t\t\t\treturn Math.max(\n\t\t\t\t\t...expr.left.map(recurse),\n\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\n\t\t\t\t\trecurse(expr.right)\n\t\t\t\t) + 1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t})(theexpr);\n\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], options?) {\n\t\t\tvar padding = left.length;\n\n\t\t\tvar {bbb=false, rrb=false} = options || {};\n\t\n\t\t\tvar htmlLeft = left.map((e, i, a) => `<td class=\"${rrb && i == a.length - 1 ? 'rrb' : 'brb'}\">${e.map(f => ktx(f.toTeXStringWithId(true))).join(', ')}</td>`).join('');\n\n\t\t\tfor (var i = 0; i < left.length; i++)\n\t\t\t\twhile(left[i].length) left[i].pop();\n\t\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\" ' : ''}colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\n\t\t}\n\n\t\tfunction exprToHtml(expr, expand?) {\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\n\t\t\tif (expand) return ktx(expr.expandMeta(true).toTeXString(true));\n\t\t\t\n\t\t\treturn ktx(expr.toTeXString(true));\n\t\t}\n\n\t\tvar ctr = 0;\n\n\t\tvar tree = (function getTree(\n\t\t\t\texpr: Metaexpr,\n\t\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t\t$Map: Map<Metaexpr, number>) {\n\t\t\t\n\t\t\tif (hypnumMap.has(expr)) {\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'R',\n\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\tnum: hypnumMap.get(expr),\n\t\t\t\t\texpr\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tif ($Map.has(expr)) {\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'R',\n\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\tnum: $Map.get(expr),\n\t\t\t\t\texpr\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tif (expr instanceof Reduction) {\n\t\t\t\tvar leftarglines = [];\n\t\t\t\tvar leftargnums = expr.leftargs.map(l => {\n\t\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\n\t\t\t\t\tif ($Map.has(l)) return $Map.get(l);\n\n\t\t\t\t\tvar lines = getTree(l, hypnumMap, $Map);\n\t\t\t\t\tleftarglines = leftarglines.concat(lines);\n\t\t\t\t\treturn lines[lines.length - 1].ctr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tvar args = null;\n\t\t\t\tvar subjectlines = [];\n\t\t\t\tvar subjectnum = hypnumMap.get(expr.subject)\n\t\t\t\t\t|| $Map.get(expr.subject)\n\t\t\t\t\t|| (expr.subject instanceof Funcall && $Map.has(expr.subject.fun)\n\t\t\t\t\t\t? (args = expr.subject.args, $Map.get(expr.subject.fun))\n\t\t\t\t\t\t: false)\n\t\t\t\t\t|| ((s => s instanceof Fun && s.name\n\t\t\t\t\t\t\t|| s instanceof Funcall && isNameable(s.fun) && s.fun.name)(expr.subject)\n\t\t\t\t\t\t? expr.subject\n\t\t\t\t\t\t: (subjectlines = getTree(expr.subject, hypnumMap, $Map))[subjectlines.length-1].ctr);\n\n\t\t\t\treturn [\n\t\t\t\t\t...leftarglines,\n\t\t\t\t\t...subjectlines,\n\t\t\t\t\t{\n\t\t\t\t\t\t_type: 'E',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\tsubject: subjectnum,\n\t\t\t\t\t\targs,\n\t\t\t\t\t\tleftargs: leftargnums,\n\t\t\t\t\t\treduced: expr.reduced\n\t\t\t\t\t}\n\t\t\t\t];\n\t\t\t} else if (expr instanceof Funcall) {\n\t\t\t\tif (hypnumMap.has(expr.fun)) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'RC',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\tschema: hypnumMap.get(expr.fun),\n\t\t\t\t\t\targs: expr.args,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\tif ($Map.has(expr.fun)) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'RC',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\tschema: $Map.get(expr.fun),\n\t\t\t\t\t\targs: expr.args,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\tif (expr.fun instanceof Schema && expr.fun.name) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'RCX',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\tif (!(expr.fun instanceof Schema)) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'NP',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\tvar schemalines = getTree(expr.fun, hypnumMap, $Map);\n\n\t\t\t\treturn [\n\t\t\t\t\t...schemalines,\n\t\t\t\t\t{\n\t\t\t\t\t\t_type: 'RC',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\n\t\t\t\t\t\targs: expr.args,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}\n\t\t\t\t];\n\t\t\t} else if (expr instanceof Variable) {\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'NP',\n\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\texpr\n\t\t\t\t}];\n\t\t\t} else if (expr instanceof Fun) {\n\t\t\t\tif (expr instanceof Schema && expr.name && expr != theexpr) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'RS',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\tif (!expr.expr) {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\t_type: 'NP',\n\t\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\t\texpr\n\t\t\t\t\t}];\n\t\t\t\t}\n\n\t\t\t\t$Map = new Map($Map);\n\n\t\t\t\tvar start = ctr + 1;\n\n\t\t\t\tvar $lines = [];\n\t\t\t\t\n\t\t\t\tif (expr instanceof Schema) {\n\t\t\t\t\texpr.def$s.forEach($ => {\n\t\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\n\t\t\t\t\t\t$lines = $lines.concat(lines);\n\n\t\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t\t\t\t$Map.set($, $num);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'V',\n\t\t\t\t\t$lines,\n\t\t\t\t\tlines: getTree(expr.expr, hypnumMap, $Map),\n\t\t\t\t\t// getHtmlLine 함수가 이 배열을 조작하기 때문에\n\t\t\t\t\t// shallow copy 해야 한다.\n\t\t\t\t\tparams: expr.params.slice(),\n\t\t\t\t\tctr: [start ,ctr]\n\t\t\t\t}];\n\t\t\t} else if (expr instanceof Tee) {\n\t\t\t\thypnumMap = new Map(hypnumMap);\n\t\t\t\tvar leftlines = [];\n\n\t\t\t\tvar start = ctr + 1;\n\n\t\t\t\texpr.left.forEach(l => {\n\t\t\t\t\thypnumMap.set(l, ++ctr);\n\t\t\t\t\tleftlines.push({\n\t\t\t\t\t\t_type: 'H',\n\t\t\t\t\t\tctr,\n\t\t\t\t\t\texpr: l\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t$Map = new Map($Map);\n\n\t\t\t\tvar $lines = [];\n\t\t\t\texpr.def$s.forEach($ => {\n\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\n\t\t\t\t\t$lines = $lines.concat(lines);\n\n\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t\t\t$Map.set($, $num);\n\t\t\t\t});\n\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'T',\n\t\t\t\t\tleftlines,\n\t\t\t\t\t$lines,\n\t\t\t\t\trightlines: getTree(expr.right, hypnumMap, $Map),\n\t\t\t\t\tctr: [start, ctr]\n\t\t\t\t}];\n\t\t\t} else if (expr instanceof $Variable) {\n\t\t\t\tif (!$Map.has(expr)) {\n\t\t\t\t\tthrow Error(`${expr.name} is not defined`);\n\t\t\t\t}\n\n\t\t\t\treturn [{\n\t\t\t\t\t_type: 'R',\n\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\tnum: $Map.get(expr),\n\t\t\t\t\texpr: expr.expr\n\t\t\t\t}];\n\t\t\t} else {\n\t\t\t\tconsole.log('Unknown metaexpr', expr);\n\t\t\t\treturn [{\n\t\t\t\t\t_type: '?',\n\t\t\t\t\tctr: ++ctr,\n\t\t\t\t\texpr\n\t\t\t\t}];\n\t\t\t}\n\t\t})(theexpr, new Map(), new Map());\n\n\t\tvar html = '<table class=\"explorer\">';\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\n\t\t\n\t\thtml += (function tree2html(lines, left) {\n\t\t\treturn lines.map(line => {\n\t\t\t\tswitch (line._type) {\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([line.params]))\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([line.params]));\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\n\n\t\t\t\t\t\tvar ret = '';\n\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\n\n\t\t\t\t\t\t\tret += getHtmlLine(\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', {bbb: true, rrb: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\n\t\t\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\t\t\tnewleft,\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t\t\t'assumption',\n\t\t\t\t\t\t\t\t\t{bbb: i == a.length - 1, rrb: true}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}).join('');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret += tree2html(\n\t\t\t\t\t\t\tline.$lines,\n\t\t\t\t\t\t\tnewleft\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tret += tree2html(\n\t\t\t\t\t\t\tline.rightlines,\n\t\t\t\t\t\t\tnewleft\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'???'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tthrow Error('no');\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RS':\n\t\t\t\t\tcase 'RCX':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RC':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)}${line.args ? ' (' + line.args.map(a => exprToHtml(a)).join(', ') + ')' : ''} [${line.leftargs.map(a => exprToHtml(a)).join(', ')}]`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'NP':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t`Unknown type ${line._type}`,\n\t\t\t\t\t\t\t''\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t})(tree[0].$lines.concat(tree[0].lines), []);\n\t\t\n\t\thtml += '</table>';\n\t\n\t\treturn html;\n\t}\n}","import $Variable from './nodes/$Variable';\nimport Fun from './nodes/Fun';\nimport Metaexpr from './nodes/Metaexpr';\nimport ObjectFun from './nodes/ObjectFun';\nimport ObjectType from './nodes/ObjectType';\nimport Schema from './nodes/Schema';\nimport Variable from './nodes/Variable';\nimport { LocationObject } from './PegInterfaceDefinitions';\nimport StackTrace from './StackTrace';\n\nexport type NestedTypeInput = string | NestedTypeInput[];\n\n/**\n * 변수 영역(scope).\n * 구문 분석 과정에서 name resolution을 할 때에만 사용해야 한다.\n */\nexport default class Scope {\n\tpublic readonly importMap: Map<string, Scope> = new Map();\n\n\tpublic readonly typedefMap: Map<string, ObjectType> = new Map();\n\tpublic readonly defMap: Map<string, Variable | ObjectFun> = new Map();\n\tpublic readonly schemaMap: Map<string, Schema> = new Map();\n\tpublic readonly $Map: Map<string, $Variable> = new Map();\n\tpublic readonly hypotheses: Metaexpr[] = [];\n\n\tpublic readonly parent: Scope;\n\tpublic readonly root: Scope;\n\n\tpublic readonly trace: StackTrace;\n\tpublic baseType: ObjectType;\n\n\tpublic readonly fileUri: string;\n\n\tconstructor (fileUri: string, parent: Scope, trace?: StackTrace) {\n\t\tthis.fileUri = fileUri;\n\n\t\tthis.parent = parent;\n\t\tthis.root = parent ? parent.root : this;\n\n\t\tif (trace && !(trace instanceof StackTrace)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tthis.trace = trace || new StackTrace(fileUri);\n\n\t\tthis.baseType = parent ? parent.baseType : null;\n\t}\n\n\tpublic extend(type: string, name: string, location: LocationObject): Scope {\n\t\tvar child = new Scope(this.fileUri, this, this.trace.extend({type, name, location}));\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\n\t\treturn child;\n\t}\n\n\tpublic error(message: string): Error {\n\t\treturn this.trace.error(message);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasOwnType(e);\n\t\t}).every(e => e);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.hasOwnType(name)\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasType(e);\n\t\t}).every(e => e);\n\t}\n\n\tpublic addType(type: ObjectType): ObjectType {\n\t\tif (!(type instanceof ObjectType))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!type.name)\n\t\t\tthrow this.error('Something\\'s wrong');\n\n\t\tif (this.hasOwnType(type.name))\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\n\n\t\tif (type.isBaseType) {\n\t\t\tif (this.baseType) {\n\t\t\t\tthrow this.error('A base type already exists');\n\t\t\t}\n\n\t\t\t(function broadcast(scope: Scope) {\n\t\t\t\tscope.baseType = type;\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\n\t\t\t})(this);\n\t\t}\n\n\t\tthis.typedefMap.set(type.name, type);\n\t\treturn type;\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic getType(name: NestedTypeInput): ObjectType {\n\t\tif (typeof name == 'string') {\n\t\t\tif (!this.hasType(name))\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\n\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t? this.typedefMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getType(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasType(name)\n\t\t\t\t\t})[0].getType(name);\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\n\t\t\treturn this.getType(e);\n\t\t});\n\n\t\tvar to = this.getType(name[name.length - 1]);\n\n\t\treturn new ObjectType({\n\t\t\tfunctional: true,\n\t\t\tfrom,\n\t\t\tto\n\t\t});\n\t}\n\n\tpublic hasOwnVariable(name: string): boolean {\n\t\treturn this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnVariable(name));\n\t}\n\n\tpublic hasVariable(name: string): boolean {\n\t\treturn this.hasOwnVariable(name)\n\t\t\t|| (!!this.parent && this.parent.hasVariable(name));\n\t}\n\n\tpublic addVariable(variable: Variable | Fun): Variable | Fun {\n\t\tif (!(variable instanceof Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnVariable(variable.name))\n\t\t\tthrow this.error(`Definition ${variable.name} has already been declared`);\n\n\t\tthis.defMap.set(variable.name, variable);\n\t\treturn variable;\n\t}\n\n\tpublic addFun(fun: ObjectFun): ObjectFun {\n\t\tif (!(fun instanceof ObjectFun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!fun.name)\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\n\n\t\tif (this.hasOwnVariable(fun.name))\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\n\n\t\tthis.defMap.set(fun.name, fun);\n\t\treturn fun;\n\t}\n\n\tpublic getVariable(name: string): Variable | ObjectFun {\n\t\tif (!this.hasVariable(name))\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\n\n\t\treturn this.defMap.has(name)\n\t\t\t? this.defMap.get(name)\n\t\t\t: (!!this.parent && this.parent.getVariable(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.hasVariable(name)\n\t\t\t\t})[0].getVariable(name);\n\t}\n\n\tpublic hasOwnSchema(name: string): boolean {\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnSchema(name));\n\t}\n\n\tpublic hasSchema(name: string): boolean {\n\t\treturn this.hasOwnSchema(name)\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\n\t}\n\n\tpublic addSchema(schema: Schema): Schema {\n\t\tif (!(schema instanceof Fun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnSchema(schema.name))\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\n\n\t\tthis.schemaMap.set(schema.name, schema);\n\t\treturn schema;\n\t}\n\n\tpublic getSchema(name: string): Variable | Fun {\n\t\tif (!this.hasSchema(name))\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\n\n\t\treturn this.schemaMap.has(name)\n\t\t\t? this.schemaMap.get(name)\n\t\t\t: this.defMap.has(name)\n\t\t\t\t? this.defMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasSchema(name)\n\t\t\t\t\t})[0].getSchema(name);\n\t}\n\n\tpublic hasOwn$(name: string): boolean {\n\t\treturn this.$Map.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwn$(name));\n\t}\n\n\tpublic has$(name: string): boolean {\n\t\treturn this.hasOwn$(name)\n\t\t\t|| (!!this.parent && this.parent.has$(name));\n\t}\n\n\tpublic add$($: $Variable): $Variable {\n\t\tif (!($ instanceof $Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwn$($.name))\n\t\t\tthrow this.error(`$ variable ${$.name} has already been declared`);\n\n\t\tthis.$Map.set($.name, $);\n\t\treturn $;\n\t}\n\n\tpublic get$(name: string): $Variable {\n\t\tif (!this.has$(name))\n\t\t\tthrow this.error(`$ variable ${name} is not defined`);\n\n\t\treturn this.$Map.has(name)\n\t\t\t? this.$Map.get(name)\n\t\t\t: (!!this.parent && this.parent.get$(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.has$(name)\n\t\t\t\t})[0].get$(name);\n\t}\n}","import { LocationObject } from \"./PegInterfaceDefinitions\";\n\ninterface StackTraceElement {\n\ttype: string;\n\tname: string;\n\tlocation: LocationObject;\n}\n\nexport default class StackTrace {\n\n\tpublic readonly fileUri: string;\n\tpublic readonly stack: StackTraceElement[];\n\n\tconstructor (fileUri: string, stack?: StackTraceElement[]) {\n\t\tthis.fileUri = fileUri;\n\t\tthis.stack = stack || [];\n\t}\n\n\tpublic extend(element: StackTraceElement): StackTrace {\n\t\treturn new StackTrace(this.fileUri, [element].concat(this.stack));\n\t}\n\n\tpublic error(message: string) {\n\t\tvar fileUri = this.fileUri || '<unknown>';\n\n\t\treturn new Error(\n\t\t\tmessage\n\t\t\t+ '\\n\\tat '\n\t\t\t+ (\n\t\t\t\tthis.stack.length\n\t\t\t\t\t? this.stack.map(({type, name, location}) => {\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${fileUri}:${location.start.line}:${location.start.column})`;\n\t\t\t\t\t}).join('\\n\\tat ')\n\t\t\t\t\t: `<root> (${fileUri}:1:1)`\n\t\t\t)\n\t\t);\n\t}\n}"],"sourceRoot":""}