{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/ExpressionResolver.ts","webpack://math/./src/nodes/Typevar.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Fun.ts","webpack://math/./src/nodes/Schemacall.ts","webpack://math/./src/nodes/Funcall.ts","webpack://math/./src/nodes/Schema.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/Ruleset.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts","webpack://math/./node_modules/process/browser.js","webpack://math/./src/PegInterface.ts","webpack://math/./src/nodes/Reduction.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","scope","_id","toIndentedString","message","error","Error","replace","tex","precedence","code","match","g1","hyps","some","hyp","equals","prec","Array","length","console","log","my","normalizePrecedence","your","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","iscall","a","includes","_type","callee","schema","fun","makecall","ER","expr","map","substitute","arg","params","e","has","left","right","axiomatic","reduced","iscallable","Map","set","expandCallOnce","callee_","expand0Funcalls","native","expandMeta","expandMetaAndFuncalls","b","recurseWrap","recurse","depth","type","every","_","isFunctional","placeholders","len","resolve","from","push","nequalscall","nequalstrue","tees","tee","reduceRight","newleft","slice","concat","nrecursecall","nrecursetrue","Typevar","isParam","guess","doc","super","isProved","toSimpleString","indent","escapeTeX","Type","isBaseType","base","origin","isSimple","functional","f","to","resolved","join","toTeXString","Fun","parseTeX","typevar","repeat","funcallToTeXString","makeTeX","Schemacall","paramTypes","argTypes","expanded","proved","Funcall","resolvedType","Schema","Tee","reduce","MetaType","Ruleset","grammar","default","Program","ExpressionResolver","lines","nativeMap","forEach","line","hasType","addType","hasTypevar","addTypevar","addFun","ruleset","hasRuleset","addRuleset","hasSchema","addSchema","typedef","defv","defun","defruleset","defschema","reduction","schemacall","var","schemaexpr","Scope","parent","trace","typedefMap","defMap","schemaMap","rulesetMap","baseType","location","extend","hasOwnType","broadcast","getType","hasOwnTypevar","getTypevar","hasOwnRuleset","getRuleset","hasOwnSchema","getSchema","StackTrace","stack","filename","process","argv","start","column","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","runClearTimeout","marker","Item","array","noop","nextTick","arguments","apply","title","browser","env","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","typeObjToString","obj","ftype","typeObjToNestedArr","PI","parentScope","tvo","tv","rettype","expr0","metavar","funcall","rulesetName","varObjToString","foo","metaexpr","subject","guesses","g","leftargs","Reduction","derefs","query","leftargTypes","lef","that","node","ptr","test"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","var ctr = 0;\r\n\r\nexport type Precedence = boolean | number | [number, number];\r\n\r\ninterface Nodeable {\r\n\ttoIndentedString: (indent: number, root?: boolean) => string;\r\n\ttoTeXString: (prec?: Precedence, root?: boolean) => string;\r\n\tisProved: (hyps) => boolean;\r\n}\r\n\r\nexport default abstract class Node implements Nodeable {\r\n\tpublic readonly _id: number;\r\n\tpublic readonly scope: Scope;\r\n\r\n\tpublic type: Type | MetaType;\r\n\tpublic doc: string;\r\n\tpublic tex: string;\r\n\tpublic precedence: Precedence;\r\n\r\n\tpublic static readonly PREC_FUNEXPR = 1000;\r\n\tpublic static readonly PREC_COMMA = 1000;\r\n\tpublic static readonly PREC_COLONEQQ = 100000;\r\n\r\n\tconstructor (scope?: Scope) {\r\n\t\tthis._id = ++ctr;\r\n\t\tthis.scope = scope;\r\n\t}\r\n\r\n\tpublic toString() {\r\n\t\treturn this.toIndentedString(0);\r\n\t}\r\n\r\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\r\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\r\n\r\n\tpublic error(message) {\r\n\t\tif (this.scope) {\r\n\t\t\treturn this.scope.error(message);\r\n\t\t} else {\r\n\t\t\treturn new Error(message);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static escapeTeX(s) {\r\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\r\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\r\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\r\n\t\t\t'}': '\\\\}',\r\n\t\t\t'~': '\\\\textasciitilde',\r\n\t\t\t'^': '\\\\textasciicircum',\r\n\t\t\t'\\\\': '\\\\textbackslash'\r\n\t\t})[m]);\r\n\t}\r\n\r\n\tpublic static parseTeX(tex) {\r\n\t\tvar precedence: Precedence = false;\r\n\r\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\r\n\t\t\tprecedence = g1 * 1;\r\n\t\t\treturn '';\r\n\t\t});\r\n\r\n\t\treturn {precedence, code};\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\r\n\t\tif (hyps.some(hyp => ExpressionResolver.equals(hyp, this))) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t* false corresponds to 0.\r\n\t* true corresponds to w * 2.\r\n\t*/\r\n\tpublic static normalizePrecedence(prec: Precedence) {\r\n\t\tif (prec === false) return [0, 0];\r\n\t\tif (prec === true) return [2, 0];\r\n\t\tif (typeof prec == 'number') return [0, prec];\r\n\r\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\r\n\t\t\tconsole.log(prec);\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn prec;\r\n\t}\r\n\r\n\tpublic shouldConsolidate(prec: Precedence) {\r\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\r\n\t\t\tyour = Node.normalizePrecedence(prec || false);\r\n\r\n\t\tif (my[0] == 0 && my[1] == 0) return false;\r\n\r\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\r\n\t}\r\n\r\n\tpublic makeTeX(id, args, prec) {\r\n\t\targs = args || [];\r\n\t\tprec = prec || false;\r\n\t\t\r\n\t\tvar ret = this.tex;\r\n\r\n\t\tif (this.shouldConsolidate(prec)) {\r\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\r\n\t\t}\r\n\r\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\r\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\r\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\r\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// 순환 참조를 피하기 위하여 export 후 import 한다.\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';","export type Expr0 = Funcall | Fun | Typevar;\r\nexport type Metaexpr = Tee | Reduction | Schemacall | Schema | Expr0;\r\n\r\nfunction iscallable(a: Metaexpr): a is Schema | Fun {\r\n\treturn ['schema', 'fun'].includes(a._type);\r\n}\r\n\r\nfunction iscall(a: Metaexpr): a is Schemacall | Funcall {\r\n\treturn ['schemacall', 'funcall'].includes(a._type);\r\n}\r\n\r\nfunction callee(a: Metaexpr): Metaexpr {\r\n\treturn a._type == 'schemacall'\r\n\t\t? a.schema\r\n\t\t: a._type == 'funcall'\r\n\t\t\t? a.fun\r\n\t\t\t: (() => {\r\n\t\t\t\tconsole.log(a);\r\n\t\t\t\tthrow Error();\r\n\t\t\t})();\r\n}\r\n\r\nfunction makecall(a: Metaexpr, args: Expr0[]): Metaexpr {\r\n\treturn a._type == 'fun' || a._type == 'typevar'\r\n\t\t? new Funcall({\r\n\t\t\tfun: a,\r\n\t\t\targs\r\n\t\t})\r\n\t\t: a._type == 'schema'\r\n\t\t\t? new Schemacall({\r\n\t\t\t\tschema: a,\r\n\t\t\t\targs\r\n\t\t\t})\r\n\t\t\t: (() => {\r\n\t\t\t\tconsole.log(a);\r\n\t\t\t\tthrow Error();\r\n\t\t\t})();\r\n}\r\n\r\nexport default class ER {\r\n\tpublic static substitute(expr: Metaexpr, map: Map<Typevar | Fun, Expr0>): Metaexpr {\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'funcall':\r\n\t\t\t\tvar fun = ER.substitute(expr.fun, map),\r\n\t\t\t\t\targs = expr.args.map(arg => ER.substitute(arg, map));\r\n\r\n\t\t\t\tif (fun._type == 'schema') {\r\n\t\t\t\t\treturn new Schemacall({\r\n\t\t\t\t\t\tschema: fun,\r\n\t\t\t\t\t\targs\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new Funcall({ fun, args });\r\n\t\t\tcase 'fun':\r\n\t\t\t\tif (!expr.expr) return map.get(expr) || expr;\r\n\r\n\t\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\t\tif (expr.name) return map.get(expr) || expr;\r\n\r\n\t\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생한다.\r\n\t\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\t\treturn new Fun({\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.substitute(expr.expr, map)\r\n\t\t\t\t});\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn map.get(expr) || expr;\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(e => ER.substitute(e, map));\r\n\t\t\t\tvar right = ER.substitute(expr.right, map);\r\n\r\n\t\t\t\treturn new Tee({\r\n\t\t\t\t\tleft, right\r\n\t\t\t\t});\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn new Schemacall({\r\n\t\t\t\t\tschema: ER.substitute(expr.schema, map),\r\n\t\t\t\t\targs: expr.args.map(arg => ER.substitute(arg, map))\r\n\t\t\t\t});\r\n\t\t\tcase 'schema':\r\n\t\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\t\tif (expr.name) return expr;\r\n\r\n\t\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.substitute(expr.expr, map)\r\n\t\t\t\t});\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.substitute(expr.reduced, map);\r\n\t\t\tdefault:\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tthrow Error(`Unknown type ${expr._type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static call(callee: Schema | Fun, args: Expr0[]): Metaexpr {\r\n\t\tif (!iscallable(callee)) {\r\n\t\t\tconsole.log(callee);\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (!callee.expr) {\r\n\t\t\tthrow Error('Cannot call a callable without a body');\r\n\t\t}\r\n\r\n\t\tif (callee.params.length != args.length) {\r\n\t\t\tthrow Error('Illegal arguments length');\r\n\t\t}\r\n\r\n\t\tvar map = new Map();\r\n\r\n\t\tfor (var i = 0; i < callee.params.length; i++) {\r\n\t\t\tmap.set(callee.params[i], args[i]);\r\n\t\t}\r\n\r\n\t\treturn ER.substitute(callee.expr, map);\r\n\t}\r\n\r\n\tpublic static expandCallOnce(expr: Metaexpr): Metaexpr {\r\n\t\tif (!iscall(expr)) {\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (iscall(callee(expr))) {\r\n\t\t\tvar fun = ER.expandCallOnce(callee(expr));\r\n\t\t\treturn makecall(fun, expr.args);\r\n\t\t}\r\n\r\n\t\tvar callee_ = callee(expr);\r\n\r\n\t\tif (callee_._type != 'schema' && callee_._type != 'fun') {\r\n\t\t\tthrow Error('Something\\'s wrong');\r\n\t\t}\r\n\r\n\t\tif (!callee_.expr) {\r\n\t\t\tthrow Error('Could not expand');\r\n\t\t}\r\n\r\n\t\treturn ER.call(callee_, expr.args);\r\n\t}\r\n\r\n\t// 이름 있는 것은 풀지 않는다. 재귀적.\r\n\tpublic static expand0Funcalls(expr) {\r\n\t\tif (expr._type == 'funcall') {\r\n\t\t\tvar fun = ER.expand0Funcalls(expr.fun);\r\n\t\t\tvar args = expr.args.map(ER.expand0Funcalls);\r\n\r\n\t\t\tif (fun._type != 'fun' || fun.name)\r\n\t\t\t\treturn new Funcall({fun, args});\r\n\r\n\t\t\treturn ER.expand0Funcalls(ER.call(fun, args));\r\n\t\t} else if (expr._type == 'fun' && !expr.name) {\r\n\t\t\treturn new Fun({\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ER.expand0Funcalls(expr.expr)\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\treturn expr;\r\n\t\t}\r\n\t}\r\n\r\n\t// expand0은 하지 않는다.\r\n\tpublic static expandMeta(expr) {\r\n\t\tif (expr.native) {\r\n\t\t\treturn expr;\r\n\t\t}\r\n\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(ER.expandMeta);\r\n\t\t\t\tvar right = ER.expandMeta(expr.right);\r\n\r\n\t\t\t\treturn new Tee({left, right});\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\tvar schema = ER.expandMeta(expr.schema),\r\n\t\t\t\t\targs = expr.args;\r\n\r\n\t\t\t\treturn ER.expandMeta(ER.call(schema, args));\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.expandMeta(expr.reduced);\r\n\t\t\tcase 'schema':\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.expandMeta(expr.expr)\r\n\t\t\t\t});\r\n\t\t\tcase 'funcall':\r\n\t\t\tcase 'fun':\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn expr;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(expr);\r\n\t\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\t// expr0의 이름 없는 funcall까지 풀음.\r\n\tpublic static expandMetaAndFuncalls(expr) {\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(ER.expandMetaAndFuncalls);\r\n\t\t\t\tvar right = ER.expandMetaAndFuncalls(expr.right);\r\n\r\n\t\t\t\treturn new Tee({left, right});\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\tvar schema = ER.expandMetaAndFuncalls(expr.schema);\r\n\t\t\t\tvar args = expr.args.map(ER.expand0Funcalls);\r\n\r\n\t\t\t\treturn ER.expandMetaAndFuncalls(ER.call(schema, args));\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.expandMetaAndFuncalls(expr.reduced);\r\n\t\t\tcase 'schema':\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.expandMetaAndFuncalls(expr.expr)\r\n\t\t\t\t});\r\n\t\t\tcase 'funcall':\r\n\t\t\tcase 'fun':\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn ER.expand0Funcalls(expr);\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(expr);\r\n\t\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static nequalscall = 0;\r\n\tpublic static nequalstrue = 0;\r\n\tpublic static nrecursecall = 0;\r\n\tpublic static nrecursetrue = 0;\r\n\r\n\t/*\r\n\t * 스펙 참조.\r\n\t */\r\n\tpublic static equals(a, b) {\r\n\t\tfunction recurse(a, b, depth) {\r\n\t\t\tif (a == b) return true;\r\n\r\n\t\t\tif (!a.type.equals(b.type)) return false;\r\n\r\n\t\t\tif (a._type == 'reduction') {\r\n\t\t\t\treturn recurseWrap(a.reduced, b, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (b._type == 'reduction') {\r\n\t\t\t\treturn recurseWrap(a, b.reduced, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a) && iscall(b)) {\r\n\t\t\t\tif (iscall(callee(a))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (iscall(callee(b))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (callee(a) == callee(b) || !callee(a).expr && !callee(b).expr) {\r\n\t\t\t\t\tif (callee(a) != callee(b)) return false;\r\n\r\n\t\t\t\t\tif (!callee(a).expr && !callee(b).expr) {\r\n\t\t\t\t\t\tfor (var i = 0; i < a.args.length; i++) {\r\n\t\t\t\t\t\t\tif (!recurseWrap(a.args[i], b.args[i], depth + 1)) return false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (a.args.every((_, i) => {\r\n\t\t\t\t\t\treturn recurseWrap(a.args[i], b.args[i], depth + 1);\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (callee(a).expr) {\r\n\t\t\t\t\treturn recurseWrap(ER.expandCallOnce(a), b, depth + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a, ER.expandCallOnce(b), depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a)) {\r\n\t\t\t\tif (iscall(callee(a))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!callee(a).expr) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(b)) {\r\n\t\t\t\tif (iscall(callee(b))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!callee(b).expr) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (a._type == 'tee') {\r\n\t\t\t\tfor (var i = 0; i < a.left.length; i++) {\r\n\t\t\t\t\tif (!recurseWrap(a.left[i], b.left[i], depth + 1)) return false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a.right, b.right, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (a.type.isFunctional) {\r\n\t\t\t\tvar placeholders = [];\r\n\t\t\t\tvar len = a.type.resolve().from.length;\r\n\r\n\t\t\t\tfor (var i = 0; i < len; i++) {\r\n\t\t\t\t\tplaceholders.push(new Typevar({\r\n\t\t\t\t\t\ttype: a.type.resolve().from[i],\r\n\t\t\t\t\t\tname: '$' + i\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tmakecall(a, placeholders), makecall(b, placeholders), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar recurseWrap = recurse;\r\n\r\n\t\t// function recurseWrap(a, b, depth) {\r\n\t\t// \tER.nrecursecall++;\r\n\r\n\t\t// \tconsole.log(`depth ${depth}\\n${a}\\n\\n${b}`);\r\n\t\t// \tvar ret = recurse(a, b, depth);\r\n\t\t// \tconsole.log(`depth ${depth} → ${ret}`);\r\n\r\n\t\t// \tif (ret) ER.nrecursetrue++;\r\n\r\n\t\t// \treturn ret;\r\n\t\t// }\r\n\r\n\t\tER.nequalscall++;\r\n\t\tvar ret = recurseWrap(a, b, 0);\r\n\t\tif (ret) ER.nequalstrue++;\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic static chain(tees) {\r\n\t\tif (!tees.every(tee => tee._type == 'tee')) {\r\n\t\t\tthrow Error('no');\r\n\t\t}\r\n\r\n\t\treturn ER.expandMetaAndFuncalls(tees.reduceRight((r, l) => {\r\n\t\t\tfor (var i = 0; i < r.left.length; i++) {\r\n\t\t\t\tif (ER.equals(l.right, r.left[i])) {\r\n\t\t\t\t\tvar newleft = r.left.slice(0, i)\r\n\t\t\t\t\t\t.concat(l.left)\r\n\t\t\t\t\t\t.concat(r.left.slice(i + 1));\r\n\r\n\t\t\t\t\treturn new Tee({\r\n\t\t\t\t\t\tleft: newleft,\r\n\t\t\t\t\t\tright: r.right\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthrow Error(`Chaining failed:\r\n\r\n--- LEFT ---\r\n${l}\r\n------------\r\n\r\n--- RIGHT ---\r\n${r}\r\n-------------`);\r\n\t\t}));\r\n\t}\r\n}\r\n\r\n// 순환 참조를 피하기 위하여 export 후 import 한다.\r\nimport Fun from \"./nodes/Fun\";\r\nimport Funcall from \"./nodes/Funcall\";\r\nimport Reduction from \"./nodes/Reduction\";\r\nimport Schema from \"./nodes/Schema\";\r\nimport Schemacall from \"./nodes/Schemacall\";\r\nimport Tee from \"./nodes/Tee\";\r\nimport Typevar from \"./nodes/Typevar\";","import Scope from '../Scope';\r\nimport Node, {Precedence} from './Node';\r\nimport Type from './Type';\r\n\r\ninterface TypevarArgumentable {\r\n\ttype: Type,\r\n\tisParam?: boolean,\r\n\tguess?: string,\r\n\tname: string,\r\n\tdoc?: string,\r\n\ttex?: string\r\n}\r\n\r\nexport default class Typevar extends Node {\r\n\tpublic readonly _type = 'typevar';\r\n\r\n\tpublic readonly isParam: boolean;\r\n\tpublic readonly guess: string;\r\n\tpublic readonly type: Type;\r\n\tpublic readonly name: string;\r\n\r\n\tconstructor ({type, isParam, guess, name, doc, tex}: TypevarArgumentable, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\t\tthis.tex = tex;\r\n\r\n\t\tthis.isParam = !!isParam;\r\n\t\tthis.guess = guess || null;\r\n\r\n\t\ttype = type as Type;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.type = type;\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps);\r\n\t}\r\n\r\n\t// pr f\r\n\tpublic toSimpleString() {\r\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\r\n\r\n\t\tvar tex = this.tex\r\n\t\t\t|| (\r\n\t\t\t\tthis.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.name)}}`\r\n\t\t\t);\r\n\t\t\r\n\t\treturn `\\\\href{#${id}}{${tex}}`;\r\n\t}\r\n}","import Node from './Node';\r\n\r\nexport default class Type extends Node {\r\n\tpublic readonly _type = 'type';\r\n\r\n\tpublic readonly isBaseType: boolean;\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly origin: Type;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: Type;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tthis.doc = o.doc;\r\n\t\tthis.isBaseType = !!o.base;\r\n\r\n\t\tif (o.origin) {\r\n\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\tthis.name = o.name;\r\n\r\n\t\t\tif (!(o.origin instanceof Type))\r\n\t\t\t\tthrow this.error('!(o.origin instanceof Type)');\r\n\r\n\t\t\tthis.isFunctional = o.origin.isFunctional;\r\n\t\t\tthis.isSimple = o.origin.isSimple;\r\n\t\t\tthis.origin = o.origin;\r\n\t\t} else {\r\n\t\t\tif (typeof o.functional != 'boolean')\r\n\t\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\tthis.isFunctional = o.functional;\r\n\t\t\tthis.isSimple = !o.functional;\r\n\r\n\t\t\tif (!o.functional) {\r\n\t\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\t\tthis.name = o.name;\r\n\t\t\t} else {\r\n\t\t\t\tif (o.from.map(f => f instanceof Type).some(e => !e))\r\n\t\t\t\t\tthrow this.error('o.from.map(f => f instanceof Type).some(e => !e)');\r\n\t\t\t\tif (!(o.to instanceof Type))\r\n\t\t\t\t\tthrow this.error('!(o.to instanceof Type)');\r\n\r\n\t\t\t\tthis.from = o.from;\r\n\t\t\t\tthis.to = o.to;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toSimpleString() {\r\n\t\tif (this.name) return this.name;\r\n\r\n\t\tvar resolved = this.resolve();\r\n\r\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent): string {\r\n\t\tif (this.isSimple) return this.name;\r\n\r\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(root?: boolean) {\r\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\r\n\t\tif (!root && this.name) {\r\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\t\t}\r\n\r\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\r\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\r\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\r\n\t}\r\n\r\n\tpublic resolve(): Type {\r\n\t\treturn this.origin ? this.origin.resolve() : this;\r\n\t}\r\n\r\n\tpublic equals(t): boolean {\r\n\t\tif (!(t instanceof Type)) return false;\r\n\r\n\t\tif (this.origin) return this.origin.equals(t);\r\n\t\tif (t.origin) return this.equals(t.origin);\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) return this === t;\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (var i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Typevar from './Typevar';\r\n\r\ninterface FunArgumentType {\r\n\tname?: string,\r\n\ttype?: Type,\r\n\tparams: Typevar[],\r\n\texpr?: Node,\r\n\tdoc?: string,\r\n\ttex?: string\r\n}\r\n\r\nexport default class Fun extends Node {\r\n\tpublic readonly _type = 'fun';\r\n\r\n\tpublic readonly name: string;\r\n\tpublic readonly type: Type;\r\n\tpublic readonly params;\r\n\tpublic readonly expr;\r\n\r\n\t/*\r\n\t * name, expr 중 하나 이상 있어야 하고 type, expr 중\r\n\t * 한 개만 있어야 한다.\r\n\t */\r\n\tconstructor ({name, type, params, expr, doc, tex}: FunArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\r\n\t\tif (tex) {\r\n\t\t\tvar {precedence, code} = Fun.parseTeX(tex);\r\n\r\n\t\t\tthis.precedence = precedence;\r\n\t\t\tthis.tex = code;\r\n\t\t} else {\r\n\t\t\tthis.precedence = false;\r\n\t\t\tthis.tex = null;\r\n\t\t}\r\n\r\n\t\tif (!name && !expr)\r\n\t\t\tthrow this.error('Anonymous fun cannot be primitive');\r\n\r\n\t\tif (type && expr)\r\n\t\t\tthrow this.error('no');\r\n\r\n\t\tif (!type && !expr)\r\n\t\t\tthrow this.error('Cannot guess the type of a primitive fun');\r\n\r\n\t\tif (name !== null && typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\ttype = type as Type;\r\n\r\n\t\tif (!(params instanceof Array)\r\n\t\t\t\t|| params.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (expr !== null && !(expr instanceof Node))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.type = type || new Type({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\tto: expr.type\r\n\t\t});\r\n\t\tthis.params = params;\r\n\t\tthis.expr = expr;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (!this.expr)\r\n\t\t\treturn `ƒ ${this.type.to} ${this.name}(${this.params.join(', ')});`;\r\n\r\n\t\treturn [\r\n\t\t\t(this.name ? 'ƒ ' + this.type.to + ' ' + this.name : 'ƒ ')\r\n\t\t\t\t+ `(${this.params.join(', ')}) => {`,\r\n\t\t\t`\\t${this.expr.toIndentedString(indent + 1)}`,\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t`\\\\mapsto ${ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(false)}`,\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\r\n\t\tif (!root)\r\n\t\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${Node.escapeTeX(this.name)}}`;\r\n\t\r\n\t\tif (!this.expr)\r\n\t\t\treturn this.funcallToTeXString(this.params, prec);\r\n\t\r\n\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\r\n\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\r\n\t}\r\n\r\n\tpublic funcallToTeXString(args, prec) {\r\n\t\targs = args.map(arg => {\r\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\r\n\t\t});\r\n\t\r\n\t\tif (this.tex) {\r\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\r\n\t\t}\r\n\t\r\n\t\treturn `${!this.name\r\n\t\t\t\t? this.toTeXString(false)\r\n\t\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? Node.escapeTeX(this.name) : `\\\\mathrm{${Node.escapeTeX(this.name)}}`}}`}`\r\n\t\t\t+ `(${args.join(', ')})`;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Typevar from './Typevar';\r\n\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';\r\nimport Scope from '../Scope';\r\n\r\nexport default class Schemacall extends Node {\r\n\tpublic readonly _type = 'schemacall';\r\n\r\n\tpublic readonly schema;\r\n\tpublic readonly args;\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly expanded;\r\n\r\n\tconstructor ({schema, args}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (!schema) {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (!(args instanceof Array))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.schema = schema;\r\n\t\tthis.args = args;\r\n\r\n\t\tvar paramTypes = schema.type.from,\r\n\t\t\targTypes = args.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(argTypes[i]))\r\n\t\t\t\tthrow this.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t\t}\r\n\r\n\t\tthis.type = schema.type.to;\r\n\r\n\t\tthis.expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.schema.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (args.join('').length <= 50) {\r\n\t\t\targs = this.args.map(arg => {\r\n\t\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\targs = args.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.schema.name || `(${this.schema})`}(`,\r\n\t\t\t\targs,\r\n\t\t\t\t')'\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\telse {\r\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.schema.name || `(${this.schema.toIndentedString(indent)})`}(`,\r\n\t\t\t\t'\\t' + args,\r\n\t\t\t\t')'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn (\r\n\t\t\tthis.schema.name\r\n\t\t\t\t? `\\\\href{#schema-${this.schema.proved ? 'p' : 'np'}-${this.schema.name}}{\\\\textsf{${Node.escapeTeX(this.schema.name)}}}`\r\n\t\t\t\t: this.schema.toTeXString(false)\r\n\t\t) + `(${this.args.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')})`;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Typevar from './Typevar';\r\nimport Fun from './Fun';\r\nimport Scope from '../Scope';\r\nimport Type from './Type';\r\n\r\nexport default class Funcall extends Node {\r\n\tpublic readonly _type = 'funcall';\r\n\t\r\n\tpublic readonly fun;\r\n\tpublic readonly type: Type;\r\n\tpublic readonly args;\r\n\r\n\tconstructor ({fun, args}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tfun = fun as Typevar | Fun | Funcall;\r\n\r\n\t\tif (fun.type.isSimple)\r\n\t\t\tthrow this.error(`${fun.name} is not callable`);\r\n\r\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tvar resolvedType = fun.type.resolve(),\r\n\t\t\tparamTypes = resolvedType.from,\r\n\t\t\targTypes = args.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(argTypes[i]))\r\n\t\t\t\tthrow this.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t\t}\r\n\t\t\r\n\t\tthis.fun = fun;\r\n\t\tthis.type = resolvedType.to;\r\n\t\tthis.args = args;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps) || this.fun.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (args.join('').length <= 50) {\r\n\t\t\targs = this.args.map(arg => {\r\n\t\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\targs = args.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.fun._type != 'fun' || !this.fun.name ? '(' + this.fun.toIndentedString(indent) + ')' : this.fun.name}(`,\r\n\t\t\t\targs,\r\n\t\t\t\t')'\r\n\t\t\t].join('');\r\n\t\t} else {\r\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.fun._type != 'fun' || !this.fun.name ? '(' + this.fun.toIndentedString(indent) + ')' : this.fun.name}(`,\r\n\t\t\t\t'\\t' + args,\r\n\t\t\t\t')'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (this.fun instanceof Fun)\r\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\r\n\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t});\r\n\r\n\t\treturn `${!this.fun.name || this.fun._type == 'typevar'\r\n\t\t\t\t? this.fun.toTeXString(false)\r\n\t\t\t\t: this.fun.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.fun.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.fun.name)}}`}`\r\n\t\t\t+ `(${args.join(', ')})`;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\nimport MetaType from './MetaType';\r\n\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Typevar from './Typevar';\r\n\r\ninterface SchemaArgumentable {\r\n\taxiomatic: boolean,\r\n\tname?: string,\r\n\tnative?: object,\r\n\tparams?: Typevar[],\r\n\texpr?: Node,\r\n\tdoc?: string\r\n}\r\n\r\nexport default class Schema extends Node {\r\n\tpublic readonly _type = 'schema';\r\n\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly native;\r\n\tpublic readonly params;\r\n\tpublic readonly expr;\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly proved: boolean;\r\n\r\n\tconstructor ({axiomatic, /* nullable */ name, native, params, expr, doc}: SchemaArgumentable, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\r\n\t\tif (typeof axiomatic != 'boolean') {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (name !== null && typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!native && !(expr.type instanceof Type || expr.type instanceof MetaType)) {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.name = name;\r\n\r\n\t\tif (native) {\r\n\t\t\tthis.native = native;\r\n\t\t\tthis.expr = null;\r\n\t\t\tthis.type = null;\r\n\t\t} else {\r\n\t\t\tif (!(params instanceof Array)\r\n\t\t\t\t\t|| params.map(e => e instanceof Typevar).some(e => !e))\r\n\t\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\t\tthis.params = params;\r\n\t\t\tthis.expr = expr;\r\n\t\t\tthis.type = new (expr.type instanceof Type ? Type : MetaType)({\r\n\t\t\t\tfunctional: true,\r\n\t\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\t\tto: expr.type\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.proved = this.isProved();\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn this.proved\r\n\t\t\t|| !this.native && super.isProved(hyps)\r\n\t\t\t|| this.axiomatic\r\n\t\t\t|| this.expr && this.expr.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (this.native)\r\n\t\t\treturn `∫ ${this.name} <native>`;\r\n\r\n\t\treturn [\r\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString()\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t`\\\\mapsto ${this.expr.toTeXString(false)}`,\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\r\n\t\tvar id = `schema-${this.proved ? 'p' : 'np'}-${this.name}`;\r\n\t\r\n\t\tif (!root)\r\n\t\t\treturn `\\\\href{#${id}}\\\\mathsf{${Node.escapeTeX(this.name)}}`;\r\n\t\r\n\t\tif (this.native)\r\n\t\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}`\r\n\t\t\t\t+ '\\\\ (\\\\textrm{native})';\r\n\t\r\n\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}(${this.params.map(e => e.toTeXString(Node.PREC_COMMA) + (e.guess ? `: \\\\texttt{@${e.guess}}` : '')).join(', ')}):`\r\n\t\t\t\t\t+ '\\\\\\\\\\\\quad' + ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(true);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport MetaType from './MetaType';\r\n\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\n\r\nexport default class Tee extends Node {\r\n\tpublic readonly _type = 'tee';\r\n\tpublic static precedence = Node.PREC_COMMA;\r\n\r\n\tpublic readonly left;\r\n\tpublic readonly right;\r\n\tpublic readonly type: MetaType;\r\n\r\n\tconstructor ({left, right}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\t\t\r\n\t\tif (!(left instanceof Array\r\n\t\t\t\t&& left.every(l => ['type', 'metatype'].includes(l.type._type)))) {\r\n\t\t\tconsole.log(left);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (!['type', 'metatype'].includes(right.type._type)) {\r\n\t\t\tconsole.log(right);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (right.type.isFunctional) {\r\n\t\t\tthrow this.error('RHS of a rule cannot be a schema');\r\n\t\t}\r\n\r\n\t\t// antecedent의 contraction\r\n\t\t// 현재 antecedent를 집합처럼 생각하므로 contraction을 자동으로 한다.\r\n\t\t// antecedent가 집합인지 시퀀스인지는 #14 참조.\r\n\t\tthis.left = left.reduce((l, r) => {\r\n\t\t\tfor (var i = 0; i < l.length; i++)\r\n\t\t\t\tif (ExpressionResolver.equals(l[i], r)) return l;\r\n\r\n\t\t\treturn l.push(r), l;\r\n\t\t}, []);\r\n\r\n\t\tthis.right = right;\r\n\r\n\t\tthis.type = new MetaType({\r\n\t\t\tfunctional: false,\r\n\t\t\tleft: left.map(e => e.type),\r\n\t\t\tright: right.type\r\n\t\t});\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.right.isProved(hyps.concat(this.left));\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (!this.left.length) {\r\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\r\n\t\t}\r\n\t\r\n\t\treturn [\r\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\r\n\t\t\t'|-',\r\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\n\r\nexport default class MetaType extends Node {\r\n\tpublic readonly _type = 'metatype';\r\n\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly left;\r\n\tpublic readonly right;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: MetaType;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tif (typeof o.functional != 'boolean')\r\n\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\r\n\t\tthis.isFunctional = o.functional;\r\n\t\tthis.isSimple = !o.functional;\r\n\r\n\t\tif (!o.functional) {\r\n\t\t\tif (!(o.left instanceof Array))\r\n\t\t\t\tthrow this.error('left should be an array');\r\n\r\n\t\t\tthis.left = o.left;\r\n\t\t\tthis.right = o.right;\r\n\t\t} else {\r\n\t\t\tif (o.from.some(f => !(f instanceof Type)))\r\n\t\t\t\tthrow this.error('o.from.some(f => !(f instanceof Type))');\r\n\t\t\tif (!(o.to instanceof MetaType))\r\n\t\t\t\tthrow this.error('!(o.to instanceof MetaType)');\r\n\r\n\t\t\tif (o.to.isFunctional)\r\n\t\t\t\tthrow this.error('Functional metatype in functional metatype is not supported');\r\n\r\n\t\t\tthis.from = o.from;\r\n\t\t\tthis.to = o.to;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic resolve() {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number) {\r\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\r\n\r\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tthrow new Error('Method not implemented.');\r\n\t}\r\n\r\n\tpublic equals(t) {\r\n\t\tif (!(t instanceof MetaType)) return false;\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) {\r\n\t\t\tif (this.left.length != t.left.length) return false;\r\n\r\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\r\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.right.equals(t.right)) return false;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (let i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport Node, { Precedence } from './Node';\r\n\r\nexport default class Ruleset extends Node {\r\n\tpublic readonly _type = 'ruleset';\r\n\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly native;\r\n\r\n\tconstructor ({axiomatic, name, native, doc}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!native)\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.name = name;\r\n\t\tthis.native = native || false;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps) || this.axiomatic;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `RS ${this.name}`\r\n\t\t\t+ (this.native ? ' <native>' : ' <error>');\r\n\t}\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `\\\\href{#ruleset-${this.name}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}`\r\n\t\t\t+ (this.native ? '\\\\ (\\\\textrm{native})' : '\\\\ (\\\\textit{error})');\r\n\t}\r\n}","var grammar;\r\n\r\nif (process.env.__webpack__) {\r\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\r\n} else {\r\n\tvar fs = require('fs');\r\n\tvar path = require('path');\r\n\r\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\r\n}\r\n\r\nvar Program = require('./Program').default;\r\n\r\nmodule.exports = {grammar, Program};","export default \"start =\\r\\n\\t_ lines:(a:line _ {return a})* {return lines}\\r\\n\\r\\nline =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defruleset\\r\\n\\t/ defschema\\r\\n\\r\\nevaluable =\\r\\n\\t_ e:evaluable_internal _ {return e}\\r\\n\\r\\nevaluable_internal =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defruleset\\r\\n\\t/ defschema\\r\\n\\t/ metaexpr\\r\\n\\r\\ntypedef =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tbase:(\\\"base\\\" __)?\\r\\n\\t\\\"type\\\" __\\r\\n\\torigin:(o:ftype __ {return o})?\\r\\n\\tname:ident _ sem\\r\\n\\t{\\r\\n\\t\\tdoc = doc && doc[0];\\r\\n\\t\\t\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'typedef',\\r\\n\\t\\t\\tdoc,\\r\\n\\t\\t\\tbase: !!base,\\r\\n\\t\\t\\torigin,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefv =\\r\\n\\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschemaparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\tguess:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\tguess,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n \\r\\ndefun =\\r\\n\\tdoc:(documentation __)?\\r\\n\\ttex:(tex __)?\\r\\n\\trettype:type __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\texpr:(\\r\\n\\t\\t\\\"{\\\" _\\r\\n\\t\\texpr:expr0 _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return expr}\\r\\n\\t\\t/ sem {return null}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defun',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\trettype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschema =\\r\\n\\t// native schemata\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"native\\\" __\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: true,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/\\r\\n\\t// non-native schemata\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defschemaparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"{\\\" _\\r\\n\\texpr:metaexpr _\\r\\n\\t\\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: false,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefruleset =\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"native\\\" __\\r\\n\\t\\\"ruleset\\\" __\\r\\n\\tname:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defruleset',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: true,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// var[...]\\r\\n// foo(...)[...]\\r\\n// foo[...][...]\\r\\n// (metaexpr)[...]\\r\\n// schema(?, ...)[...]\\r\\nreduction =\\r\\n\\tsubject:(\\r\\n\\t\\tschemacall\\r\\n\\t\\t/ var\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\tguesses:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:('?' {return null} / expr0) _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)?\\r\\n\\tleftargs:(\\r\\n\\t\\t\\\"[\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:metaexpr _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\"]\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)+\\r\\n\\t{\\r\\n\\t\\tvar ret = {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject,\\r\\n\\t\\t\\tguesses,\\r\\n\\t\\t\\tleftargs: leftargs[0],\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor (var i = 1; i < leftargs.length; i++) {\\r\\n\\t\\t\\tret = {\\r\\n\\t\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\t\\tsubject: ret,\\r\\n\\t\\t\\t\\tguesses: null,\\r\\n\\t\\t\\t\\tleftargs: leftargs[i],\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n\\r\\n// var(...)\\r\\n// (metaexpr)(...)\\r\\nschemacall =\\r\\n\\tschema:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemacall',\\r\\n\\t\\t\\tschema,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// forall(f, g)\\r\\n// (expr0)(f, g)\\r\\nfuncall =\\r\\n\\tfun:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:expr0 _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funcall',\\r\\n\\t\\t\\tfun,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => { expr0 }\\r\\nfunexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\t\\\"{\\\" _ expr:expr0 _ \\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => { metaexpr }\\r\\nschemaexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\t\\\"{\\\" _ expr:metaexpr _ \\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemaexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nmetaexpr =\\r\\n\\t// right associativity\\r\\n\\ta:(\\r\\n\\t\\tmetaexpr_internal_1\\r\\n\\t) _ \\\"~\\\" _ b:metaexpr\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject: {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\t\\tname: 'cut',\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tleftargs: [a, b],\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_1\\r\\n\\r\\nmetaexpr_internal_1 =\\r\\n\\tleft:(\\r\\n\\t\\tl:(\\r\\n\\t\\t\\thead:metaexpr_internal_2 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_2 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)? {return l || []}\\r\\n\\t)\\r\\n\\t\\\"|-\\\" _\\r\\n\\tright:metaexpr_internal_1\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'tee',\\r\\n\\t\\t\\tleft,\\r\\n\\t\\t\\tright,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_2\\r\\n\\r\\n/*\\r\\n * 다음이 성립하여야 한다.\\r\\n *\\r\\n * - reduction이 schemacall보다 앞이다.\\r\\n * - schemacall이 var보다 앞이다.\\r\\n *\\r\\n */\\r\\nmetaexpr_internal_2 =\\r\\n\\treduction\\r\\n\\t/ schemacall\\r\\n\\t/ var\\r\\n\\t/ schemaexpr\\r\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\r\\n\\r\\nexpr0 =\\r\\n\\tfuncall\\r\\n\\t/ funexpr\\r\\n\\t/ var\\r\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\r\\n\\r\\ntype =\\r\\n\\tstype\\r\\n\\t/ ftype\\r\\n\\r\\nstype =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: false,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nftype =\\r\\n\\t\\\"[\\\" _\\r\\n\\tfrom:(\\r\\n\\t\\ttype:type {return [type]}\\r\\n\\t\\t/ (\\r\\n\\t\\t\\ttt:(\\r\\n\\t\\t\\t\\t\\\"(\\\" _\\r\\n\\t\\t\\t\\thead: type\\r\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\r\\n\\t\\t\\t\\t_ \\\")\\\"\\r\\n\\t\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t\\t)\\r\\n\\t\\t\\t{return tt}\\r\\n\\t\\t)\\r\\n\\t) _\\r\\n\\t\\\"->\\\" _\\r\\n\\tto:type _\\r\\n\\t\\\"]\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: true,\\r\\n\\t\\t\\tfrom,\\r\\n\\t\\t\\tto,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nvar =\\r\\n\\trulesetName:(id:ident _ \\\".\\\" _ {return id})?\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn rulesetName\\r\\n\\t\\t\\t? {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'ruleset',\\r\\n\\t\\t\\t\\trulesetName,\\r\\n\\t\\t\\t\\tname,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t: {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\t\\tname,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t}\\r\\n\\t}\\r\\n\\r\\nkeyword =\\r\\n\\t\\\"axiomatic\\\"\\r\\n\\t/ \\\"base\\\"\\r\\n\\t/ \\\"native\\\"\\r\\n\\t/ \\\"ruleset\\\"\\r\\n\\t/ \\\"schema\\\"\\r\\n\\t/ \\\"type\\\";\\r\\n\\r\\nident =\\r\\n\\t$(!keyword [a-zA-Z0-9_]+)\\r\\n\\r\\ndocumentation =\\r\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ntex =\\r\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ncomment =\\r\\n\\t\\\"#\\\" (!newline .)*\\r\\n\\t/ \\\"//\\\" (!newline .)*\\r\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\r\\n\\r\\nnewline =\\r\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\r\\n\\r\\n// optional whitespace\\r\\n_ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\r\\n\\r\\n// mandatory whitespace\\r\\n__ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\r\\n\\r\\nsem =\\r\\n\\t\\\";\\\"\";","import Scope from './Scope';\r\nimport PegInterface from './PegInterface';\r\nimport ExpressionResolver from './ExpressionResolver';\r\n\r\nexport default class Program {\r\n\tpublic scope = new Scope(null);\r\n\r\n\tpublic ExpressionResolver = ExpressionResolver;\r\n\t\r\n\tconstructor() {}\r\n\r\n\tfeed(lines, nativeMap) {\r\n\t\tlines.forEach(line => {\r\n\t\t\tswitch (line._type) {\r\n\t\t\t\tcase 'typedef':\r\n\t\t\t\t\tvar type = PegInterface.type(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasType(type.name)) {\r\n\t\t\t\t\t\tthrow type.scope.error(`Type ${type.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addType(type);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defv':\r\n\t\t\t\t\tvar typevar = PegInterface.typevar(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasTypevar(typevar.name)) {\r\n\t\t\t\t\t\tthrow typevar.scope.error(`Definition ${typevar.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addTypevar(typevar);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defun':\r\n\t\t\t\t\tvar fun = PegInterface.fun(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasTypevar(fun.name)) {\r\n\t\t\t\t\t\tthrow fun.scope.error(`Definition ${fun.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addFun(fun);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defruleset':\r\n\t\t\t\t\tvar ruleset = PegInterface.ruleset(line, this.scope, nativeMap);\r\n\r\n\t\t\t\t\tif (this.scope.hasRuleset(ruleset.name)) {\r\n\t\t\t\t\t\tthrow ruleset.scope.error(`Ruleset ${ruleset.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addRuleset(ruleset);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defschema':\r\n\t\t\t\t\tvar schema = PegInterface.schema(line, this.scope, nativeMap);\r\n\r\n\t\t\t\t\tif (this.scope.hasSchema(schema.name)) {\r\n\t\t\t\t\t\tthrow schema.scope.error(`Schema ${schema.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addSchema(schema);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tevaluate(line) {\r\n\t\tswitch (line._type) {\r\n\t\t\tcase 'typedef':\r\n\t\t\tcase 'defv':\r\n\t\t\tcase 'defun':\r\n\t\t\tcase 'defruleset':\r\n\t\t\tcase 'defschema':\r\n\t\t\tcase 'tee':\r\n\t\t\tcase 'reduction':\r\n\t\t\tcase 'schemacall':\r\n\t\t\tcase 'var':\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PegInterface[({\r\n\t\t\t\t\ttypedef: 'type',\r\n\t\t\t\t\tdefv: 'typevar',\r\n\t\t\t\t\tdefun: 'fun',\r\n\t\t\t\t\tdefruleset: 'ruleset',\r\n\t\t\t\t\tdefschema: 'schema',\r\n\t\t\t\t\ttee: 'tee',\r\n\t\t\t\t\treduction: 'reduction',\r\n\t\t\t\t\tschemacall: 'schemacall',\r\n\t\t\t\t\tvar: 'metavar',\r\n\t\t\t\t\tschemaexpr: 'schemaexpr'\r\n\t\t\t\t})[line._type]](line, this.scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t}\r\n\t}\r\n}","import Type from './nodes/Type';\r\nimport Typevar from './nodes/Typevar';\r\nimport Fun from './nodes/Fun';\r\nimport Funcall from './nodes/Funcall';\r\nimport Tee from './nodes/Tee';\r\nimport Ruleset from './nodes/Ruleset';\r\nimport Schema from './nodes/Schema';\r\nimport Schemacall from './nodes/Schemacall';\r\n\r\nimport StackTrace from './StackTrace';\r\n\r\nexport default class Scope {\r\n\tpublic readonly typedefMap = {};\r\n\tpublic readonly defMap = {};\r\n\tpublic readonly schemaMap = {};\r\n\tpublic readonly rulesetMap = {};\r\n\r\n\tpublic readonly parent: Scope;\r\n\tpublic readonly root: Scope;\r\n\r\n\tpublic readonly trace: StackTrace;\r\n\tpublic baseType: Type;\r\n\r\n\tpublic readonly Type = Type;\r\n\tpublic readonly Typevar = Typevar;\r\n\tpublic readonly Fun = Fun;\r\n\tpublic readonly Funcall = Funcall;\r\n\tpublic readonly Tee = Tee;\r\n\tpublic readonly Ruleset = Ruleset;\r\n\tpublic readonly Schema = Schema;\r\n\tpublic readonly Schemacall = Schemacall;\r\n\r\n\tconstructor (parent: Scope, trace?: StackTrace) {\r\n\t\tthis.parent = parent;\r\n\t\tthis.root = parent ? parent.root : this;\r\n\r\n\t\tif (trace && !(trace instanceof StackTrace)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.trace = trace || new StackTrace();\r\n\r\n\t\tthis.baseType = parent ? parent.baseType : null;\r\n\t}\r\n\r\n\tpublic extend(type, name, location) {\r\n\t\treturn new Scope(this, this.trace.extend(type, name, location));\r\n\t}\r\n\r\n\tpublic error(message: string) {\r\n\t\treturn this.trace.error(message);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasOwnType(name) {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn !!this.typedefMap[name];\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasOwnType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasType(name) {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.hasOwnType(name)\r\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\tpublic addType(type: Type) {\r\n\t\tif (!(type instanceof Type))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!type.name)\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\r\n\t\tif (this.hasOwnType(type.name))\r\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\r\n\r\n\t\tif (type.isBaseType) {\r\n\t\t\tif (this.baseType) {\r\n\t\t\t\tthrow this.error('A base type already exists');\r\n\t\t\t}\r\n\r\n\t\t\t(function broadcast(scope: Scope) {\r\n\t\t\t\tscope.baseType = type;\r\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\r\n\t\t\t})(this);\r\n\t\t}\r\n\r\n\t\treturn this.typedefMap[type.name] = type;\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic getType(name) {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\tif (!this.hasType(name))\r\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\r\n\r\n\t\t\treturn this.typedefMap[name] ||\r\n\t\t\t\t(!!this.parent && this.parent.getType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\r\n\t\t\treturn this.getType(e);\r\n\t\t});\r\n\r\n\t\tvar to = this.getType(name[name.length - 1]);\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom,\r\n\t\t\tto\r\n\t\t});\r\n\t}\r\n\r\n\tpublic hasOwnTypevar(name) {\r\n\t\treturn !!this.defMap[name];\r\n\t}\r\n\r\n\tpublic hasTypevar(name) {\r\n\t\treturn this.hasOwnTypevar(name) ||\r\n\t\t\t(!!this.parent && this.parent.hasTypevar(name));\r\n\t}\r\n\r\n\tpublic addTypevar(typevar) {\r\n\t\tif (!(typevar instanceof Typevar))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnTypevar(typevar.name))\r\n\t\t\tthrow this.error(`Definition ${typevar.name} has already been declared`);\r\n\r\n\t\treturn this.defMap[typevar.name] = typevar;\r\n\t}\r\n\r\n\tpublic addFun(fun) {\r\n\t\tif (!(fun instanceof Fun))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!fun.name)\r\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\r\n\r\n\t\tif (this.hasOwnTypevar(fun.name))\r\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\r\n\r\n\t\treturn this.defMap[fun.name] = fun;\r\n\t}\r\n\r\n\tpublic getTypevar(name) {\r\n\t\tif (!this.hasTypevar(name))\r\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\r\n\r\n\t\treturn this.defMap[name] ||\r\n\t\t\t(!!this.parent && this.parent.getTypevar(name));\r\n\t}\r\n\r\n\tpublic hasOwnRuleset(name) {\r\n\t\treturn !!this.rulesetMap[name];\r\n\t}\r\n\r\n\tpublic hasRuleset(name) {\r\n\t\treturn this.hasOwnRuleset(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasRuleset(name));\r\n\t}\r\n\r\n\tpublic addRuleset(ruleset) {\r\n\t\tif (!(ruleset instanceof Ruleset))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnRuleset(ruleset.name))\r\n\t\t\tthrow this.error(`Ruleset ${ruleset.name} has already been declared`);\r\n\r\n\t\treturn this.rulesetMap[ruleset.name] = ruleset;\r\n\t}\r\n\r\n\tpublic getRuleset(name) {\r\n\t\tif (!this.hasRuleset(name))\r\n\t\t\tthrow this.error(`Ruleset ${name} is not defined`);\r\n\r\n\t\treturn this.rulesetMap[name] ||\r\n\t\t\t(!!this.parent && this.parent.getRuleset(name));\r\n\t}\r\n\r\n\tpublic hasOwnSchema(name) {\r\n\t\treturn !!this.schemaMap[name] || !!this.defMap[name];\r\n\t}\r\n\r\n\tpublic hasSchema(name) {\r\n\t\treturn this.hasOwnSchema(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\r\n\t}\r\n\r\n\tpublic addSchema(schema) {\r\n\t\tif (!(schema instanceof Schema))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnSchema(schema.name))\r\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\r\n\r\n\t\treturn this.schemaMap[schema.name] = schema;\r\n\t}\r\n\r\n\tpublic getSchema(name) {\r\n\t\tif (!this.hasSchema(name))\r\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\r\n\r\n\t\treturn this.schemaMap[name] || this.defMap[name] ||\r\n\t\t\t(!!this.parent && this.parent.getSchema(name));\r\n\t}\r\n}","export default class StackTrace {\r\n\tpublic readonly stack: any[];\r\n\r\n\tconstructor (stack?: any[]) {\r\n\t\tthis.stack = stack || [];\r\n\t}\r\n\r\n\tpublic extend(type, name, location) {\r\n\t\treturn new StackTrace([[type, name, location]].concat(this.stack));\r\n\t}\r\n\r\n\tpublic error(message: string) {\r\n\t\tvar filename = typeof process != 'undefined' && process.argv[2];\r\n\r\n\t\treturn new Error(\r\n\t\t\tmessage\r\n\t\t\t+ '\\n\\tat '\r\n\t\t\t+ (\r\n\t\t\t\tthis.stack.length\r\n\t\t\t\t\t? this.stack.map(([type, name, location]) => {\r\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${filename || '<unknown>'}:${location.start.line}:${location.start.column})`;\r\n\t\t\t\t\t}).join('\\n\\tat ')\r\n\t\t\t\t\t: `<root> (${filename || '<unknown>'}:1:1)`\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\r\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\r\n * PEG.js의 출력은 여기에서만 처리해야 한다.\r\n */\r\n\r\nimport Type from './nodes/Type';\r\nimport Typevar from './nodes/Typevar';\r\nimport Fun from './nodes/Fun';\r\nimport Funcall from './nodes/Funcall';\r\nimport Tee from './nodes/Tee';\r\nimport Ruleset from './nodes/Ruleset';\r\nimport Schema from './nodes/Schema';\r\nimport Schemacall from './nodes/Schemacall';\r\nimport Reduction from './nodes/Reduction';\r\n\r\nimport ExpressionResolver from './ExpressionResolver';\r\nimport { DefrulesetObject, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject } from './PegInterfaceDefinitions';\r\nimport Scope from './Scope';\r\n\r\nfunction typeObjToString(obj: TypeObject): string {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) return (obj as StypeObject).name;\r\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\r\n\t\t\t+ typeObjToString(obj.to) + ']';\r\n}\r\n\r\n/*\r\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\r\n * st\t\t\t\t\t\t-> 'st'\r\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\r\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\r\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\r\n */\r\nfunction typeObjToNestedArr(obj: TypeObject) {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) {\r\n\t\tobj = obj as StypeObject;\r\n\r\n\t\tif (!obj.name)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.name;\r\n\t} else {\r\n\t\tif (!obj.from || !obj.to)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\r\n\t\t\t[typeObjToNestedArr(obj.to)]\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction varObjToString(obj: VarObject): string {\r\n\tswitch (obj.type) {\r\n\t\tcase 'ruleset':\r\n\t\t\treturn `${obj.rulesetName}.${obj.name}`;\r\n\t\tcase 'normal':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\r\n\t}\r\n}\r\n\r\nexport default class PI {\r\n\tpublic static type(obj: TypedefObject, parentScope: Scope): Type {\r\n\t\tif (obj._type != 'typedef')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\r\n\r\n\t\tvar origin: Type = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\r\n\r\n\t\tvar name: string = obj.name;\r\n\t\tvar doc: string = obj.doc;\r\n\t\tvar base: boolean = obj.base;\r\n\r\n\t\tif (base && origin) {\r\n\t\t\tthrow scope.error('Base type should not be an alias');\r\n\t\t}\r\n\r\n\t\tif (origin) {\r\n\t\t\treturn new Type({\r\n\t\t\t\tname,\r\n\t\t\t\tdoc,\r\n\t\t\t\tbase,\r\n\t\t\t\torigin\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: false,\r\n\t\t\tname,\r\n\t\t\tdoc,\r\n\t\t\tbase\r\n\t\t});\r\n\t}\r\n\r\n\tpublic static typevar(obj: DefvObject | VarObject, parentScope: Scope): Typevar {\r\n\t\tif (!['defv', 'var'].includes(obj._type)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('typevar', obj.name, obj.location);\r\n\r\n\t\tif (obj._type == 'var') {\r\n\t\t\tif (!scope.hasTypevar(obj.name))\r\n\t\t\t\tthrow scope.error(`Undefined identifier ${obj.name}`);\r\n\t\t\treturn scope.getTypevar(obj.name);\r\n\t\t}\r\n\r\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\r\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\r\n\r\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\r\n\r\n\t\treturn new Typevar({\r\n\t\t\ttype,\r\n\t\t\tisParam: !!obj.isParam,\r\n\t\t\tguess: obj.guess || null,\r\n\t\t\tname: obj.name,\r\n\t\t\tdoc: obj.doc,\r\n\t\t\ttex: obj.tex\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): Fun {\r\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name = null,\r\n\t\t\tdoc = null,\r\n\t\t\ttex = null;\r\n\r\n\t\tif (obj._type == 'defun') {\r\n\t\t\tobj = obj as DefunObject\r\n\t\t\tname = obj.name;\r\n\t\t\tdoc = obj.doc;\r\n\t\t\ttex = obj.tex;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('fun', name, obj.location);\r\n\r\n\t\tvar type = null;\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.typevar(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnTypevar(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\r\n\t\t\treturn scope.addTypevar(tv);\r\n\t\t});\r\n\t\tvar expr = null;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'defun':\r\n\t\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\r\n\t\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\r\n\r\n\t\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\r\n\r\n\t\t\t\tif (obj.expr) {\r\n\t\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\t\tif (!rettype.equals(expr.type))\r\n\t\t\t\t\t\tthrow scope.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = new Type({\r\n\t\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\t\t\t\tto: rettype\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\ttype = null;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn new Fun({name, type, params, expr, doc, tex}, scope);\r\n\t}\r\n\r\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope) {\r\n\t\tif (obj._type != 'funcall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.fun ? obj.fun.name : null, obj.location);\r\n\r\n\t\tvar fun = PI.expr0(obj.fun, scope);\r\n\r\n\t\tvar args = obj.args.map(arg => {\r\n\t\t\treturn PI.expr0(arg, scope);\r\n\t\t});\r\n\r\n\t\treturn new Funcall({fun, args}, scope);\r\n\t}\r\n\r\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope) {\r\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PI.tee(obj, scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PI.reduction(obj, scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PI.schemacall(obj, scope);\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PI.schema(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.metavar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope) {\r\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\r\n\t\t\tconsole.log(obj);\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'funcall':\r\n\t\t\t\treturn PI.funcall(obj, scope);\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\treturn PI.fun(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.typevar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static metavar(obj: VarObject, parentScope: Scope) {\r\n\t\tif (obj._type != 'var')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj.type) {\r\n\t\t\tcase 'ruleset':\r\n\t\t\t\tif (!scope.hasRuleset(obj.rulesetName))\r\n\t\t\t\t\tthrow scope.error(`Ruleset ${obj.rulesetName} is not defined`);\r\n\r\n\t\t\t\tvar ruleset = scope.getRuleset(obj.rulesetName);\r\n\r\n\t\t\t\tif (!ruleset.native)\r\n\t\t\t\t\tthrow scope.error('Behavior undefined for non-native rulesets');\r\n\r\n\t\t\t\tvar schema = ruleset.native.get(obj.name, scope);\r\n\r\n\t\t\t\tif (!schema)\r\n\t\t\t\t\tthrow scope.error(`Schema ${varObjToString(obj)} is not defined`);\r\n\t\t\t\t\r\n\t\t\t\treturn schema;\r\n\t\t\tcase 'normal':\r\n\t\t\t\tif (!scope.hasSchema(obj.name))\r\n\t\t\t\t\tthrow scope.error(`Schema ${obj.name} is not defined`);\r\n\r\n\t\t\t\treturn scope.getSchema(obj.name);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static tee(obj: TeeObject, parentScope: Scope) {\r\n\t\tif (obj._type != 'tee')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\r\n\r\n\t\tvar foo = obj => PI.metaexpr(obj, scope);\r\n\r\n\t\tvar left = obj.left.map(foo);\r\n\t\tvar right = foo(obj.right);\r\n\r\n\t\treturn new Tee({left, right}, scope);\r\n\t}\r\n\r\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope, nativeMap?) {\r\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tnativeMap = nativeMap || {};\r\n\r\n\t\tvar name = null, axiomatic = false, doc = null;\r\n\r\n\t\tif (obj._type == 'defschema') {\r\n\t\t\tname = obj.name; axiomatic = obj.axiomatic;\r\n\t\t\tdoc = obj.doc;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\r\n\r\n\t\tif (obj._type == 'defschema' && obj.native) {\r\n\t\t\tif (!nativeMap.schema[name])\r\n\t\t\t\tthrow scope.error(`Native code for native schema ${name} not found`);\r\n\r\n\t\t\tvar native = {\r\n\t\t\t\tget: args => nativeMap.schema[name].get(args, scope, ExpressionResolver)\r\n\t\t\t};\r\n\r\n\t\t\treturn new Schema({axiomatic, name, native, doc: obj.doc}, scope);\r\n\t\t}\r\n\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.typevar(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnTypevar(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\t\t\t\r\n\t\t\treturn scope.addTypevar(tv);\r\n\t\t});\r\n\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new Schema({axiomatic, name, params, expr, doc}, scope);\r\n\t}\r\n\r\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope) {\r\n\t\tif (obj._type != 'schemacall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar schema = PI.metaexpr(obj.schema, scope);\r\n\r\n\t\tif (schema.type._type == 'type') {\r\n\t\t\treturn PI.funcall({\r\n\t\t\t\t_type: 'funcall',\r\n\t\t\t\tfun: obj.schema as any,\r\n\t\t\t\targs: obj.args,\r\n\t\t\t\tlocation: obj.location\r\n\t\t\t}, parentScope);\r\n\t\t}\r\n\r\n\t\tvar args = obj.args.map(obj => {\r\n\t\t\treturn PI.expr0(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Schemacall({\r\n\t\t\tschema,\r\n\t\t\targs\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static ruleset(obj: DefrulesetObject, parentScope: Scope, nativeMap?) {\r\n\t\tif (obj._type != 'defruleset')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tnative = native || {};\r\n\r\n\t\tvar scope = parentScope.extend('ruleset', obj.name, obj.location);\r\n\r\n\t\tvar axiomatic = obj.axiomatic;\r\n\t\tvar name = obj.name;\r\n\r\n\t\tif (!obj.native)\r\n\t\t\tthrow scope.error('Assertion failed');\r\n\r\n\t\tif (!nativeMap.ruleset[name])\r\n\t\t\tthrow scope.error(`Native code for native ruleset ${name} not found`);\r\n\r\n\t\tvar native = nativeMap.ruleset[name];\r\n\r\n\t\treturn new Ruleset({axiomatic, name, native, doc: obj.doc}, scope);\r\n\t}\r\n\r\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope) {\r\n\t\tif (obj._type != 'reduction')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\r\n\r\n\t\tvar subject = PI.metaexpr(obj.subject, scope);\r\n\r\n\t\tvar guesses = !obj.guesses\r\n\t\t\t? null\r\n\t\t\t: obj.guesses.map(g => {\r\n\t\t\t\treturn g && PI.expr0(g, scope);\r\n\t\t\t});\r\n\r\n\t\tvar leftargs = obj.leftargs.map(obj => {\r\n\t\t\treturn PI.metaexpr(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Reduction({\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs\r\n\t\t}, scope);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Schemacall from './Schemacall';\r\n\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\n\r\nexport default class Reduction extends Node {\r\n\tpublic readonly _type = 'reduction';\r\n\r\n\tpublic readonly subject;\r\n\tpublic readonly guesses;\r\n\tpublic readonly leftargs;\r\n\tpublic readonly reduced;\r\n\tpublic readonly type;\r\n\r\n\tconstructor ({subject, guesses, leftargs}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (!subject.native && subject._type == 'schema') {\r\n\t\t\tsubject.params.forEach((p, i) => {\r\n\t\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\r\n\t\t\t\t\tthrow this.error(`Argument #${i + 1} could not be guessed`);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t\tvar derefs = subject.params.map((p, i) => {\r\n\t\t\t\tif (guesses && guesses[i]) return guesses[i];\r\n\t\r\n\t\t\t\treturn this.query(\r\n\t\t\t\t\tp.guess,\r\n\t\t\t\t\tExpressionResolver.expandMeta(subject.expr).left,\r\n\t\t\t\t\tleftargs\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\r\n\t\t\tsubject = new Schemacall({\r\n\t\t\t\tschema: subject,\r\n\t\t\t\targs: derefs,\r\n\t\t\t}, scope);\r\n\t\t} else if (guesses) {\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\t\t}\r\n\t\r\n\t\tif (!subject.native\r\n\t\t\t\t&& !(subject.type._type == 'metatype' && subject.type.isSimple))\r\n\t\t\tthrow this.error('Subject is not reducible');\r\n\t\r\n\t\tif (!(leftargs instanceof Array)\r\n\t\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.subject = subject;\r\n\t\tthis.leftargs = leftargs;\r\n\t\r\n\t\tif (subject.native) {\r\n\t\t\tthis.reduced = subject.native.get(leftargs);\r\n\t\t\tthis.type = this.reduced.type;\r\n\t\t} else {\r\n\t\t\tvar paramTypes = subject.type.left,\r\n\t\t\t\tleftargTypes = leftargs.map(e => e.type);\r\n\t\r\n\t\t\tif (paramTypes.length != leftargTypes.length)\r\n\t\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`);\r\n\t\r\n\t\t\tfor (let i = 0; i < paramTypes.length; i++) {\r\n\t\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\r\n\t\t\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.type = subject.type.right;\r\n\t\r\n\t\t\tvar tee = ExpressionResolver.expandMetaAndFuncalls(subject);\r\n\t\r\n\t\t\tif (tee._type != 'tee') {\r\n\t\t\t\tthrow this.error('Assertion failed');\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (let i = 0; i < tee.left.length; i++) {\r\n\t\t\t\tif (!ExpressionResolver.equals(tee.left[i], leftargs[i])) {\r\n\t\t\t\t\tthrow this.error(`LHS #${i + 1} failed to match:\r\n\r\n--- EXPECTED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(tee.left[i])}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(leftargs[i])}\r\n----------------`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.reduced = tee.right;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.subject.isProved(hyps)\r\n\t\t\t\t&& this.leftargs.every(l => l.isProved(hyps));\r\n\t}\r\n\r\n\tpublic query(guess, left, leftargs) {\r\n\t\tif (guess.length == 0) throw this.error('wut');\r\n\r\n\t\tif (!(1 <= guess[0] * 1 && guess[0] * 1 <= leftargs.length))\r\n\t\t\tthrow this.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\r\n\t\tvar lef = left[guess[0] * 1 - 1];\r\n\t\tvar ret = leftargs[guess[0] * 1 - 1];\r\n\r\n\t\tvar that = this;\r\n\r\n\t\treturn (function recurse(guess, lef, node, ptr) {\r\n\t\t\tnode = ExpressionResolver.expandMetaAndFuncalls(node);\r\n\t\t\t\r\n\t\t\tif (guess.length <= ptr) return node;\r\n\r\n\t\t\tif (/[0-9]/.test(guess[ptr])) {\r\n\t\t\t\tvar n = guess[ptr] * 1;\r\n\r\n\t\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\t\tif (lef.left.length != node.left.length) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent length mismatch`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(1 <= n && n <= node.left.length)) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recurse(guess, lef.left[n - 1], node.left[n - 1], ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tif (!lef.fun || !node.fun) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ExpressionResolver.equals(lef.fun, node.fun)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!node.fun.expr) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = ExpressionResolver.expandCallOnce(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.args || !(1 <= n && n <= node.args.length))\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\r\n\t\t\t\treturn recurse(guess, lef.args[n - 1], node.args[n - 1], ptr + 1);\r\n\t\t\t} else if (guess[ptr] == 'r') {\r\n\t\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\t\treturn recurse(guess, lef.right, node.right, ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t}\r\n\r\n\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t})(guess, lef, ret, 1);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar leftargs = this.leftargs.map(arg => {\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (leftargs.join('').length <= 50) {\r\n\t\t\tleftargs = this.leftargs.map(arg => {\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\tleftargs = leftargs.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\tleftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\t'\\t' + leftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\r\n\t}\r\n}"],"sourceRoot":""}