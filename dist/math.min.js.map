{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/nodes/Typevar.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Schema.ts","webpack://math/./src/ExpressionResolver.ts","webpack://math/./src/nodes/Schemacall.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/nodes/Ruleset.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/$var.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts","webpack://math/./node_modules/process/browser.js","webpack://math/./src/PegInterface.ts","webpack://math/./src/nodes/Reduction.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","scope","_id","toIndentedString","message","error","Error","replace","tex","precedence","code","match","g1","hyps","length","prec","Array","console","log","my","normalizePrecedence","your","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","Typevar","type","isParam","guess","doc","super","_type","isProved","toSimpleString","indent","escapeTeX","Type","isBaseType","base","origin","isFunctional","isSimple","functional","from","map","f","some","e","to","resolved","resolve","join","toTeXString","equals","Schema","shouldValidate","axiomatic","native","params","def$s","expr","parseTeX","typevar","proved","repeat","expandMetaAndFuncalls","funcallToTeXString","arg","makeTeX","iscall","a","callee","schema","makecall","ER","substitute","has","left","right","reduced","Map","set","expandCallOnce","callee_","expandMeta","b","recurseWrap","recurse","depth","every","_","placeholders","len","push","nequalscall","nequalstrue","tees","tee","reduceRight","newleft","slice","concat","nrecursecall","nrecursetrue","Schemacall","resolvedType","paramTypes","argTypes","Tee","includes","$","reduce","expanded","Ruleset","MetaType","$var","grammar","default","Program","nativeMap","ruleset","tt","vars","nullary","arityMap","forEach","usedVars","fill","stack","lastIsFull","token","indexOf","pop","filter","parsed","collen","functionMap","N","A","q","O","I","E","varTable","j","constTable","T","F","getColumn","columns","column","col","baseType","typevars","typevarMap","keys","k","v","hasTypevar","getTypevar","funcall","cut","rules","chain","mpu","rule","lines","line","hasType","addType","addTypevar","fun","addFun","hasRuleset","addRuleset","hasSchema","addSchema","typedef","defv","defun","defruleset","defschema","reduction","schemacall","var","schemaexpr","ktx","DIAMOND","schemaMap","theexpr","ncols","Math","max","leftargs","subject","getHtmlLine","h1","h2","bbb","padding","htmlLeft","exprToHtml","expand","tree","getTree","hypnumMap","$Map","num","leftarglines","leftargnums","subjectlines","subjectnum","schemalines","$lines","$num","leftlines","start","rightlines","html","tree2html","Scope","parent","trace","typedefMap","defMap","rulesetMap","hypotheses","location","child","extend","h","hasOwnType","broadcast","getType","hasOwnTypevar","hasOwnRuleset","getRuleset","hasOwnSchema","getSchema","hasOwn$","has$","get$","StackTrace","filename","process","argv","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","runClearTimeout","marker","Item","array","noop","nextTick","arguments","apply","title","browser","env","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","typeObjToString","obj","ftype","typeObjToNestedArr","PI","parentScope","tvo","tv","rettype","expr0","metavar","hypnum","Number","rulesetName","varObjToString","metaexpr","scopeRight","$v","def$","add$","guesses","g","Reduction","derefs","query","leftargTypes","lef","that","node","ptr","test"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","var ctr = 0;\r\n\r\nexport type Precedence = boolean | number | [number, number];\r\n\r\ninterface Nodeable {\r\n\ttoIndentedString: (indent: number, root?: boolean) => string;\r\n\ttoTeXString: (prec?: Precedence, root?: boolean) => string;\r\n\tisProved: (hyps) => boolean;\r\n}\r\n\r\nexport default abstract class Node implements Nodeable {\r\n\tpublic readonly _id: number;\r\n\tpublic readonly scope: Scope;\r\n\r\n\tpublic type: Type | MetaType;\r\n\tpublic doc: string;\r\n\tpublic tex: string;\r\n\tpublic precedence: Precedence;\r\n\r\n\tpublic static readonly PREC_FUNEXPR = 1000;\r\n\tpublic static readonly PREC_COMMA = 1000;\r\n\tpublic static readonly PREC_COLONEQQ = 100000;\r\n\r\n\tconstructor (scope?: Scope) {\r\n\t\tthis._id = ++ctr;\r\n\t\tthis.scope = scope;\r\n\t}\r\n\r\n\tpublic toString() {\r\n\t\treturn this.toIndentedString(0);\r\n\t}\r\n\r\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\r\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\r\n\r\n\tpublic error(message) {\r\n\t\tif (this.scope) {\r\n\t\t\treturn this.scope.error(message);\r\n\t\t} else {\r\n\t\t\treturn new Error(message);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static escapeTeX(s) {\r\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\r\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\r\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\r\n\t\t\t'}': '\\\\}',\r\n\t\t\t'~': '\\\\textasciitilde',\r\n\t\t\t'^': '\\\\textasciicircum',\r\n\t\t\t'\\\\': '\\\\textbackslash'\r\n\t\t})[m]);\r\n\t}\r\n\r\n\tpublic static parseTeX(tex) {\r\n\t\tvar precedence: Precedence = false;\r\n\r\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\r\n\t\t\tprecedence = g1 * 1;\r\n\t\t\treturn '';\r\n\t\t});\r\n\r\n\t\treturn {precedence, code};\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\r\n\t\tfor (var i = 0; i < hyps.length; i++) {\r\n\t\t\tif (hyps[i] == this) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t* false corresponds to 0.\r\n\t* true corresponds to w * 2.\r\n\t*/\r\n\tpublic static normalizePrecedence(prec: Precedence) {\r\n\t\tif (prec === false) return [0, 0];\r\n\t\tif (prec === true) return [2, 0];\r\n\t\tif (typeof prec == 'number') return [0, prec];\r\n\r\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\r\n\t\t\tconsole.log(prec);\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn prec;\r\n\t}\r\n\r\n\tpublic shouldConsolidate(prec: Precedence) {\r\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\r\n\t\t\tyour = Node.normalizePrecedence(prec || false);\r\n\r\n\t\tif (my[0] == 0 && my[1] == 0) return false;\r\n\r\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\r\n\t}\r\n\r\n\tpublic makeTeX(id, args, prec) {\r\n\t\targs = args || [];\r\n\t\tprec = prec || false;\r\n\t\t\r\n\t\tvar ret = this.tex;\r\n\r\n\t\tif (this.shouldConsolidate(prec)) {\r\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\r\n\t\t}\r\n\r\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\r\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\r\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\r\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// 순환 참조를 피하기 위하여 export 후 import 한다.\r\nimport ExpressionResolver from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';","import Scope from '../Scope';\r\nimport Node, {Precedence} from './Node';\r\nimport Type from './Type';\r\n\r\ninterface TypevarArgumentType {\r\n\ttype: Type,\r\n\tisParam: boolean,\r\n\tguess?: string,\r\n\tname: string,\r\n\tdoc?: string,\r\n\ttex?: string\r\n}\r\n\r\nexport default class Typevar extends Node {\r\n\tpublic readonly _type = 'typevar';\r\n\r\n\tpublic readonly isParam: boolean;\r\n\tpublic readonly guess: string;\r\n\tpublic readonly type: Type;\r\n\tpublic readonly name: string;\r\n\r\n\tconstructor ({type, isParam, guess, name, doc, tex}: TypevarArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\t\tthis.tex = tex;\r\n\r\n\t\tthis.isParam = !!isParam;\r\n\t\tthis.guess = guess || null;\r\n\r\n\t\ttype = type as Type;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.type = type;\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps);\r\n\t}\r\n\r\n\t// pr f\r\n\tpublic toSimpleString() {\r\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\r\n\r\n\t\tvar tex = this.tex\r\n\t\t\t|| (\r\n\t\t\t\tthis.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.name)}}`\r\n\t\t\t);\r\n\t\t\r\n\t\treturn `\\\\href{#${id}}{${tex}}`;\r\n\t}\r\n}","import Node from './Node';\r\n\r\nexport default class Type extends Node {\r\n\tpublic readonly _type = 'type';\r\n\r\n\tpublic readonly isBaseType: boolean;\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly origin: Type;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: Type;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tthis.doc = o.doc;\r\n\t\tthis.isBaseType = !!o.base;\r\n\r\n\t\tif (o.origin) {\r\n\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\tthis.name = o.name;\r\n\r\n\t\t\tif (!(o.origin instanceof Type))\r\n\t\t\t\tthrow this.error('!(o.origin instanceof Type)');\r\n\r\n\t\t\tthis.isFunctional = o.origin.isFunctional;\r\n\t\t\tthis.isSimple = o.origin.isSimple;\r\n\t\t\tthis.origin = o.origin;\r\n\t\t} else {\r\n\t\t\tif (typeof o.functional != 'boolean')\r\n\t\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\tthis.isFunctional = o.functional;\r\n\t\t\tthis.isSimple = !o.functional;\r\n\r\n\t\t\tif (!o.functional) {\r\n\t\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\t\tthis.name = o.name;\r\n\t\t\t} else {\r\n\t\t\t\tif (o.from.map(f => f instanceof Type).some(e => !e))\r\n\t\t\t\t\tthrow this.error('o.from.map(f => f instanceof Type).some(e => !e)');\r\n\t\t\t\tif (!(o.to instanceof Type))\r\n\t\t\t\t\tthrow this.error('!(o.to instanceof Type)');\r\n\r\n\t\t\t\tthis.from = o.from;\r\n\t\t\t\tthis.to = o.to;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toSimpleString() {\r\n\t\tif (this.name) return this.name;\r\n\r\n\t\tvar resolved = this.resolve();\r\n\r\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent): string {\r\n\t\tif (this.isSimple) return this.name;\r\n\r\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(root?: boolean) {\r\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\r\n\t\tif (!root && this.name) {\r\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\t\t}\r\n\r\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\r\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\r\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\r\n\t}\r\n\r\n\tpublic resolve(): Type {\r\n\t\treturn this.origin ? this.origin.resolve() : this;\r\n\t}\r\n\r\n\tpublic equals(t: object): boolean {\r\n\t\tif (!(t instanceof Type)) return false;\r\n\r\n\t\tif (this.origin) return this.origin.equals(t);\r\n\t\tif (t.origin) return this.equals(t.origin);\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) return this === t;\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (var i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\nimport MetaType from './MetaType';\r\n\r\nimport ExpressionResolver, { Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Typevar from './Typevar';\r\nimport $var from './$var';\r\n\r\ninterface SchemaArgumentType {\r\n\tshouldValidate: boolean;\r\n\taxiomatic?: boolean;\r\n\ttype?: Type | MetaType;\r\n\tname?: string;\r\n\tnative?: object;\r\n\tparams?: (Typevar | Schema)[];\r\n\tdef$s?: $var[];\r\n\texpr?: Metaexpr;\r\n\tdoc?: string;\r\n\ttex?: string;\r\n}\r\n\r\nexport default class Schema extends Node {\r\n\tpublic readonly _type = 'schema';\r\n\r\n\tpublic readonly shouldValidate;\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly native;\r\n\tpublic readonly params;\r\n\tpublic readonly def$s: $var[];\r\n\tpublic readonly expr: Metaexpr;\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly proved: boolean;\r\n\r\n\t/*\r\n\t * name, expr 중 하나 이상 있어야 하고 type, native, expr 중\r\n\t * 한 개만 있어야 한다.\r\n\t */\r\n\tconstructor ({doc, tex, shouldValidate, axiomatic, type, /* nullable */ name, native, params, def$s, expr}: SchemaArgumentType, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\t\tthis.shouldValidate = shouldValidate;\r\n\r\n\t\tif (tex) {\r\n\t\t\tvar {precedence, code} = Node.parseTeX(tex);\r\n\r\n\t\t\tthis.precedence = precedence;\r\n\t\t\tthis.tex = code;\r\n\t\t} else {\r\n\t\t\tthis.precedence = false;\r\n\t\t\tthis.tex = null;\r\n\t\t}\r\n\r\n\t\tif (!name && !native && !expr)\r\n\t\t\tthrow this.error('Anonymous fun cannot be primitive');\r\n\r\n\t\tif (type && expr || expr && native || native && type)\r\n\t\t\tthrow this.error('no');\r\n\r\n\t\tif (!type && !native && !expr)\r\n\t\t\tthrow this.error('Cannot guess the type of a primitive fun');\r\n\r\n\t\tif (name !== null && typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!native && expr && !(expr.type instanceof Type || expr.type instanceof MetaType)) {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.name = name;\r\n\r\n\t\tif (native) {\r\n\t\t\tthis.native = native;\r\n\t\t\tthis.def$s = [];\r\n\t\t\tthis.expr = null;\r\n\t\t\tthis.type = null;\r\n\t\t} else {\r\n\t\t\tif (!(params instanceof Array)\r\n\t\t\t\t\t|| params.map(e => e instanceof Typevar).some(e => !e))\r\n\t\t\t\tthrow this.error('Assertion failed');\r\n\t\t\t\r\n\t\t\tif (expr !== null && !(expr instanceof Node))\r\n\t\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\t\tthis.type = type || new (expr.type instanceof Type ? Type : MetaType)({\r\n\t\t\t\tfunctional: true,\r\n\t\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\t\tto: expr.type\r\n\t\t\t});\r\n\r\n\t\t\tthis.params = params;\r\n\t\t\tthis.def$s = def$s || [];\r\n\t\t\tthis.expr = expr;\r\n\t\t}\r\n\r\n\t\tthis.proved = this.isProved();\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn this.proved\r\n\t\t\t|| !this.native && super.isProved(hyps)\r\n\t\t\t|| this.axiomatic\r\n\t\t\t|| this.expr && this.expr.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (this.native)\r\n\t\t\treturn `∫ ${this.name} <native>`;\r\n\r\n\t\treturn [\r\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\r\n\t\t\t'}'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (!this.name) {\r\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\r\n\t\t\treturn [\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t\t(\r\n\t\t\t\t\tthis.params.length == 1\r\n\t\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t\t),\r\n\t\t\t\t`\\\\mapsto ${ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(false)}`,\r\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t\t].join('');\r\n\t\t}\r\n\r\n\t\tif (!this.shouldValidate) {\r\n\t\t\tif (!root)\r\n\t\t\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${Node.escapeTeX(this.name)}}`;\r\n\t\t\r\n\t\t\tif (!this.expr)\r\n\t\t\t\treturn this.funcallToTeXString(this.params, prec);\r\n\t\t\r\n\t\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\r\n\t\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\r\n\t\t} else {\r\n\t\t\tvar id = `schema-${this.proved ? 'p' : 'np'}-${this.name}`;\r\n\t\t\r\n\t\t\tif (!root)\r\n\t\t\t\treturn `\\\\href{#${id}}\\\\mathsf{${Node.escapeTeX(this.name)}}`;\r\n\t\t\r\n\t\t\tif (this.native)\r\n\t\t\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}`\r\n\t\t\t\t\t+ '\\\\ (\\\\textrm{native})';\r\n\t\t\r\n\t\t\treturn `\\\\href{#${id}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}(${this.params.map(e => e.toTeXString(Node.PREC_COMMA) + (e.guess ? `: \\\\texttt{@${e.guess}}` : '')).join(', ')}):`\r\n\t\t\t\t\t\t+ '\\\\\\\\\\\\quad' + ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(true);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic funcallToTeXString(args, prec) {\r\n\t\targs = args.map(arg => {\r\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\r\n\t\t});\r\n\t\r\n\t\tif (this.tex) {\r\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\r\n\t\t}\r\n\t\r\n\t\treturn `${!this.name\r\n\t\t\t\t? this.toTeXString(false)\r\n\t\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? Node.escapeTeX(this.name) : `\\\\mathrm{${Node.escapeTeX(this.name)}}`}}`}`\r\n\t\t\t+ `(${args.join(', ')})`;\r\n\t}\r\n}","export type Expr0 = Schemacall | Schema | Typevar;\r\nexport type Metaexpr = Tee | Reduction | Schemacall | Schema | $var | Expr0;\r\n\r\nfunction iscall(a: Metaexpr): a is Schemacall {\r\n\treturn a._type == 'schemacall';\r\n}\r\n\r\nfunction callee(a: Metaexpr) {\r\n\tif (iscall(a)) return a.schema;\r\n\r\n\tconsole.log(a);\r\n\tthrow Error();\r\n}\r\n\r\nfunction makecall(a: Metaexpr, args: Expr0[]): Schemacall {\r\n\tif (a._type == 'typevar' || a._type == 'schema') {\r\n\t\treturn new Schemacall({\r\n\t\t\tschema: a,\r\n\t\t\targs\r\n\t\t});\r\n\t}\r\n\r\n\tconsole.log(a);\r\n\tthrow Error();\r\n}\r\n\r\nexport default class ER {\r\n\tpublic static substitute(expr: Metaexpr, map: Map<Typevar | Schema, Expr0>): Metaexpr {\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn new Schemacall({\r\n\t\t\t\t\tschema: ER.substitute(expr.schema, map),\r\n\t\t\t\t\targs: expr.args.map(arg => ER.substitute(arg, map))\r\n\t\t\t\t});\r\n\t\t\tcase 'schema':\r\n\t\t\t\tif (!expr.expr) return map.get(expr) || expr;\r\n\r\n\t\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\t\tif (expr.name) return map.get(expr) || expr;\r\n\r\n\t\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\tshouldValidate: expr.shouldValidate,\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.substitute(expr.expr, map)\r\n\t\t\t\t});\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn map.get(expr) || expr;\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(e => ER.substitute(e, map));\r\n\t\t\t\tvar right = ER.substitute(expr.right, map);\r\n\r\n\t\t\t\treturn new Tee({\r\n\t\t\t\t\tleft, right\r\n\t\t\t\t});\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.substitute(expr.reduced, map);\r\n\t\t\tcase '$var':\r\n\t\t\t\treturn ER.substitute(expr.expr, map);\r\n\t\t\tdefault:\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tthrow Error(`Unknown type ${expr._type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static call(callee: Metaexpr, args: Expr0[]): Metaexpr {\r\n\t\tif (callee._type != 'schema') {\r\n\t\t\tconsole.log(callee);\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (!callee.expr) {\r\n\t\t\tthrow Error('Cannot call a callable without a body');\r\n\t\t}\r\n\r\n\t\tif (callee.params.length != args.length) {\r\n\t\t\tthrow Error('Illegal arguments length');\r\n\t\t}\r\n\r\n\t\tvar map = new Map();\r\n\r\n\t\tfor (var i = 0; i < callee.params.length; i++) {\r\n\t\t\tmap.set(callee.params[i], args[i]);\r\n\t\t}\r\n\r\n\t\treturn ER.substitute(callee.expr, map);\r\n\t}\r\n\r\n\tpublic static expandCallOnce(expr: Metaexpr): Metaexpr {\r\n\t\tif (!iscall(expr)) {\r\n\t\t\tthrow Error('Illegal type');\r\n\t\t}\r\n\r\n\t\tif (iscall(callee(expr))) {\r\n\t\t\tvar schema = ER.expandCallOnce(callee(expr));\r\n\t\t\treturn makecall(schema, expr.args);\r\n\t\t}\r\n\r\n\t\tvar callee_ = callee(expr);\r\n\r\n\t\tif (callee_._type != 'schema') {\r\n\t\t\tthrow Error('Something\\'s wrong');\r\n\t\t}\r\n\r\n\t\tif (!callee_.expr) {\r\n\t\t\tthrow Error('Could not expand');\r\n\t\t}\r\n\r\n\t\treturn ER.call(callee_, expr.args);\r\n\t}\r\n\r\n\t// expand0은 하지 않는다.\r\n\tpublic static expandMeta(expr: Metaexpr): Metaexpr {\r\n\t\tif ('native' in expr && expr.native) {\r\n\t\t\treturn expr;\r\n\t\t}\r\n\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(ER.expandMeta);\r\n\t\t\t\tvar right = ER.expandMeta(expr.right);\r\n\r\n\t\t\t\treturn new Tee({left, right});\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\tvar schema = ER.expandMeta(expr.schema),\r\n\t\t\t\t\targs = expr.args;\r\n\t\t\t\t\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\tif (!schema.expr || schema.name && !schema.shouldValidate)\r\n\t\t\t \t\treturn new Schemacall({schema, args});\r\n\r\n\t\t\t\treturn ER.expandMeta(ER.call(schema, args));\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.expandMeta(expr.reduced);\r\n\t\t\tcase 'schema':\r\n\t\t\t\tif (!expr.expr) return expr;\r\n\t\t\t\tif (expr.type._type == 'type' && expr.name) return expr;\r\n\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\tshouldValidate: expr.shouldValidate,\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.expandMeta(expr.expr)\r\n\t\t\t\t});\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn expr;\r\n\t\t\tcase '$var':\r\n\t\t\t\treturn ER.expandMeta(expr.expr);\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(expr);\r\n\t\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\t// expr0의 이름 없는 funcall까지 풀음.\r\n\tpublic static expandMetaAndFuncalls(expr: Metaexpr) {\r\n\t\tswitch (expr._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\tvar left = expr.left.map(ER.expandMetaAndFuncalls);\r\n\t\t\t\tvar right = ER.expandMetaAndFuncalls(expr.right);\r\n\r\n\t\t\t\treturn new Tee({left, right});\r\n\t\t\tcase 'schema':\r\n\t\t\t\tif (!expr.expr) return expr;\r\n\t\t\t\tif (expr.type._type == 'type' && expr.name) return expr;\r\n\r\n\t\t\t\treturn new Schema({\r\n\t\t\t\t\tshouldValidate: expr.shouldValidate,\r\n\t\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tparams: expr.params,\r\n\t\t\t\t\texpr: ER.expandMetaAndFuncalls(expr.expr)\r\n\t\t\t\t});\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\tvar schema = ER.expandMetaAndFuncalls(expr.schema);\r\n\t\t\t\tvar args = expr.args.map(ER.expandMetaAndFuncalls);\r\n\r\n\t\t\t\tif (!schema.expr || schema.name && !schema.shouldValidate)\r\n\t\t\t \t\treturn new Schemacall({schema, args});\r\n\r\n\t\t\t\treturn ER.expandMetaAndFuncalls(ER.call(schema, args));\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn ER.expandMetaAndFuncalls(expr.reduced);\r\n\t\t\tcase 'typevar':\r\n\t\t\t\treturn expr;\r\n\t\t\tcase '$var':\r\n\t\t\t\treturn ER.expandMetaAndFuncalls(expr.expr);\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(expr);\r\n\t\t\t\tthrow Error('Unknown metaexpr');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static nequalscall = 0;\r\n\tpublic static nequalstrue = 0;\r\n\tpublic static nrecursecall = 0;\r\n\tpublic static nrecursetrue = 0;\r\n\r\n\t/*\r\n\t * 스펙 참조.\r\n\t */\r\n\tpublic static equals(a: Metaexpr, b: Metaexpr) {\r\n\t\tfunction recurse(a: Metaexpr, b: Metaexpr, depth: number) {\r\n\t\t\tif (a == b) return true;\r\n\r\n\t\t\tif (!a.type.equals(b.type)) return false;\r\n\r\n\t\t\tif (a._type == 'reduction') {\r\n\t\t\t\treturn recurseWrap(a.reduced, b, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (b._type == 'reduction') {\r\n\t\t\t\treturn recurseWrap(a, b.reduced, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (a._type == '$var') {\r\n\t\t\t\treturn recurseWrap(a.expr, b, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (b._type == '$var') {\r\n\t\t\t\treturn recurseWrap(a, b.expr, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a) && iscall(b)) {\r\n\t\t\t\tif (iscall(callee(a))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (iscall(callee(b))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (callee(a) == callee(b) || !callee(a).expr && !callee(b).expr) {\r\n\t\t\t\t\tif (callee(a) != callee(b)) return false;\r\n\r\n\t\t\t\t\tif (!callee(a).expr && !callee(b).expr) {\r\n\t\t\t\t\t\tfor (var i = 0; i < a.args.length; i++) {\r\n\t\t\t\t\t\t\tif (!recurseWrap(a.args[i], b.args[i], depth + 1)) return false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (a.args.every((_, i) => {\r\n\t\t\t\t\t\treturn recurseWrap(a.args[i], (b as Schemacall).args[i], depth + 1);\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (callee(a).expr) {\r\n\t\t\t\t\treturn recurseWrap(ER.expandCallOnce(a), b, depth + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a, ER.expandCallOnce(b), depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(a)) {\r\n\t\t\t\tif (iscall(callee(a))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!callee(a).expr) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tER.expandCallOnce(a), b, depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (iscall(b)) {\r\n\t\t\t\tif (iscall(callee(b))) {\r\n\t\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!callee(b).expr) return false;\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\ta, ER.expandCallOnce(b), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (a._type == 'tee') {\r\n\t\t\t\tb = b as Tee;\r\n\r\n\t\t\t\tfor (var i = 0; i < a.left.length; i++) {\r\n\t\t\t\t\tif (!recurseWrap(a.left[i], b.left[i], depth + 1)) return false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(a.right, b.right, depth + 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (a.type.isFunctional) {\r\n\t\t\t\tvar placeholders = [];\r\n\t\t\t\tvar len = a.type.resolve().from.length;\r\n\r\n\t\t\t\tfor (var i = 0; i < len; i++) {\r\n\t\t\t\t\tplaceholders.push(new Typevar({\r\n\t\t\t\t\t\tisParam: true,\r\n\t\t\t\t\t\ttype: a.type.resolve().from[i],\r\n\t\t\t\t\t\tname: '$' + i\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurseWrap(\r\n\t\t\t\t\tmakecall(a, placeholders), makecall(b, placeholders), depth + 1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar recurseWrap = recurse;\r\n\r\n\t\t// function recurseWrap(a, b, depth) {\r\n\t\t// \tER.nrecursecall++;\r\n\r\n\t\t// \tconsole.log(`depth ${depth}\\n${a}\\n\\n${b}`);\r\n\t\t// \tvar ret = recurse(a, b, depth);\r\n\t\t// \tconsole.log(`depth ${depth} → ${ret}`);\r\n\r\n\t\t// \tif (ret) ER.nrecursetrue++;\r\n\r\n\t\t// \treturn ret;\r\n\t\t// }\r\n\r\n\t\tER.nequalscall++;\r\n\t\tvar ret = recurseWrap(a, b, 0);\r\n\t\tif (ret) ER.nequalstrue++;\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic static chain(tees: Tee[]) {\r\n\t\tif (!tees.every(tee => tee._type == 'tee')) {\r\n\t\t\tthrow Error('no');\r\n\t\t}\r\n\r\n\t\treturn ER.expandMetaAndFuncalls(tees.reduceRight((r, l) => {\r\n\t\t\tfor (var i = 0; i < r.left.length; i++) {\r\n\t\t\t\tif (ER.equals(l.right, r.left[i])) {\r\n\t\t\t\t\tvar newleft = r.left.slice(0, i)\r\n\t\t\t\t\t\t.concat(l.left)\r\n\t\t\t\t\t\t.concat(r.left.slice(i + 1));\r\n\r\n\t\t\t\t\treturn new Tee({\r\n\t\t\t\t\t\tleft: newleft,\r\n\t\t\t\t\t\tright: r.right\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthrow Error(`Chaining failed:\r\n\r\n--- LEFT ---\r\n${l}\r\n------------\r\n\r\n--- RIGHT ---\r\n${r}\r\n-------------`);\r\n\t\t}));\r\n\t}\r\n}\r\n\r\n// 순환 참조를 피하기 위하여 export 후 import 한다.\r\nimport $var from \"./nodes/$var\";\r\nimport Reduction from \"./nodes/Reduction\";\r\nimport Schema from \"./nodes/Schema\";\r\nimport Schemacall from \"./nodes/Schemacall\";\r\nimport Tee from \"./nodes/Tee\";\r\nimport Typevar from \"./nodes/Typevar\";","import Node, { Precedence } from './Node';\r\nimport Typevar from './Typevar';\r\nimport MetaType from './MetaType';\r\nimport Type from './Type';\r\nimport Scope from '../Scope';\r\nimport Schema from './Schema';\r\n\r\nexport default class Schemacall extends Node {\r\n\tpublic readonly _type = 'schemacall';\r\n\r\n\tpublic readonly type: Type | MetaType;\r\n\tpublic readonly schema;\r\n\tpublic readonly args;\r\n\r\n\tconstructor ({schema, args}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (schema.type.isSimple)\r\n\t\t\tthrow this.error(`${schema.name} is not callable`);\r\n\r\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\t \r\n\t\tvar resolvedType = schema.type.resolve(),\r\n\t\t\tparamTypes = resolvedType.from,\r\n\t\t\targTypes = args.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != argTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\r\n\t\t\t\tthrow this.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.schema = schema;\r\n\t\tthis.type = resolvedType.to;\r\n\t\tthis.args = args;\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.schema.isProved(hyps);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (args.join('').length <= 50) {\r\n\t\t\targs = this.args.map(arg => {\r\n\t\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\targs = args.join(', ');\r\n\t\r\n\t\t\tif (this.schema.shouldValidate) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t`${this.schema.name || `(${this.schema})`}(`,\r\n\t\t\t\t\targs,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('');\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t`${this.schema._type != 'schema' || !this.schema.name ? '(' + this.schema.toIndentedString(indent) + ')' : this.schema.name}(`,\r\n\t\t\t\t\targs,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('');\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\t\t\r\n\t\t\tif (this.schema.shouldValidate) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t`${this.schema.name || `(${this.schema.toIndentedString(indent)})`}(`,\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\t`${this.schema._type != 'schema' || !this.schema.name ? '(' + this.schema.toIndentedString(indent) + ')' : this.schema.name}(`,\r\n\t\t\t\t\t'\\t' + args,\r\n\t\t\t\t\t')'\r\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tif (this.schema.shouldValidate) {\r\n\t\t\treturn (\r\n\t\t\t\tthis.schema.name\r\n\t\t\t\t\t? `\\\\href{#schema-${this.schema.proved ? 'p' : 'np'}-${this.schema.name}}{\\\\textsf{${Node.escapeTeX(this.schema.name)}}}`\r\n\t\t\t\t\t: this.schema.toTeXString(false)\r\n\t\t\t) + `(${this.args.map(arg => {\r\n\t\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t\t}).join(', ')})`;\r\n\t\t}\r\n\r\n\t\tif (this.schema instanceof Schema)\r\n\t\t\treturn this.schema.funcallToTeXString(this.args, prec);\r\n\t\t\r\n\t\tvar args = this.args.map(arg => {\r\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\r\n\t\t});\r\n\r\n\t\treturn `${!this.schema.name || this.schema._type == 'typevar'\r\n\t\t\t\t? this.schema.toTeXString(false)\r\n\t\t\t\t: this.schema.name.length == 1\r\n\t\t\t\t\t? Node.escapeTeX(this.schema.name)\r\n\t\t\t\t\t: `\\\\mathrm{${Node.escapeTeX(this.schema.name)}}`}`\r\n\t\t\t+ `(${args.join(', ')})`;\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport MetaType from './MetaType';\r\n\r\nimport ExpressionResolver, { Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport $var from './$var';\r\n\r\ninterface TeeInput {\r\n\tleft: Metaexpr[];\r\n\tdef$s?: $var[];\r\n\tright: Metaexpr;\r\n}\r\n\r\nexport default class Tee extends Node {\r\n\tpublic readonly _type = 'tee';\r\n\tpublic precedence = Node.PREC_COMMA;\r\n\r\n\tpublic readonly left;\r\n\tpublic readonly def$s: $var[];\r\n\tpublic readonly right;\r\n\tpublic readonly type: MetaType;\r\n\r\n\tconstructor ({left, def$s, right}: TeeInput, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\t\t\r\n\t\tif (!(left instanceof Array\r\n\t\t\t\t&& left.every(l => ['type', 'metatype'].includes(l.type._type)))) {\r\n\t\t\tconsole.log(left);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $._type == '$var')))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!['type', 'metatype'].includes(right.type._type)) {\r\n\t\t\tconsole.log(right);\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tif (right.type.isFunctional) {\r\n\t\t\tthrow this.error('RHS of a rule cannot be a schema');\r\n\t\t}\r\n\r\n\t\t// antecedent의 contraction\r\n\t\t// 현재 antecedent를 집합처럼 생각하므로 contraction을 자동으로 한다.\r\n\t\t// antecedent가 집합인지 시퀀스인지는 #14 참조.\r\n\t\tthis.left = left.reduce((l, r) => {\r\n\t\t\tfor (var i = 0; i < l.length; i++)\r\n\t\t\t\tif (ExpressionResolver.equals(l[i], r)) return l;\r\n\r\n\t\t\treturn l.push(r), l;\r\n\t\t}, []);\r\n\r\n\t\tthis.def$s = def$s || [];\r\n\r\n\t\tthis.right = right;\r\n\r\n\t\tthis.type = new MetaType({\r\n\t\t\tfunctional: false,\r\n\t\t\tleft: left.map(e => e.type),\r\n\t\t\tright: right.type\r\n\t\t});\r\n\t}\r\n\r\n\tpublic isProved(hyps?) {\r\n\t\thyps = hyps || [];\r\n\t\r\n\t\treturn super.isProved(hyps) || this.right.isProved(hyps.concat(this.left));\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tif (!this.left.length) {\r\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\r\n\t\t}\r\n\t\r\n\t\treturn [\r\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\r\n\t\t\t'|-',\r\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n\t\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tvar expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n}","import Scope from '../Scope';\r\nimport Node, { Precedence } from './Node';\r\n\r\nexport default class Ruleset extends Node {\r\n\tpublic readonly _type = 'ruleset';\r\n\r\n\tpublic readonly axiomatic: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly native;\r\n\r\n\tconstructor ({axiomatic, name, native, doc}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tthis.doc = doc;\r\n\r\n\t\tif (typeof name != 'string')\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tif (!native)\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.axiomatic = axiomatic;\r\n\t\tthis.name = name;\r\n\t\tthis.native = native || false;\r\n\t}\r\n\r\n\tpublic isProved(hyps) {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps) || this.axiomatic;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\treturn `RS ${this.name}`\r\n\t\t\t+ (this.native ? ' <native>' : ' <error>');\r\n\t}\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `\\\\href{#ruleset-${this.name}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}`\r\n\t\t\t+ (this.native ? '\\\\ (\\\\textrm{native})' : '\\\\ (\\\\textit{error})');\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Type from './Type';\r\n\r\nexport default class MetaType extends Node {\r\n\tpublic readonly _type = 'metatype';\r\n\r\n\tpublic readonly isFunctional: boolean;\r\n\tpublic readonly isSimple: boolean;\r\n\tpublic readonly name: string;\r\n\tpublic readonly left;\r\n\tpublic readonly right;\r\n\tpublic readonly from: Type[];\r\n\tpublic readonly to: MetaType;\r\n\r\n\tconstructor (o) {\r\n\t\tsuper();\r\n\r\n\t\tif (typeof o.functional != 'boolean')\r\n\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\t\r\n\t\tthis.isFunctional = o.functional;\r\n\t\tthis.isSimple = !o.functional;\r\n\r\n\t\tif (!o.functional) {\r\n\t\t\tif (!(o.left instanceof Array))\r\n\t\t\t\tthrow this.error('left should be an array');\r\n\r\n\t\t\tthis.left = o.left;\r\n\t\t\tthis.right = o.right;\r\n\t\t} else {\r\n\t\t\tif (o.from.some(f => !(f instanceof Type)))\r\n\t\t\t\tthrow this.error('o.from.some(f => !(f instanceof Type))');\r\n\t\t\tif (!(o.to instanceof MetaType))\r\n\t\t\t\tthrow this.error('!(o.to instanceof MetaType)');\r\n\r\n\t\t\tif (o.to.isFunctional)\r\n\t\t\t\tthrow this.error('Functional metatype in functional metatype is not supported');\r\n\r\n\t\t\tthis.from = o.from;\r\n\t\t\tthis.to = o.to;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic resolve() {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number) {\r\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\r\n\r\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\tthrow new Error('Method not implemented.');\r\n\t}\r\n\r\n\tpublic equals(t: object): boolean {\r\n\t\tif (!(t instanceof MetaType)) return false;\r\n\r\n\t\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\t\tif (this.isSimple) {\r\n\t\t\tif (this.left.length != t.left.length) return false;\r\n\r\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\r\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.right.equals(t.right)) return false;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.from.length != t.from.length) return false;\r\n\r\n\t\tfor (let i = 0; i < this.from.length; i++)\r\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\t\treturn this.to.equals(t.to);\r\n\t}\r\n}","import { Metaexpr } from \"../ExpressionResolver\";\r\nimport Scope from \"../Scope\";\r\nimport MetaType from \"./MetaType\";\r\nimport Node, { Precedence } from \"./Node\";\r\nimport Type from \"./Type\";\r\n\r\ninterface $varInput {\r\n    name: string;\r\n    expr: Metaexpr;\r\n}\r\n\r\nexport default class $var extends Node {\r\n    public readonly _type = '$var';\r\n\r\n    public readonly type: Type | MetaType;\r\n    public readonly name: string;\r\n    public readonly expr: Metaexpr;\r\n\r\n    constructor({name, expr}: $varInput, scope?: Scope) {\r\n        super(scope);\r\n\r\n        if (!name || !expr) {\r\n            throw this.error('Assertion failed');\r\n        }\r\n\r\n        this.type = expr.type;\r\n        this.name = name;\r\n        this.expr = expr;\r\n    }\r\n\r\n    public isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.expr.isProved(hyps);\r\n\t}\r\n\r\n    public toIndentedString(indent: number, root?: boolean): string {\r\n        return this.name;\r\n    }\r\n    \r\n    public toTeXString(prec?: Precedence, root?: boolean): string {\r\n        return `\\\\mathtt{${Node.escapeTeX(this.name)}}`;\r\n    }\r\n\r\n}","var grammar;\r\n\r\nif (process.env.__webpack__) {\r\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\r\n} else {\r\n\tvar fs = require('fs');\r\n\tvar path = require('path');\r\n\r\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\r\n}\r\n\r\nvar Program = require('./Program').default;\r\n\r\nmodule.exports = {grammar, Program};","export default \"start =\\r\\n\\t_ lines:(a:line _ {return a})* {return lines}\\r\\n\\r\\nline =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defruleset\\r\\n\\t/ defschema\\r\\n\\r\\nevaluable =\\r\\n\\t_ e:evaluable_internal _ {return e}\\r\\n\\r\\nevaluable_internal =\\r\\n\\ttypedef\\r\\n\\t/ defv\\r\\n\\t/ defun\\r\\n\\t/ defruleset\\r\\n\\t/ defschema\\r\\n\\t/ metaexpr\\r\\n\\r\\ntypedef =\\r\\n\\tdoc:(documentation __)?\\r\\n\\tbase:(\\\"base\\\" __)?\\r\\n\\t\\\"type\\\" __\\r\\n\\torigin:(o:ftype __ {return o})?\\r\\n\\tname:ident _ sem\\r\\n\\t{\\r\\n\\t\\tdoc = doc && doc[0];\\r\\n\\t\\t\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'typedef',\\r\\n\\t\\t\\tdoc,\\r\\n\\t\\t\\tbase: !!base,\\r\\n\\t\\t\\torigin,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefv =\\r\\n\\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschemaparam =\\r\\n\\ttex:(tex __)? type:type __ name:ident\\r\\n\\tguess:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defv',\\r\\n\\t\\t\\tisParam: true,\\r\\n\\t\\t\\tguess,\\r\\n\\t\\t\\ttype,\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n \\r\\ndefun =\\r\\n\\tdoc:(documentation __)?\\r\\n\\ttex:(tex __)?\\r\\n\\trettype:type __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\texpr:(\\r\\n\\t\\t\\\"{\\\" _\\r\\n\\t\\texpr:expr0 _\\r\\n\\t\\t\\\"}\\\"\\r\\n\\t\\t{return expr}\\r\\n\\t\\t/ sem {return null}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defun',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\ttex: tex && tex[0],\\r\\n\\t\\t\\trettype,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefschema =\\r\\n\\t// native schemata\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"native\\\" __\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: true,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/\\r\\n\\t// non-native schemata\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"schema\\\" __\\r\\n\\tname:ident _\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defschemaparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"{\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\texpr:metaexpr _\\r\\n\\t\\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defschema',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: false,\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndefruleset =\\r\\n\\tdoc:(documentation __)?\\r\\n\\taxiomatic:(\\\"axiomatic\\\" __)?\\r\\n\\t\\\"native\\\" __\\r\\n\\t\\\"ruleset\\\" __\\r\\n\\tname:ident _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'defruleset',\\r\\n\\t\\t\\tdoc: doc && doc[0],\\r\\n\\t\\t\\taxiomatic: !!axiomatic,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tnative: true,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// var[...]\\r\\n// foo(...)[...]\\r\\n// foo[...][...]\\r\\n// (metaexpr)[...]\\r\\n// schema(?, ...)[...]\\r\\nreduction =\\r\\n\\tsubject:(\\r\\n\\t\\tschemacall\\r\\n\\t\\t/ var\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\tguesses:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:('?' {return null} / expr0) _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)?\\r\\n\\tleftargs:(\\r\\n\\t\\t\\\"[\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:metaexpr _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\"]\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)+\\r\\n\\t{\\r\\n\\t\\tvar ret = {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject,\\r\\n\\t\\t\\tguesses,\\r\\n\\t\\t\\tleftargs: leftargs[0],\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor (var i = 1; i < leftargs.length; i++) {\\r\\n\\t\\t\\tret = {\\r\\n\\t\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\t\\tsubject: ret,\\r\\n\\t\\t\\t\\tguesses: null,\\r\\n\\t\\t\\t\\tleftargs: leftargs[i],\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n\\r\\n// var(...)\\r\\n// (metaexpr)(...)\\r\\nschemacall =\\r\\n\\tschema:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:metaexpr _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemacall',\\r\\n\\t\\t\\tschema,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// forall(f, g)\\r\\n// (expr0)(f, g)\\r\\nfuncall =\\r\\n\\tschema:(\\r\\n\\t\\tvar\\r\\n\\t\\t/ \\\"(\\\" _\\r\\n\\t\\te:expr0 _\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return e}\\r\\n\\t) _\\r\\n\\targs:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\ta:(\\r\\n\\t\\t\\thead:expr0 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\"\\r\\n\\t\\t{return a || []}\\r\\n\\t)\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funcall',\\r\\n\\t\\t\\tschema,\\r\\n\\t\\t\\targs,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => { expr0 }\\r\\nfunexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\t\\\"{\\\" _ expr:expr0 _ \\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'funexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n// (T t) => { metaexpr }\\r\\nschemaexpr =\\r\\n\\tparams:(\\r\\n\\t\\t\\\"(\\\" _\\r\\n\\t\\tp:(\\r\\n\\t\\t\\thead:defparam _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)?\\r\\n\\t\\t\\\")\\\" _\\r\\n\\t\\t{return p || []}\\r\\n\\t)\\r\\n\\t\\\"=>\\\" _\\r\\n\\t\\\"{\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\texpr:metaexpr _\\r\\n\\t\\\"}\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'schemaexpr',\\r\\n\\t\\t\\tparams,\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nmetaexpr =\\r\\n\\t// right associativity\\r\\n\\ta:(\\r\\n\\t\\tmetaexpr_internal_1\\r\\n\\t) _ \\\"~\\\" _ b:metaexpr\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'reduction',\\r\\n\\t\\t\\tsubject: {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\t\\tname: 'cut',\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tleftargs: [a, b],\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_1\\r\\n\\r\\nmetaexpr_internal_1 =\\r\\n\\tleft:(\\r\\n\\t\\tl:(\\r\\n\\t\\t\\thead:metaexpr_internal_2 _\\r\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_2 _ {return e})*\\r\\n\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t)? {return l || []}\\r\\n\\t)\\r\\n\\t\\\"|-\\\" _\\r\\n\\tdefdollars: (d:defdollar _ {return d})* _\\r\\n\\tright:metaexpr_internal_1\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'tee',\\r\\n\\t\\t\\tdef$s: defdollars,\\r\\n\\t\\t\\tleft,\\r\\n\\t\\t\\tright,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/ metaexpr_internal_2\\r\\n\\r\\n/*\\r\\n * 다음이 성립하여야 한다.\\r\\n *\\r\\n * - reduction이 schemacall보다 앞이다.\\r\\n * - schemacall이 var보다 앞이다.\\r\\n *\\r\\n */\\r\\nmetaexpr_internal_2 =\\r\\n\\treduction\\r\\n\\t/ schemacall\\r\\n\\t/ var\\r\\n\\t/ schemaexpr\\r\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\r\\n\\r\\nexpr0 =\\r\\n\\tfuncall\\r\\n\\t/ funexpr\\r\\n\\t/ var\\r\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\r\\n\\r\\ndefdollar =\\r\\n\\tname:dollar_ident _\\r\\n\\t'=' _\\r\\n\\texpr:metaexpr _\\r\\n\\tsem\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'def$',\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\texpr,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\r\\ntype =\\r\\n\\tstype\\r\\n\\t/ ftype\\r\\n\\r\\nstype =\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: false,\\r\\n\\t\\t\\tname,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nftype =\\r\\n\\t\\\"[\\\" _\\r\\n\\tfrom:(\\r\\n\\t\\ttype:type {return [type]}\\r\\n\\t\\t/ (\\r\\n\\t\\t\\ttt:(\\r\\n\\t\\t\\t\\t\\\"(\\\" _\\r\\n\\t\\t\\t\\thead: type\\r\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\r\\n\\t\\t\\t\\t_ \\\")\\\"\\r\\n\\t\\t\\t\\t{return [head].concat(tail)}\\r\\n\\t\\t\\t)\\r\\n\\t\\t\\t{return tt}\\r\\n\\t\\t)\\r\\n\\t) _\\r\\n\\t\\\"->\\\" _\\r\\n\\tto:type _\\r\\n\\t\\\"]\\\"\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'type',\\r\\n\\t\\t\\tftype: true,\\r\\n\\t\\t\\tfrom,\\r\\n\\t\\t\\tto,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nvar =\\r\\n\\tat_var\\r\\n\\t/ dollar_var\\r\\n\\t/ plain_var\\r\\n\\r\\nat_var =\\r\\n\\tname:at_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '@',\\r\\n\\t\\t\\tname: name.slice(1),\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\ndollar_var =\\r\\n\\tname:dollar_ident\\r\\n\\t{\\r\\n\\t\\treturn {\\r\\n\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\ttype: '$',\\r\\n\\t\\t\\tname: name,\\r\\n\\t\\t\\tlocation: location()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nplain_var =\\r\\n\\trulesetName:(id:ident _ \\\".\\\" _ {return id})?\\r\\n\\tname:ident\\r\\n\\t{\\r\\n\\t\\treturn rulesetName\\r\\n\\t\\t\\t? {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'ruleset',\\r\\n\\t\\t\\t\\trulesetName,\\r\\n\\t\\t\\t\\tname,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t: {\\r\\n\\t\\t\\t\\t_type: 'var',\\r\\n\\t\\t\\t\\ttype: 'normal',\\r\\n\\t\\t\\t\\tname,\\r\\n\\t\\t\\t\\tlocation: location()\\r\\n\\t\\t\\t}\\r\\n\\t}\\r\\n\\r\\nkeyword =\\r\\n\\t\\\"axiomatic\\\"\\r\\n\\t/ \\\"base\\\"\\r\\n\\t/ \\\"native\\\"\\r\\n\\t/ \\\"ruleset\\\"\\r\\n\\t/ \\\"schema\\\"\\r\\n\\t/ \\\"type\\\";\\r\\n\\r\\nident =\\r\\n\\t$(!keyword [a-zA-Z0-9_]+)\\r\\n\\r\\nat_ident =\\r\\n\\t$('@' [a-zA-Z0-9_]+)\\r\\n\\r\\ndollar_ident =\\r\\n\\t$('$' [a-zA-Z0-9_]+)\\r\\n\\r\\ndocumentation =\\r\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ntex =\\r\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\r\\n\\t\\treturn b\\r\\n\\t}\\r\\n\\r\\ncomment =\\r\\n\\t\\\"#\\\" (!newline .)*\\r\\n\\t/ \\\"//\\\" (!newline .)*\\r\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\r\\n\\r\\nnewline =\\r\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\r\\n\\r\\n// optional whitespace\\r\\n_ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\r\\n\\r\\n// mandatory whitespace\\r\\n__ =\\r\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\r\\n\\r\\nsem =\\r\\n\\t\\\";\\\"\";","import Scope from './Scope';\r\nimport PegInterface from './PegInterface';\r\nimport ExpressionResolver, { Metaexpr } from './ExpressionResolver';\r\nimport Schema from './nodes/Schema';\r\nimport Typevar from './nodes/Typevar';\r\nimport Tee from './nodes/Tee';\r\nimport Schemacall from './nodes/Schemacall';\r\nimport Type from './nodes/Type';\r\nimport $var from './nodes/$var';\r\n\r\nexport default class Program {\r\n\tpublic scope = new Scope(null);\r\n\t\r\n\tconstructor() {}\r\n\r\n\tpublic feed(lines) {\r\n\t\tlines.forEach(line => {\r\n\t\t\tswitch (line._type) {\r\n\t\t\t\tcase 'typedef':\r\n\t\t\t\t\tvar type = PegInterface.type(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasType(type.name)) {\r\n\t\t\t\t\t\tthrow type.scope.error(`Type ${type.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addType(type);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defv':\r\n\t\t\t\t\tvar typevar = PegInterface.typevar(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasTypevar(typevar.name)) {\r\n\t\t\t\t\t\tthrow typevar.scope.error(`Definition ${typevar.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addTypevar(typevar);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defun':\r\n\t\t\t\t\tvar fun = PegInterface.fun(line, this.scope);\r\n\r\n\t\t\t\t\tif (this.scope.hasTypevar(fun.name)) {\r\n\t\t\t\t\t\tthrow fun.scope.error(`Definition ${fun.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addFun(fun);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defruleset':\r\n\t\t\t\t\tvar ruleset = PegInterface.ruleset(line, this.scope, this.nativeMap);\r\n\r\n\t\t\t\t\tif (this.scope.hasRuleset(ruleset.name)) {\r\n\t\t\t\t\t\tthrow ruleset.scope.error(`Ruleset ${ruleset.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addRuleset(ruleset);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'defschema':\r\n\t\t\t\t\tvar schema = PegInterface.schema(line, this.scope, this.nativeMap);\r\n\r\n\t\t\t\t\tif (this.scope.hasSchema(schema.name)) {\r\n\t\t\t\t\t\tthrow schema.scope.error(`Schema ${schema.name} has already been declared`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.scope.addSchema(schema);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tpublic evaluate(line) {\r\n\t\tswitch (line._type) {\r\n\t\t\tcase 'typedef':\r\n\t\t\tcase 'defv':\r\n\t\t\tcase 'defun':\r\n\t\t\tcase 'defruleset':\r\n\t\t\tcase 'defschema':\r\n\t\t\tcase 'tee':\r\n\t\t\tcase 'reduction':\r\n\t\t\tcase 'schemacall':\r\n\t\t\tcase 'var':\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PegInterface[({\r\n\t\t\t\t\ttypedef: 'type',\r\n\t\t\t\t\tdefv: 'typevar',\r\n\t\t\t\t\tdefun: 'fun',\r\n\t\t\t\t\tdefruleset: 'ruleset',\r\n\t\t\t\t\tdefschema: 'schema',\r\n\t\t\t\t\ttee: 'tee',\r\n\t\t\t\t\treduction: 'reduction',\r\n\t\t\t\t\tschemacall: 'schemacall',\r\n\t\t\t\t\tvar: 'metavar',\r\n\t\t\t\t\tschemaexpr: 'schemaexpr'\r\n\t\t\t\t})[line._type]](line, this.scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic nativeMap = {\r\n\t\truleset: {\r\n\t\t\ttt: {\r\n\t\t\t\tget: (name: string, scope: Scope): Schema => {\r\n\t\t\t\t\tif (typeof name != 'string')\r\n\t\t\t\t\t\tthrow Error('Assertion failed');\r\n\t\r\n\t\t\t\t\tvar vars = ['p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\r\n\t\t\t\t\tvar nullary = ['T', 'F'].concat(vars);\r\n\t\t\t\t\tvar unary = ['N'];\r\n\t\t\t\t\tvar binary = ['A', 'O', 'I', 'E'];\r\n\t\r\n\t\t\t\t\tvar arityMap = {};\r\n\t\t\t\t\tnullary.forEach(e => arityMap[e] = 0);\r\n\t\t\t\t\tunary.forEach(e => arityMap[e] = 1);\r\n\t\t\t\t\tbinary.forEach(e => arityMap[e] = 2);\r\n\t\r\n\t\t\t\t\tvar usedVars = Array(vars.length).fill(false);\r\n\t\r\n\t\t\t\t\t// 1: 파싱 하기\r\n\t\t\t\t\tvar stack = [];\r\n\t\r\n\t\t\t\t\tfunction lastIsFull() {\r\n\t\t\t\t\t\tif (!stack.length) return true;\r\n\t\t\t\t\t\treturn arityMap[stack[stack.length - 1][0]] == stack[stack.length - 1].length - 1;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfunction push(token) {\r\n\t\t\t\t\t\tif (arityMap[token] == 0) {\r\n\t\t\t\t\t\t\tif (vars.includes(token))\r\n\t\t\t\t\t\t\t\tusedVars[vars.indexOf(token)] = true;\r\n\t\r\n\t\t\t\t\t\t\tif (lastIsFull()) {\r\n\t\t\t\t\t\t\t\tstack.push(token);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstack[stack.length - 1].push(token);\r\n\t\r\n\t\t\t\t\t\t\t\twhile (stack.length > 1 && lastIsFull()\r\n\t\t\t\t\t\t\t\t\t\t&& (stack[stack.length - 2] instanceof Array)) {\r\n\t\t\t\t\t\t\t\t\tvar p = stack.pop();\r\n\t\t\t\t\t\t\t\t\tstack[stack.length - 1].push(p);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstack.push([token]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor (var i = 0; i < name.length; i++) {\r\n\t\t\t\t\t\tif (typeof arityMap[name[i]] != 'number')\r\n\t\t\t\t\t\t\tthrow Error(`Unexpected character ${name[i]}`);\r\n\t\r\n\t\t\t\t\t\tpush(name[i]);\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (stack.length != 1)\r\n\t\t\t\t\t\tthrow Error('Parse failed');\r\n\t\r\n\t\t\t\t\tif (!lastIsFull())\r\n\t\t\t\t\t\tthrow Error('Parse failed');\r\n\t\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tusedVars = usedVars.map((e, i) => e && i).filter(e => e !== false);\r\n\t\r\n\t\t\t\t\tvar parsed = stack[0];\r\n\t\r\n\t\t\t\t\t// 2: 진리표 확인\r\n\t\t\t\t\tvar collen = 2 ** usedVars.length;\r\n\t\r\n\t\t\t\t\tvar functionMap = {\r\n\t\t\t\t\t\tN: p => !p,\r\n\t\t\t\t\t\tA: (p, q) => p && q,\r\n\t\t\t\t\t\tO: (p, q) => p || q,\r\n\t\t\t\t\t\tI: (p, q) => !p || q,\r\n\t\t\t\t\t\tE: (p, q) => p == q\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tvar varTable = {};\r\n\t\r\n\t\t\t\t\tfor (var i = 0; i < usedVars.length; i++) {\r\n\t\t\t\t\t\tvarTable[vars[usedVars[i]]] = Array(collen).fill(null).map((_, j) => {\r\n\t\t\t\t\t\t\treturn !((j >> (usedVars.length - i - 1)) & 1);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar constTable = {\r\n\t\t\t\t\t\tT: Array(collen).fill(true),\r\n\t\t\t\t\t\tF: Array(collen).fill(false)\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tfunction getColumn(t) {\r\n\t\t\t\t\t\tif (t instanceof Array) {\r\n\t\t\t\t\t\t\tvar columns = t.slice(1).map(getColumn);\r\n\t\r\n\t\t\t\t\t\t\tvar column = Array(collen);\r\n\t\r\n\t\t\t\t\t\t\tfor (var i = 0; i < collen; i++) {\r\n\t\t\t\t\t\t\t\tcolumn[i] = functionMap[t[0]](...columns.map(col => col[i]));\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\treturn column;\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif (['T', 'F'].includes(t)) return constTable[t];\r\n\t\t\t\t\t\treturn varTable[t];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (!getColumn(parsed).every(e => e))\r\n\t\t\t\t\t\tthrow Error('Validation failed');\r\n\t\r\n\t\t\t\t\t// 3: 노드 트리 만들기\r\n\t\t\t\t\tif (!scope.baseType)\r\n\t\t\t\t\t\tthrow Error(`Base type not found`);\r\n\t\r\n\t\t\t\t\tvar base = scope.baseType;\r\n\t\r\n\t\t\t\t\tvar typevars = Array(usedVars.length).fill(null).map((_, i) => {\r\n\t\t\t\t\t\treturn new Typevar({\r\n\t\t\t\t\t\t\tisParam: true,\r\n\t\t\t\t\t\t\ttype: base,\r\n\t\t\t\t\t\t\tname: vars[usedVars[i]]\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\tvar typevarMap = {\r\n\t\t\t\t\t\t'T': 'T',\r\n\t\t\t\t\t\t'F': 'F',\r\n\t\t\t\t\t\t'N': 'N',\r\n\t\t\t\t\t\t'A': 'A',\r\n\t\t\t\t\t\t'O': 'O',\r\n\t\t\t\t\t\t'I': 'I',\r\n\t\t\t\t\t\t'E': 'E'\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tObject.keys(typevarMap).forEach(k => {\r\n\t\t\t\t\t\tvar v = typevarMap[k];\r\n\t\r\n\t\t\t\t\t\tif (!scope.root.hasTypevar(v))\r\n\t\t\t\t\t\t\tthrow Error(`Typevar ${v} not found`);\r\n\t\t\t\t\t\ttypevarMap[k] = scope.root.getTypevar(v);\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\tfunction recurse(t) {\r\n\t\t\t\t\t\tif (t instanceof Array) {\r\n\t\t\t\t\t\t\treturn new Schemacall({\r\n\t\t\t\t\t\t\t\tschema: recurse(t[0]),\r\n\t\t\t\t\t\t\t\targs: t.slice(1).map(recurse)\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif (vars.includes(t)) return typevars[vars.indexOf(t)];\r\n\t\t\t\t\t\treturn typevarMap[t];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar funcall = recurse(parsed);\r\n\t\r\n\t\t\t\t\tvar tee = new Tee({\r\n\t\t\t\t\t\tleft: [],\r\n\t\t\t\t\t\tright: funcall\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\tvar schema = new Schema({\r\n\t\t\t\t\t\tshouldValidate: true,\r\n\t\t\t\t\t\taxiomatic: true,\r\n\t\t\t\t\t\tname: 'tt.' + name,\r\n\t\t\t\t\t\tparams: typevars,\r\n\t\t\t\t\t\texpr: tee\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\treturn schema;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tschema: {\r\n\t\t\tcut: {\r\n\t\t\t\tget: (rules, scope: Scope) => {\r\n\t\t\t\t\treturn ExpressionResolver.chain(rules.map(ExpressionResolver.expandMeta));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmpu: {\r\n\t\t\t\tget: (rules, scope: Scope) => {\r\n\t\t\t\t\tif (rules.length != 1) throw Error('wut');\r\n\t\t\t\t\tvar rule = rules[0];\r\n\t\r\n\t\t\t\t\tif (!scope.baseType)\r\n\t\t\t\t\t\tthrow Error(`Base type not found`);\r\n\t\r\n\t\t\t\t\tvar base = scope.baseType;\r\n\t\r\n\t\t\t\t\tvar tee = ExpressionResolver.expandMeta(rule) as Tee;\r\n\t\r\n\t\t\t\t\tvar right = ExpressionResolver.expandMetaAndFuncalls(tee.right);\r\n\t\r\n\t\t\t\t\tif (tee._type != 'tee')\r\n\t\t\t\t\t\tthrow Error('wut');\r\n\t\r\n\t\t\t\t\tif (!scope.hasTypevar('I'))\r\n\t\t\t\t\t\tthrow Error(`Typevar I not found`);\r\n\t\r\n\t\t\t\t\tvar I = scope.getTypevar('I');\r\n\t\r\n\t\t\t\t\tif (!I.type.equals(new Type({\r\n\t\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\t\tfrom: [base, base],\r\n\t\t\t\t\t\tto: base\r\n\t\t\t\t\t})))\r\n\t\t\t\t\t\tthrow Error(`Wrong type for I`);\r\n\t\r\n\t\t\t\t\tif (right._type != 'schemacall' || right.schema != I) {\r\n\t\t\t\t\t\tconsole.log(right);\r\n\t\t\t\t\t\tthrow Error('wut');\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn new Tee({\r\n\t\t\t\t\t\tleft: tee.left.concat([right.args[0]]),\r\n\t\t\t\t\t\tright: right.args[1]\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tpublic getProofExplorer(name: string, ktx) {\t\r\n\t\tvar DIAMOND = '&#x25C7;',\r\n\t\t\tDOWN = '&#x25BC;',\r\n\t\t\tUP = '&#x25B2;';\r\n\t\t\r\n\t\tif (!this.scope.schemaMap.has(name)) {\r\n\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t\r\n\t\tvar theexpr = this.scope.schemaMap.get(name);\r\n\t\r\n\t\tvar ncols = (function recurse(expr: any) {\r\n\t\t\tswitch (expr._type) {\r\n\t\t\t\tcase 'reduction':\r\n\t\t\t\t\treturn Math.max(\r\n\t\t\t\t\t\t...expr.leftargs.map(recurse),\r\n\t\t\t\t\t\t((expr.subject._type == 'schema' && expr.subject.name)\r\n\t\t\t\t\t\t\t|| (expr.subject._type == 'schemacall' && expr.subject.schema.name)\r\n\t\t\t\t\t\t\t\t? 0 : recurse(expr.subject)),\r\n\t\t\t\t\t\t1\r\n\t\t\t\t\t);\r\n\t\t\t\tcase 'schema':\r\n\t\t\t\t\treturn recurse(expr.expr) + 1;\r\n\t\t\t\tcase 'tee':\r\n\t\t\t\t\treturn Math.max(\r\n\t\t\t\t\t\t...expr.left.map(recurse),\r\n\t\t\t\t\t\t...expr.def$s.map($ => recurse($.expr)),\r\n\t\t\t\t\t\trecurse(expr.right)\r\n\t\t\t\t\t) + 1;\r\n\t\t\t\tcase 'schemacall':\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t})(theexpr);\r\n\r\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], bbb?: boolean) {\r\n\t\t\tvar padding = left.length;\r\n\t\r\n\t\t\tvar htmlLeft = left.map(e => `<td class=\"brb\">${e.map(f => ktx(f.toTeXString(true))).join(', ')}</td>`).join('');\r\n\r\n\t\t\tfor (var i = 0; i < left.length; i++)\r\n\t\t\t\twhile(left[i].length) left[i].pop();\r\n\t\r\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\"' : ''} colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\r\n\t\t}\r\n\r\n\t\tfunction exprToHtml(expr, expand?) {\r\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\r\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\r\n\t\t\tif (expand) return ktx(ExpressionResolver.expandMetaAndFuncalls(expr).toTeXString(true));\r\n\t\t\t\r\n\t\t\treturn ktx(expr.toTeXString(true));\r\n\t\t}\r\n\r\n\t\tvar ctr = 0;\r\n\r\n\t\tvar tree = (function getTree(\r\n\t\t\t\texpr: Metaexpr,\r\n\t\t\t\thypnumMap: Map<Metaexpr, number>,\r\n\t\t\t\t$Map: Map<Metaexpr, number>) {\r\n\t\t\t\r\n\t\t\tif (hypnumMap.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: hypnumMap.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tif ($Map.has(expr)) {\r\n\t\t\t\treturn [{\r\n\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\texpr\r\n\t\t\t\t}];\r\n\t\t\t}\r\n\r\n\t\t\tswitch (expr._type) {\r\n\t\t\t\tcase 'reduction':\r\n\t\t\t\t\tvar leftarglines = [];\r\n\t\t\t\t\tvar leftargnums = expr.leftargs.map(l => {\r\n\t\t\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\r\n\t\t\t\t\t\tif ($Map.has(l)) return $Map.get(l);\r\n\r\n\t\t\t\t\t\tvar lines = getTree(l, hypnumMap, $Map);\r\n\t\t\t\t\t\tleftarglines = leftarglines.concat(lines);\r\n\t\t\t\t\t\treturn lines[lines.length - 1].ctr;\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar subjectlines = [];\r\n\t\t\t\t\tvar subjectnum = hypnumMap.get(expr.subject)\r\n\t\t\t\t\t\t|| $Map.get(expr.subject)\r\n\t\t\t\t\t\t|| ((s => s._type == 'schema' && s.name\r\n\t\t\t\t\t\t\t\t|| s._type == 'schemacall' && s.schema.name)(expr.subject)\r\n\t\t\t\t\t\t\t? expr.subject\r\n\t\t\t\t\t\t\t: (subjectlines = getTree(expr.subject, hypnumMap, $Map))[subjectlines.length-1].ctr);\r\n\r\n\t\t\t\t\treturn [\r\n\t\t\t\t\t\t...leftarglines,\r\n\t\t\t\t\t\t...subjectlines,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t_type: 'E',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\tsubject: subjectnum,\r\n\t\t\t\t\t\t\tleftargs: leftargnums,\r\n\t\t\t\t\t\t\treduced: expr.reduced\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\tcase 'schemacall':\r\n\t\t\t\t\tif (hypnumMap.has(expr.schema)) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\tschema: hypnumMap.get(expr.schema),\r\n\t\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ($Map.has(expr.schema)) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\tschema: $Map.get(expr.schema),\r\n\t\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (expr.schema.shouldValidate && expr.schema.name) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'RCX',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!expr.schema.shouldValidate) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar schemalines = getTree(expr.schema, hypnumMap, $Map);\r\n\r\n\t\t\t\t\treturn [\r\n\t\t\t\t\t\t...schemalines,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t_type: 'RC',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\r\n\t\t\t\t\t\t\targs: expr.args,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t];\r\n\t\t\t\tcase 'typevar':\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t\tcase 'schema':\r\n\t\t\t\t\tif (expr.shouldValidate && expr.name && expr != theexpr) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'RS',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!expr.expr) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\t_type: 'NP',\r\n\t\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\t\texpr\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\t\tvar $lines = [];\r\n\t\t\t\t\t\r\n\t\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'V',\r\n\t\t\t\t\t\t$lines,\r\n\t\t\t\t\t\tlines: getTree(expr.expr, hypnumMap, $Map),\r\n\t\t\t\t\t\t// getHtmlLine 함수가 이 배열을 조작하기 때문에\r\n\t\t\t\t\t\t// shallow copy 해야 한다.\r\n\t\t\t\t\t\tparams: expr.params.slice(),\r\n\t\t\t\t\t\tctr\r\n\t\t\t\t\t}];\r\n\t\t\t\tcase 'tee':\r\n\t\t\t\t\thypnumMap = new Map(hypnumMap);\r\n\t\t\t\t\tvar leftlines = [];\r\n\r\n\t\t\t\t\tvar start = ctr + 1;\r\n\r\n\t\t\t\t\texpr.left.forEach(l => {\r\n\t\t\t\t\t\thypnumMap.set(l, ++ctr);\r\n\t\t\t\t\t\tleftlines.push({\r\n\t\t\t\t\t\t\t_type: 'H',\r\n\t\t\t\t\t\t\tctr,\r\n\t\t\t\t\t\t\texpr: l\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t$Map = new Map($Map);\r\n\r\n\t\t\t\t\tvar $lines = [];\r\n\t\t\t\t\texpr.def$s.forEach($ => {\r\n\t\t\t\t\t\tvar lines = getTree($.expr, hypnumMap, $Map);\r\n\t\t\t\t\t\t$lines = $lines.concat(lines);\r\n\r\n\t\t\t\t\t\tvar $num = lines[lines.length - 1].ctr;\r\n\t\t\t\t\t\t$Map.set($, $num);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'T',\r\n\t\t\t\t\t\tleftlines,\r\n\t\t\t\t\t\t$lines,\r\n\t\t\t\t\t\trightlines: getTree(expr.right, hypnumMap, $Map),\r\n\t\t\t\t\t\tctr: [start, ctr]\r\n\t\t\t\t\t}];\r\n\t\t\t\tcase '$var':\r\n\t\t\t\t\tif (!$Map.has(expr)) {\r\n\t\t\t\t\t\tthrow Error(`${expr.name} is not defined`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: 'R',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\tnum: $Map.get(expr),\r\n\t\t\t\t\t\texpr: expr.expr\r\n\t\t\t\t\t}];\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tconsole.error(expr.error(`Unknown type ${expr._type}`));\r\n\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t_type: '?',\r\n\t\t\t\t\t\tctr: ++ctr,\r\n\t\t\t\t\t\texpr\r\n\t\t\t\t\t}];\r\n\t\t\t}\r\n\t\t})(theexpr, new Map(), new Map());\r\n\r\n\t\tvar html = '<table class=\"explorer\">';\r\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\r\n\t\t\r\n\t\thtml += (function tree2html(lines, left) {\r\n\t\t\treturn lines.map(line => {\r\n\t\t\t\tswitch (line._type) {\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([line.params]))\r\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([line.params]));\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\r\n\r\n\t\t\t\t\t\tvar ret = '';\r\n\r\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\r\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\r\n\r\n\t\t\t\t\t\t\tret += getHtmlLine(\r\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', true\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\r\n\t\t\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\t\t\tnewleft,\r\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t\t\t'assumption',\r\n\t\t\t\t\t\t\t\t\ti == a.length - 1\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}).join('');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.$lines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tret += tree2html(\r\n\t\t\t\t\t\t\tline.rightlines,\r\n\t\t\t\t\t\t\tnewleft\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\tcase '?':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'???'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tthrow Error('no');\r\n\t\t\t\t\tcase 'R':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RS':\r\n\t\t\t\t\tcase 'RCX':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'RC':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\r\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)} [${line.leftargs.map(a => exprToHtml(a)).join(', ')}]`]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tcase 'NP':\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\r\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn getHtmlLine(\r\n\t\t\t\t\t\t\tline.ctr,\r\n\t\t\t\t\t\t\tleft,\r\n\t\t\t\t\t\t\t`Unknown type ${line._type}`,\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}).join('');\r\n\t\t})(tree[0].$lines.concat(tree[0].lines), []);\r\n\t\t\r\n\t\thtml += '</table>';\r\n\t\r\n\t\treturn html;\r\n\t}\r\n}","import Type from './nodes/Type';\r\nimport Typevar from './nodes/Typevar';\r\nimport Ruleset from './nodes/Ruleset';\r\nimport Schema from './nodes/Schema';\r\n\r\nimport StackTrace from './StackTrace';\r\nimport { Metaexpr } from './ExpressionResolver';\r\nimport $var from './nodes/$var';\r\n\r\nexport type NestedTypeInput = string | NestedTypeInput[];\r\n\r\nexport default class Scope {\r\n\tpublic readonly typedefMap: Map<string, Type> = new Map();\r\n\tpublic readonly defMap: Map<string, Typevar | Schema> = new Map();\r\n\tpublic readonly schemaMap: Map<string, Schema> = new Map();\r\n\tpublic readonly rulesetMap: Map<string, Ruleset> = new Map();\r\n\tpublic readonly $Map: Map<string, $var> = new Map();\r\n\tpublic readonly hypotheses: Metaexpr[] = [];\r\n\r\n\tpublic readonly parent: Scope;\r\n\tpublic readonly root: Scope;\r\n\r\n\tpublic readonly trace: StackTrace;\r\n\tpublic baseType: Type;\r\n\r\n\tconstructor (parent: Scope, trace?: StackTrace) {\r\n\t\tthis.parent = parent;\r\n\t\tthis.root = parent ? parent.root : this;\r\n\r\n\t\tif (trace && !(trace instanceof StackTrace)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tthis.trace = trace || new StackTrace();\r\n\r\n\t\tthis.baseType = parent ? parent.baseType : null;\r\n\t}\r\n\r\n\tpublic extend(type, name, location): Scope {\r\n\t\tvar child = new Scope(this, this.trace.extend(type, name, location));\r\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\r\n\t\treturn child;\r\n\t}\r\n\r\n\tpublic error(message: string): Error {\r\n\t\treturn this.trace.error(message);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.typedefMap.has(name);\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasOwnType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic hasType(name: NestedTypeInput): boolean {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\treturn this.hasOwnType(name)\r\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\treturn name.map(e => {\r\n\t\t\treturn this.hasType(e);\r\n\t\t}).every(e => e);\r\n\t}\r\n\r\n\tpublic addType(type: Type): Type {\r\n\t\tif (!(type instanceof Type))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!type.name)\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\r\n\t\tif (this.hasOwnType(type.name))\r\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\r\n\r\n\t\tif (type.isBaseType) {\r\n\t\t\tif (this.baseType) {\r\n\t\t\t\tthrow this.error('A base type already exists');\r\n\t\t\t}\r\n\r\n\t\t\t(function broadcast(scope: Scope) {\r\n\t\t\t\tscope.baseType = type;\r\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\r\n\t\t\t})(this);\r\n\t\t}\r\n\r\n\t\tthis.typedefMap.set(type.name, type);\r\n\t\treturn type;\r\n\t}\r\n\r\n\t/*\r\n\t * Possible input values:\r\n\t * 'st'\t\t\t\t\t\t-> st\r\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\r\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n\t */\r\n\tpublic getType(name: NestedTypeInput): Type {\r\n\t\tif (typeof name == 'string') {\r\n\t\t\tif (!this.hasType(name))\r\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\r\n\r\n\t\t\treturn this.typedefMap.has(name)\r\n\t\t\t\t? this.typedefMap.get(name) : (!!this.parent && this.parent.getType(name));\r\n\t\t}\r\n\r\n\t\tif (!(name instanceof Array))\r\n\t\t\tthrow this.error('Argument is malformed');\r\n\r\n\t\tif (name.length < 2)\r\n\t\t\tthrow this.error('Illegal array length');\r\n\r\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\r\n\t\t\treturn this.getType(e);\r\n\t\t});\r\n\r\n\t\tvar to = this.getType(name[name.length - 1]);\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom,\r\n\t\t\tto\r\n\t\t});\r\n\t}\r\n\r\n\tpublic hasOwnTypevar(name: string): boolean {\r\n\t\treturn this.defMap.has(name);\r\n\t}\r\n\r\n\tpublic hasTypevar(name: string): boolean {\r\n\t\treturn this.hasOwnTypevar(name) ||\r\n\t\t\t(!!this.parent && this.parent.hasTypevar(name));\r\n\t}\r\n\r\n\tpublic addTypevar(typevar: Typevar | Schema): Typevar | Schema {\r\n\t\tif (!(typevar instanceof Typevar))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnTypevar(typevar.name))\r\n\t\t\tthrow this.error(`Definition ${typevar.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(typevar.name, typevar);\r\n\t\treturn typevar;\r\n\t}\r\n\r\n\tpublic addFun(fun: Schema): Schema {\r\n\t\tif (!(fun instanceof Schema))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (!fun.name)\r\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\r\n\r\n\t\tif (this.hasOwnTypevar(fun.name))\r\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\r\n\r\n\t\tthis.defMap.set(fun.name, fun);\r\n\t\treturn fun;\r\n\t}\r\n\r\n\tpublic getTypevar(name: string): Typevar | Schema {\r\n\t\tif (!this.hasTypevar(name))\r\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\r\n\r\n\t\treturn this.defMap.has(name)\r\n\t\t\t? this.defMap.get(name) : (!!this.parent && this.parent.getTypevar(name));\r\n\t}\r\n\r\n\tpublic hasOwnRuleset(name: string): boolean {\r\n\t\treturn this.rulesetMap.has(name);\r\n\t}\r\n\r\n\tpublic hasRuleset(name: string): boolean {\r\n\t\treturn this.hasOwnRuleset(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasRuleset(name));\r\n\t}\r\n\r\n\tpublic addRuleset(ruleset: Ruleset): Ruleset {\r\n\t\tif (!(ruleset instanceof Ruleset))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnRuleset(ruleset.name))\r\n\t\t\tthrow this.error(`Ruleset ${ruleset.name} has already been declared`);\r\n\r\n\t\tthis.rulesetMap.set(ruleset.name, ruleset);\r\n\t\treturn ruleset;\r\n\t}\r\n\r\n\tpublic getRuleset(name: string): Ruleset {\r\n\t\tif (!this.hasRuleset(name))\r\n\t\t\tthrow this.error(`Ruleset ${name} is not defined`);\r\n\r\n\t\treturn this.rulesetMap.has(name)\r\n\t\t\t? this.rulesetMap.get(name) : (!!this.parent && this.parent.getRuleset(name));\r\n\t}\r\n\r\n\tpublic hasOwnSchema(name: string): boolean {\r\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name);\r\n\t}\r\n\r\n\tpublic hasSchema(name: string): boolean {\r\n\t\treturn this.hasOwnSchema(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\r\n\t}\r\n\r\n\tpublic addSchema(schema: Schema): Schema {\r\n\t\tif (!(schema instanceof Schema))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwnSchema(schema.name))\r\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\r\n\r\n\t\tthis.schemaMap.set(schema.name, schema);\r\n\t\treturn schema;\r\n\t}\r\n\r\n\tpublic getSchema(name: string): Typevar | Schema {\r\n\t\tif (!this.hasSchema(name))\r\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\r\n\r\n\t\treturn this.schemaMap.has(name)\r\n\t\t\t? this.schemaMap.get(name)\r\n\t\t\t: this.defMap.has(name)\r\n\t\t\t\t? this.defMap.get(name)\r\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name));\r\n\t}\r\n\r\n\tpublic hasOwn$(name: string): boolean {\r\n\t\treturn this.$Map.has(name);\r\n\t}\r\n\r\n\tpublic has$(name: string): boolean {\r\n\t\treturn this.hasOwn$(name)\r\n\t\t\t|| (!!this.parent && this.parent.has$(name));\r\n\t}\r\n\r\n\tpublic add$($: $var): $var {\r\n\t\tif (!($ instanceof $var))\r\n\t\t\tthrow this.error('Illegal argument type');\r\n\r\n\t\tif (this.hasOwn$($.name))\r\n\t\t\tthrow this.error(`$var ${$.name} has already been declared`);\r\n\r\n\t\tthis.$Map.set($.name, $);\r\n\t\treturn $;\r\n\t}\r\n\r\n\tpublic get$(name: string): $var {\r\n\t\tif (!this.has$(name))\r\n\t\t\tthrow this.error(`$var ${name} is not defined`);\r\n\r\n\t\treturn this.$Map.has(name)\r\n\t\t\t? this.$Map.get(name) : (!!this.parent && this.parent.get$(name));\r\n\t}\r\n}","export default class StackTrace {\r\n\tpublic readonly stack: any[];\r\n\r\n\tconstructor (stack?: any[]) {\r\n\t\tthis.stack = stack || [];\r\n\t}\r\n\r\n\tpublic extend(type, name, location): StackTrace {\r\n\t\treturn new StackTrace([[type, name, location]].concat(this.stack));\r\n\t}\r\n\r\n\tpublic error(message: string) {\r\n\t\tvar filename = typeof process != 'undefined' && process.argv[2];\r\n\r\n\t\treturn new Error(\r\n\t\t\tmessage\r\n\t\t\t+ '\\n\\tat '\r\n\t\t\t+ (\r\n\t\t\t\tthis.stack.length\r\n\t\t\t\t\t? this.stack.map(([type, name, location]) => {\r\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${filename || 'code.math'}:${location.start.line}:${location.start.column})`;\r\n\t\t\t\t\t}).join('\\n\\tat ')\r\n\t\t\t\t\t: `<root> (${filename || 'code.math'}:1:1)`\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\r\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\r\n * PEG.js의 출력은 여기에서만 처리해야 한다.\r\n */\r\n\r\nimport Type from './nodes/Type';\r\nimport Typevar from './nodes/Typevar';\r\nimport Tee from './nodes/Tee';\r\nimport Ruleset from './nodes/Ruleset';\r\nimport Schema from './nodes/Schema';\r\nimport Schemacall from './nodes/Schemacall';\r\nimport Reduction from './nodes/Reduction';\r\n\r\nimport { Expr0, Metaexpr } from './ExpressionResolver';\r\nimport { Def$Object, DefrulesetObject, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject } from './PegInterfaceDefinitions';\r\nimport Scope, { NestedTypeInput } from './Scope';\r\nimport $var from './nodes/$var';\r\n\r\nfunction typeObjToString(obj: TypeObject): string {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) return (obj as StypeObject).name;\r\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\r\n\t\t\t+ typeObjToString(obj.to) + ']';\r\n}\r\n\r\n/*\r\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\r\n * st\t\t\t\t\t\t-> 'st'\r\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\r\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\r\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\r\n */\r\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) {\r\n\t\tobj = obj as StypeObject;\r\n\r\n\t\tif (!obj.name)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.name;\r\n\t} else {\r\n\t\tif (!obj.from || !obj.to)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\r\n\t\t\t[typeObjToNestedArr(obj.to)]\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction varObjToString(obj: VarObject): string {\r\n\tswitch (obj.type) {\r\n\t\tcase '@':\r\n\t\t\treturn `@${obj.name}`;\r\n\t\tcase '$':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tcase 'ruleset':\r\n\t\t\treturn `${obj.rulesetName}.${obj.name}`;\r\n\t\tcase 'normal':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\r\n\t}\r\n}\r\n\r\nexport default class PI {\r\n\tpublic static type(obj: TypedefObject, parentScope: Scope): Type {\r\n\t\tif (obj._type != 'typedef')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\r\n\r\n\t\tvar origin: Type = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\r\n\r\n\t\tvar name: string = obj.name;\r\n\t\tvar doc: string = obj.doc;\r\n\t\tvar base: boolean = obj.base;\r\n\r\n\t\tif (base && origin) {\r\n\t\t\tthrow scope.error('Base type should not be an alias');\r\n\t\t}\r\n\r\n\t\tif (origin) {\r\n\t\t\treturn new Type({\r\n\t\t\t\tname,\r\n\t\t\t\tdoc,\r\n\t\t\t\tbase,\r\n\t\t\t\torigin\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn new Type({\r\n\t\t\tfunctional: false,\r\n\t\t\tname,\r\n\t\t\tdoc,\r\n\t\t\tbase\r\n\t\t});\r\n\t}\r\n\r\n\tpublic static typevar(obj: DefvObject | VarObject, parentScope: Scope): Typevar | Schema {\r\n\t\tif (!['defv', 'var'].includes(obj._type)) {\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('typevar', obj.name, obj.location);\r\n\r\n\t\tif (obj._type == 'var') {\r\n\t\t\tif (obj.type != 'normal') {\r\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\r\n\t\t\t}\r\n\r\n\t\t\tif (!scope.hasTypevar(obj.name))\r\n\t\t\t\tthrow scope.error(`Undefined identifier ${obj.name}`);\r\n\t\t\treturn scope.getTypevar(obj.name);\r\n\t\t}\r\n\r\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\r\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\r\n\r\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\r\n\r\n\t\treturn new Typevar({\r\n\t\t\ttype,\r\n\t\t\tisParam: !!obj.isParam,\r\n\t\t\tguess: obj.guess || null,\r\n\t\t\tname: obj.name,\r\n\t\t\tdoc: obj.doc,\r\n\t\t\ttex: obj.tex\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): Schema {\r\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar name = null,\r\n\t\t\tdoc = null,\r\n\t\t\ttex = null;\r\n\r\n\t\tif (obj._type == 'defun') {\r\n\t\t\tobj = obj as DefunObject;\r\n\t\t\tname = obj.name;\r\n\t\t\tdoc = obj.doc;\r\n\t\t\ttex = obj.tex;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('fun', name, obj.location);\r\n\r\n\t\tvar type = null;\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.typevar(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnTypevar(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\r\n\t\t\treturn scope.addTypevar(tv);\r\n\t\t});\r\n\t\tvar expr = null;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'defun':\r\n\t\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\r\n\t\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\r\n\r\n\t\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\r\n\r\n\t\t\t\tif (obj.expr) {\r\n\t\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\t\tif (!rettype.equals(expr.type))\r\n\t\t\t\t\t\tthrow scope.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = new Type({\r\n\t\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\t\t\t\tto: rettype\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\texpr = PI.expr0(obj.expr, scope);\r\n\t\t\t\ttype = null;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\r\n\t\treturn new Schema({shouldValidate: false, name, type, params, expr, doc, tex}, scope);\r\n\t}\r\n\r\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Schemacall {\r\n\t\tif (obj._type != 'funcall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar schema = PI.expr0(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(arg => {\r\n\t\t\treturn PI.expr0(arg, scope);\r\n\t\t});\r\n\r\n\t\treturn new Schemacall({schema, args}, scope);\r\n\t}\r\n\r\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope): Metaexpr {\r\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'tee':\r\n\t\t\t\treturn PI.tee(obj, scope);\r\n\t\t\tcase 'reduction':\r\n\t\t\t\treturn PI.reduction(obj, scope);\r\n\t\t\tcase 'schemacall':\r\n\t\t\t\treturn PI.schemacall(obj, scope);\r\n\t\t\tcase 'schemaexpr':\r\n\t\t\t\treturn PI.schema(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.metavar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\r\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\r\n\t\t\tconsole.log(obj);\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t}\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj._type) {\r\n\t\t\tcase 'funcall':\r\n\t\t\t\treturn PI.funcall(obj, scope);\r\n\t\t\tcase 'funexpr':\r\n\t\t\t\treturn PI.fun(obj, scope);\r\n\t\t\tcase 'var':\r\n\t\t\t\treturn PI.typevar(obj, scope);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error('wut');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Metaexpr {\r\n\t\tif (obj._type != 'var')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\t// don't extend scope\r\n\t\tvar scope = parentScope;\r\n\r\n\t\tswitch (obj.type) {\r\n\t\t\tcase '@':\r\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\r\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\r\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\r\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn scope.hypotheses[hypnum];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow scope.error(`Unknown selector query @${obj.name}`);\r\n\t\t\tcase '$':\r\n\t\t\t\tif (!scope.has$(obj.name)) {\r\n\t\t\t\t\tthrow scope.error(`${obj.name} is not defined`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn scope.get$(obj.name);\r\n\t\t\tcase 'ruleset':\r\n\t\t\t\tif (!scope.hasRuleset(obj.rulesetName))\r\n\t\t\t\t\tthrow scope.error(`Ruleset ${obj.rulesetName} is not defined`);\r\n\r\n\t\t\t\tvar ruleset = scope.getRuleset(obj.rulesetName);\r\n\r\n\t\t\t\tif (!ruleset.native)\r\n\t\t\t\t\tthrow scope.error('Behavior undefined for non-native rulesets');\r\n\r\n\t\t\t\tvar schema = ruleset.native.get(obj.name, scope);\r\n\r\n\t\t\t\tif (!schema)\r\n\t\t\t\t\tthrow scope.error(`Schema ${varObjToString(obj)} is not defined`);\r\n\t\t\t\t\r\n\t\t\t\treturn schema;\r\n\t\t\tcase 'normal':\r\n\t\t\t\tif (!scope.hasSchema(obj.name))\r\n\t\t\t\t\tthrow scope.error(`Schema ${obj.name} is not defined`);\r\n\r\n\t\t\t\treturn scope.getSchema(obj.name);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static tee(obj: TeeObject, parentScope: Scope): Tee {\r\n\t\tif (obj._type != 'tee')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\r\n\r\n\t\tvar left = obj.left.map(o => PI.metaexpr(o, scope));\r\n\r\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\r\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scopeRight);\r\n\r\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scopeRight.add$($v);\r\n\t\t});\r\n\r\n\t\tvar right = PI.metaexpr(obj.right, scopeRight);\r\n\r\n\t\treturn new Tee({left, def$s, right}, scope);\r\n\t}\r\n\r\n\tpublic static def$(obj: Def$Object, parentScope: Scope): $var {\r\n\t\tif (obj._type != 'def$')\r\n\t\t\tthrow Error('Assertion failed');\r\n\t\t\r\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\r\n\t\t\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new $var({name: obj.name, expr}, scope);\r\n\t}\r\n\r\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope, nativeMap?): Schema {\r\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tnativeMap = nativeMap || {};\r\n\r\n\t\tvar name = null, axiomatic = false, doc = null;\r\n\r\n\t\tif (obj._type == 'defschema') {\r\n\t\t\tname = obj.name; axiomatic = obj.axiomatic;\r\n\t\t\tdoc = obj.doc;\r\n\t\t}\r\n\r\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\r\n\r\n\t\tif (obj._type == 'defschema' && obj.native) {\r\n\t\t\tif (!nativeMap.schema[name])\r\n\t\t\t\tthrow scope.error(`Native code for native schema ${name} not found`);\r\n\r\n\t\t\tvar native = {\r\n\t\t\t\tget: args => nativeMap.schema[name].get(args, scope)\r\n\t\t\t};\r\n\r\n\t\t\treturn new Schema({shouldValidate: true, axiomatic, name, native, doc: obj.doc}, scope);\r\n\t\t}\r\n\r\n\t\tvar params = obj.params.map(tvo => {\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(tvo.type)} is not defined`);\r\n\r\n\t\t\tvar tv = PI.typevar(tvo, scope);\r\n\r\n\t\t\tif (scope.hasOwnTypevar(tv.name))\r\n\t\t\t\tthrow tv.scope.error(`Parameter ${tv.name} has already been declared`);\r\n\t\t\t\r\n\t\t\treturn scope.addTypevar(tv);\r\n\t\t});\r\n\r\n\t\tvar def$s = obj.def$s.map($ => {\r\n\t\t\tvar $v = PI.def$($, scope);\r\n\r\n\t\t\tif (scope.hasOwn$($v.name)) {\r\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\r\n\t\t\t}\r\n\r\n\t\t\treturn scope.add$($v);\r\n\t\t});\r\n\r\n\t\tvar expr = PI.metaexpr(obj.expr, scope);\r\n\r\n\t\treturn new Schema({shouldValidate: true, axiomatic, name, params, def$s, expr, doc}, scope);\r\n\t}\r\n\r\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope): Schemacall {\r\n\t\tif (obj._type != 'schemacall')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\r\n\r\n\t\tvar schema = PI.metaexpr(obj.schema, scope);\r\n\r\n\t\tvar args = obj.args.map(obj => {\r\n\t\t\treturn PI.expr0(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Schemacall({\r\n\t\t\tschema,\r\n\t\t\targs\r\n\t\t}, scope);\r\n\t}\r\n\r\n\tpublic static ruleset(obj: DefrulesetObject, parentScope: Scope, nativeMap?): Ruleset {\r\n\t\tif (obj._type != 'defruleset')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tnative = native || {};\r\n\r\n\t\tvar scope = parentScope.extend('ruleset', obj.name, obj.location);\r\n\r\n\t\tvar axiomatic = obj.axiomatic;\r\n\t\tvar name = obj.name;\r\n\r\n\t\tif (!obj.native)\r\n\t\t\tthrow scope.error('Assertion failed');\r\n\r\n\t\tif (!nativeMap.ruleset[name])\r\n\t\t\tthrow scope.error(`Native code for native ruleset ${name} not found`);\r\n\r\n\t\tvar native = nativeMap.ruleset[name];\r\n\r\n\t\treturn new Ruleset({axiomatic, name, native, doc: obj.doc}, scope);\r\n\t}\r\n\r\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope): Reduction {\r\n\t\tif (obj._type != 'reduction')\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\r\n\r\n\t\tvar subject = PI.metaexpr(obj.subject, scope);\r\n\r\n\t\tvar guesses = !obj.guesses\r\n\t\t\t? null\r\n\t\t\t: obj.guesses.map(g => {\r\n\t\t\t\treturn g && PI.expr0(g, scope);\r\n\t\t\t});\r\n\r\n\t\tvar leftargs = obj.leftargs.map(obj => {\r\n\t\t\treturn PI.metaexpr(obj, scope);\r\n\t\t});\r\n\r\n\t\treturn new Reduction({\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs\r\n\t\t}, scope);\r\n\t}\r\n}","import Node, { Precedence } from './Node';\r\nimport Schemacall from './Schemacall';\r\n\r\nimport ExpressionResolver, { Metaexpr } from '../ExpressionResolver';\r\nimport Scope from '../Scope';\r\nimport Tee from './Tee';\r\n\r\nexport default class Reduction extends Node {\r\n\tpublic readonly _type = 'reduction';\r\n\r\n\tpublic readonly subject: Metaexpr;\r\n\tpublic readonly guesses;\r\n\tpublic readonly leftargs;\r\n\tpublic readonly reduced;\r\n\tpublic readonly type;\r\n\r\n\tconstructor ({subject, guesses, leftargs}, scope?: Scope) {\r\n\t\tsuper(scope);\r\n\r\n\t\tif (!subject.native && subject._type == 'schema') {\r\n\t\t\tsubject.params.forEach((p, i) => {\r\n\t\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\r\n\t\t\t\t\tthrow this.error(`Argument #${i + 1} could not be guessed`);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t\tvar derefs = subject.params.map((p, i) => {\r\n\t\t\t\tif (guesses && guesses[i]) return guesses[i];\r\n\t\r\n\t\t\t\treturn this.query(\r\n\t\t\t\t\tp.guess,\r\n\t\t\t\t\t(ExpressionResolver.expandMeta(subject.expr) as Tee).left,\r\n\t\t\t\t\tleftargs\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\r\n\t\t\tsubject = new Schemacall({\r\n\t\t\t\tschema: subject,\r\n\t\t\t\targs: derefs,\r\n\t\t\t}, scope);\r\n\t\t} else if (guesses) {\r\n\t\t\tthrow this.error('Something\\'s wrong');\r\n\t\t}\r\n\t\r\n\t\tif (!subject.native\r\n\t\t\t\t&& !(subject.type._type == 'metatype' && subject.type.isSimple))\r\n\t\t\tthrow this.error('Subject is not reducible');\r\n\t\r\n\t\tif (!(leftargs instanceof Array)\r\n\t\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t\r\n\t\tthis.subject = subject;\r\n\t\tthis.leftargs = leftargs;\r\n\t\r\n\t\tif (subject.native) {\r\n\t\t\tthis.reduced = subject.native.get(leftargs);\r\n\t\t\tthis.type = this.reduced.type;\r\n\t\t} else {\r\n\t\t\tvar paramTypes = subject.type.left,\r\n\t\t\t\tleftargTypes = leftargs.map(e => e.type);\r\n\t\r\n\t\t\tif (paramTypes.length != leftargTypes.length)\r\n\t\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`);\r\n\t\r\n\t\t\tfor (let i = 0; i < paramTypes.length; i++) {\r\n\t\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\r\n\t\t\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.type = subject.type.right;\r\n\t\r\n\t\t\tvar tee = ExpressionResolver.expandMetaAndFuncalls(subject);\r\n\t\r\n\t\t\tif (tee._type != 'tee') {\r\n\t\t\t\tthrow this.error('Assertion failed');\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (let i = 0; i < tee.left.length; i++) {\r\n\t\t\t\tif (!ExpressionResolver.equals(tee.left[i], leftargs[i])) {\r\n\t\t\t\t\tthrow this.error(`LHS #${i + 1} failed to match:\r\n\r\n--- EXPECTED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(tee.left[i])}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(leftargs[i])}\r\n----------------`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.reduced = tee.right;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic isProved(hyps?): boolean {\r\n\t\thyps = hyps || [];\r\n\t\t\r\n\t\treturn super.isProved(hyps)\r\n\t\t\t|| this.subject.isProved(hyps)\r\n\t\t\t\t&& this.leftargs.every(l => l.isProved(hyps));\r\n\t}\r\n\r\n\tpublic query(guess, left, leftargs) {\r\n\t\tif (guess.length == 0) throw this.error('wut');\r\n\r\n\t\tif (!(1 <= guess[0] * 1 && guess[0] * 1 <= leftargs.length))\r\n\t\t\tthrow this.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\r\n\t\tvar lef = left[guess[0] * 1 - 1];\r\n\t\tvar ret = leftargs[guess[0] * 1 - 1];\r\n\r\n\t\tvar that = this;\r\n\r\n\t\treturn (function recurse(guess, lef, node, ptr) {\r\n\t\t\tnode = ExpressionResolver.expandMetaAndFuncalls(node);\r\n\t\t\t\r\n\t\t\tif (guess.length <= ptr) return node;\r\n\r\n\t\t\tif (/[0-9]/.test(guess[ptr])) {\r\n\t\t\t\tvar n = guess[ptr] * 1;\r\n\r\n\t\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\t\tif (lef.left.length != node.left.length) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent length mismatch`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(1 <= n && n <= node.left.length)) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recurse(guess, lef.left[n - 1], node.left[n - 1], ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tif (!lef.schema || !node.schema) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ExpressionResolver.equals(lef.schema, node.schema)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!node.schema.expr) {\r\n\t\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = ExpressionResolver.expandCallOnce(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.args || !(1 <= n && n <= node.args.length))\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\r\n\t\t\t\treturn recurse(guess, lef.args[n - 1], node.args[n - 1], ptr + 1);\r\n\t\t\t} else if (guess[ptr] == 'r') {\r\n\t\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\t\treturn recurse(guess, lef.right, node.right, ptr + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t}\r\n\r\n\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t})(guess, lef, ret, 1);\r\n\t}\r\n\r\n\tpublic toIndentedString(indent: number, root?: boolean): string {\r\n\t\tvar leftargs = this.leftargs.map(arg => {\r\n\t\t\treturn arg.toIndentedString(indent + 1);\r\n\t\t});\r\n\t\r\n\t\tif (leftargs.join('').length <= 50) {\r\n\t\t\tleftargs = this.leftargs.map(arg => {\r\n\t\t\t\treturn arg.toIndentedString(indent);\r\n\t\t\t});\r\n\t\r\n\t\t\tleftargs = leftargs.join(', ');\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\tleftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t\t'\\t' + leftargs,\r\n\t\t\t\t']'\r\n\t\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\r\n\t\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\r\n\t}\r\n}"],"sourceRoot":""}