!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,__webpack_require__),r.l=!0,r.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,n){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(__webpack_require__.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)__webpack_require__.d(n,r,function(e){return t[e]}.bind(null,r));return n},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=15)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=0;class Node{constructor(t,e,n){this._id=++r,this.trace=t,this.doc=e,this.tex=n}toString(){return this.toIndentedString(0)}error(t){return Node.error(t,this.trace)}static error(t,e){return e?e.error(t):new Error(t)}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t])))}static parseTeX(t){var e=!1,n=t.replace(/^!<prec=([0-9]+)>/,((t,n)=>(e=1*n,"")));return{precedence:e,code:n}}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return!1}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),n=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<n[0]||e[0]==n[0]&&e[1]<n[1])}makeTeX(t,e,n){e=e||[],n=n||!1;var r=this.tex;return this.shouldConsolidate(n)&&(r="\\left("+r+"\\right)"),r.replace(/#([0-9]+)/g,((t,n)=>e[1*n-1]||`\\texttt{\\textcolor{red}{\\#${n}}}`)).replace(/<<(.+?)>>/,((e,n)=>`\\href{#${t}}{${n}}`))}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.EqualsPriority=void 0;const a=r(n(0));!function(t){t[t.ZERO=0]="ZERO",t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR"}(e.EqualsPriority||(e.EqualsPriority={}));class Metaexpr extends a.default{constructor(t,e,n,r){if(super(t,e,n),!r)throw a.default.error("Assertion failed",t);this.type=r}equals(t,e){return this===t||!!this.type.equals(t.type)&&(t.getEqualsPriority()>this.getEqualsPriority()?t.equalsInternal(this,e):this.equalsInternal(t,e))}}e.default=Metaexpr},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(0)),i=r(n(12));class ObjectType extends i.default{constructor(t){if(t.origin){if(super(null,t.doc,null,t.origin.isFunctional),this.isBaseType=!!t.base,"string"!=typeof t.name)throw a.default.error("typeof o.name != 'string'",null);if(this.name=t.name,!(t.origin instanceof ObjectType))throw a.default.error("!(o.origin instanceof ObjectType)",null);this.origin=t.origin}else{if(super(null,t.doc,null,t.functional),this.isBaseType=!!t.base,"boolean"!=typeof t.functional)throw a.default.error("typeof o.functional != 'boolean'",null);if(t.functional){if(t.from.map((t=>t instanceof ObjectType)).some((t=>!t)))throw a.default.error("o.from.map(f => f instanceof ObjectType).some(e => !e)",null);if(!(t.to instanceof ObjectType))throw a.default.error("!(o.to instanceof ObjectType)",null);this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw a.default.error("typeof o.name != 'string'",null);this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map((t=>t.toSimpleString())).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map((t=>t.toTeXString())).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof ObjectType))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=ObjectType},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(8));class Fun extends a.default{constructor({doc:t,tex:e,annotations:n,sealed:r,type:a,name:i,params:s,expr:f},h){if(!i&&!f)throw l.default.error("Anonymous fun cannot be primitive",h);if(a&&f)throw l.default.error("no",h);if(!a&&!f)throw l.default.error("Cannot guess the type of a primitive fun",h);var c=!1;if(e){var d=l.default.parseTeX(e);c=d.precedence,e=d.code}else e=null;super(h,t,e,a||new(f.type instanceof u.default?u.default:o.default)({functional:!0,from:s.map((t=>t.type)),to:f.type})),this.annotations=n,this.sealed=r,this.precedence=c,this.name=i,this.params=s,this.expr=f}isProved(t){return t=t||[],super.isProved(t)||this.expr&&this.expr.isProved(t)}getEqualsPriority(){return s.EqualsPriority.ONE}equalsInternal(t,e){if((!this.expr||this.sealed)&&(!(t instanceof Fun&&t.expr)||t.sealed))return!1;for(var n=[],r=this.type.resolve().from,a=0;a<r.length;a++)n.push(new f.default({isParam:!0,type:r[a],name:"$"+a},this.trace));var s=this.expr&&!this.sealed?this.call(n):new i.default({fun:this,args:n},this.trace),o=t instanceof Fun&&t.expr&&!t.sealed?t.call(n):new i.default({fun:t,args:n},this.trace);return s.equals(o,e)}call(t){if(!this.expr)throw Error("Cannot call a primitive fun");if(this.params.length!=t.length)throw Error("Illegal arguments length");for(var e=new Map,n=0;n<this.params.length;n++)e.set(this.params[n],t[n]);return this.expr.substitute(e)}}e.default=Fun;const i=r(n(6)),s=n(1),o=r(n(9)),l=r(n(0)),u=r(n(2)),f=r(n(5))},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=i(n(1)),l=s(n(0));class $Variable extends o.default{constructor({name:t,expr:e},n){if(super(n,null,null,e.type),!t||!e)throw l.default.error("Assertion failed",n);this.name=t,this.expr=e}isProved(t){return t=t||[],super.isProved(t)||this.expr.isProved(t)}substitute(t){return this.expr.substitute(t)}expandMeta(t){return this.expr.expandMeta(t)}getEqualsPriority(){return o.EqualsPriority.FOUR}equalsInternal(t,e){return this.expr.equals(t,e)}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${l.default.escapeTeX(this.name)}}`}}e.default=$Variable},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(8)),i=n(1),s=r(n(0));class Variable extends a.default{constructor({doc:t,tex:e,type:n,name:r,isParam:a,guess:i},o){if(super(o,t,e,n),this.isParam=!!a,this.guess=i||null,"string"!=typeof r)throw s.default.error("Assertion failed",o);this.name=r}isProved(t){return t=t||[],super.isProved(t)}substitute(t){return t.get(this)||this}expandMeta(t){return this}getEqualsPriority(){return i.EqualsPriority.ZERO}equalsInternal(t,e){return!1}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?s.default.escapeTeX(this.name):`\\mathrm{${s.default.escapeTeX(this.name)}}`)}}`}toTeXStringWithId(t,e){if(!this.isParam)throw Error("wut");return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(t,e),"}"].join("")}}e.default=Variable},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(4)),i=r(n(8)),s=r(n(3)),o=n(1),l=n(13),u=r(n(0)),f=r(n(7)),h=r(n(10)),c=r(n(5));class Funcall extends i.default{constructor({fun:t,args:e},n){if(t.type.isSimple){var r=l.isNameable(t)?t.name:"<anonymous>";throw u.default.error(r+" is not callable",n)}if(!(e instanceof Array)||e.map((t=>t instanceof u.default)).some((t=>!t)))throw u.default.error("Assertion failed",n);var a=t.type.resolve(),i=a.from,s=e.map((t=>t.type));if(i.length!=s.length)throw u.default.error(`Invalid number of arguments (expected ${i.length}): ${s.length}`,n);for(var o=0;o<i.length;o++)if(!i[o].equals(s[o]))throw u.default.error(`Argument #${o+1} has illegal argument type (expected ${i[o]}): ${s[o]}`,n);super(n,null,null,a.to),this.fun=t,this.args=e}isProved(t){return t=t||[],super.isProved(t)||this.fun.isProved(t)}substitute(t){return new Funcall({fun:this.fun.substitute(t),args:this.args.map((e=>e.substitute(t)))},this.trace)}expandMeta(t){var e=this.fun.expandMeta(t),n=this.args.map((e=>e.expandMeta(t)));return e instanceof s.default&&e.expr&&(!e.name||e instanceof h.default)?e.call(n).expandMeta(t):new Funcall({fun:e,args:n},this.trace)}isExpandable(t){for(var e=this.fun;e instanceof a.default;)e=e.expr;return e instanceof Funcall?e.isExpandable(t):e instanceof s.default&&e.isCallable(t)}expandOnce(t){if(!this.isExpandable(t))throw Error("Cannot expand");for(var e=this.fun;e instanceof a.default;)e=e.expr;if(e instanceof Funcall)return new Funcall({fun:e.expandOnce(t),args:this.args},this.trace);if(!(e instanceof s.default))throw Error("Something's wrong");return e.call(this.args)}getEqualsPriority(){return o.EqualsPriority.THREE}equalsInternal(t,e){if(!(t instanceof Funcall))return!!this.isExpandable(e)&&this.expandOnce(e).equals(t,e);if(this.fun.equals(t.fun,e)){for(var n=0;n<this.args.length;n++)if(!this.args[n].equals(t.args[n],e))return!1;return!0}if(this.fun instanceof Funcall&&this.fun.isExpandable(e))return this.expandOnce(e).equals(t,e);if(t.fun instanceof Funcall&&t.fun.isExpandable(e))return this.equals(t.expandOnce(e),e);var r=this.isExpandable(e),a=t.isExpandable(e);if(this.fun==t.fun||!r&&!a){if(this.fun!=t.fun)return!1;if(!r&&!a){for(n=0;n<this.args.length;n++)if(!this.args[n].equals(t.args[n],e))return!1;return!0}if(this.args.every(((n,r)=>this.args[r].equals(t.args[r],e))))return!0}return r?this.expandOnce(e).equals(t,e):this.equals(t.expandOnce(e),e)}toIndentedString(t,e){var n=this.args.map((e=>e instanceof c.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1)));return n.join("").length<=50?(n=(n=this.args.map((e=>e instanceof c.default?`${e.name}<${e._id}>`:e.toIndentedString(t)))).join(", "),this.fun instanceof h.default?`${this.fun.name||`(${this.fun})`}(${n})`:[this.fun instanceof s.default&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")",`(${n})`].join("")):(n=n.join(",\n"+"\t".repeat(t+1)),this.fun instanceof h.default?[this.fun.name||`(${this.fun.toIndentedString(t)})`,"(","\t"+n,")"].join("\n"+"\t".repeat(t)):[(this.fun instanceof s.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")")+"(","\t"+n,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.fun instanceof h.default)return(this.fun.name?`\\href{#schema-${this.fun.isProved()?"p":"np"}-${this.fun.name}}{\\textsf{${u.default.escapeTeX(this.fun.name)}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((t=>t.toTeXString(u.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof f.default)return this.fun.funcallToTeXString(this.args,t);var n=this.args.map((t=>t.toTeXString(u.default.PREC_COMMA)));return(!l.isNameable(this.fun)||!this.fun.name||this.fun instanceof c.default?this.fun.toTeXString(!1):1==this.fun.name.length?u.default.escapeTeX(this.fun.name):`\\mathrm{${u.default.escapeTeX(this.fun.name)}}`)+`\\mathord{\\left(${n.join(", ")}\\right)}`}}e.default=Funcall},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(3)),i=r(n(0)),s=r(n(2));class ObjectFun extends a.default{constructor({doc:t,tex:e,annotations:n,sealed:r,type:a,name:i,params:s,expr:o},l){super({doc:t,tex:e,annotations:n,sealed:r,type:a,name:i,params:s,expr:o},l)}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new ObjectFun({annotations:this.annotations,sealed:this.sealed,name:null,params:this.params,expr:this.expr.substitute(t)},this.trace)}expandMeta(t){return this.expr?this.type instanceof s.default&&this.name?this:new ObjectFun({annotations:this.annotations,sealed:this.sealed,name:null,params:this.params,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return this.expr&&(!this.sealed||t.uses(this))}toIndentedString(t,e){return this.name?this.name:[`ƒ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){return this.name?e?this.expr?this.funcallToTeXString(this.params,i.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(i.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}\\mathrm{${i.default.escapeTeX(this.name)}}`:(this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join(""))}funcallToTeXString(t,e){return t=t.map((t=>t.toTeXString(this.tex?this.precedence:i.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?i.default.escapeTeX(this.name):`\\mathrm{${i.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`\\mathord{\\left(${t.join(", ")}\\right)}`}}e.default=ObjectFun},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(1));class Expr0 extends a.default{}e.default=Expr0},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(0)),i=r(n(2)),s=r(n(12));class MetaType extends s.default{constructor(t){if(super(null,null,null,t.functional),"boolean"!=typeof t.functional)throw a.default.error("typeof o.functional != 'boolean'",null);if(0==t.functional){if(!(t.left instanceof Array))throw a.default.error("left should be an array",null);this.left=t.left,this.right=t.right}else{if(t.from.some((t=>!(t instanceof i.default))))throw a.default.error("o.from.some(f => !(f instanceof ObjectType))",null);if(!(t.to instanceof MetaType))throw a.default.error("!(o.to instanceof MetaType)",null);if(t.to.isFunctional)throw a.default.error("Functional metatype in functional metatype is not supported",null);this.from=t.from,this.to=t.to}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(3));class Schema extends a.default{constructor({doc:t,tex:e,annotations:n,axiomatic:r,name:a,params:s,context:o,def$s:l,expr:u},f){if(!u)throw i.default.error("wut",f);super({doc:t,tex:e,annotations:n,sealed:!1,type:null,name:a,params:s,expr:u},f),this.axiomatic=r,this.def$s=l||[],this.context=o}isProved(t){if(this._isProvedCache)return!0;if(!t&&"boolean"==typeof this._isProvedCache)return this._isProvedCache;var e=!t;t=t||[];var n=this.axiomatic||super.isProved(t);return e&&(this._isProvedCache=n),n}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new Schema({annotations:this.annotations,axiomatic:this.axiomatic,name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.substitute(t)},this.trace)}expandMeta(t){return this.expr?this.type instanceof s.default&&this.name?this:new Schema({annotations:this.annotations,axiomatic:this.axiomatic,name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return!0}toIndentedString(t,e){return[`∫ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.expandMeta(!0).toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");var n=`schema-${this.isProved()?"p":"np"}-${this.name}`;return e?`\\href{#${n}}{\\mathsf{${i.default.escapeTeX(this.name)}}}\\mathord{\\left(${this.params.map((t=>t.toTeXStringWithId(i.default.PREC_COMMA)+(t.guess?`: \\texttt{@${t.guess}}`:""))).join(", ")}\\right)}:\\\\\\quad`+this.expr.expandMeta(!0).toTeXString(!0):`\\href{#${n}}\\mathsf{${i.default.escapeTeX(this.name)}}`}}e.default=Schema;const i=r(n(0)),s=r(n(2))},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(4)),l=i(n(1)),u=s(n(9)),f=s(n(0)),h=s(n(2));class Tee extends l.default{constructor({left:t,def$s:e,right:n},r){if(!(t instanceof Array&&t.every((t=>t.type instanceof h.default||t.type instanceof u.default))))throw console.log(t),f.default.error("Assertion failed",r);if(e&&!(e instanceof Array&&e.every((t=>t instanceof o.default))))throw f.default.error("Assertion failed",r);if(!(n.type instanceof h.default||n.type instanceof u.default))throw console.log(n),f.default.error("Assertion failed",r);if(n.type.isFunctional)throw f.default.error("RHS of a rule cannot be a schema",r);super(r,null,null,new u.default({functional:!1,left:t.map((t=>t.type)),right:n.type})),this.left=t,this.def$s=e||[],this.right=n,this.precedence=f.default.PREC_COMMA}isProved(t){return t=t||[],super.isProved(t)||this.right.isProved(t.concat(this.left))}substitute(t){var e=this.left.map((e=>e.substitute(t))),n=this.right.substitute(t);return new Tee({left:e,right:n},this.trace)}expandMeta(t){var e=this.left.map((e=>e.expandMeta(t))),n=this.right.expandMeta(t);return new Tee({left:e,right:n},this.trace)}getEqualsPriority(){return l.EqualsPriority.TWO}equalsInternal(t,e){if(!(t instanceof Tee))throw Error("Assertion failed");if(this.left.length!=t.left.length)throw Error("Assertion failed");for(var n=0;n<this.left.length;n++)if(!this.left[n].equals(t.left[n],e))return!1;return this.right.equals(t.right,e)}toIndentedString(t,e){return this.left.length?["\t"+this.left.map((e=>e.toIndentedString(t+1))).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var n=this.expandMeta(!0);return[this.shouldConsolidate(t)?"\\left(":"",`{${n.left.map((t=>t.toTeXString(f.default.PREC_COMMA))).join(", ")} \\vdash ${n.right.toTeXString(f.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(0));class Type extends a.default{constructor(t,e,n,r){super(t,e,n),this.isFunctional=r,this.isSimple=!r}}e.default=Type},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNameable=void 0,e.isNameable=function isNameable(t){return"name"in t}},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(3)),l=s(n(6)),u=i(n(1)),f=s(n(9)),h=s(n(0)),c=s(n(11));class Reduction extends u.default{constructor({subject:t,guesses:e,leftargs:n,expected:r},a,i){if(e){let n=t.type.resolve().from,r=e.map((t=>t&&t.type));if(n.length!=r.length)throw h.default.error(`Invalid number of arguments (expected ${n.length}): ${r.length}`,i);for(var s=0;s<n.length;s++)if(r[s]&&!n[s].equals(r[s]))throw h.default.error(`Argument #${s+1} has illegal argument type (expected ${n[s]}): ${r[s]}`,i)}if(t instanceof o.default){t.params.forEach(((t,n)=>{if(!(e&&e[n]||t.guess))throw h.default.error(`Argument #${n+1} could not be guessed`,i)}));var u=t.params.map(((s,o)=>{if(e&&e[o])return e[o];var l=t.expr.expandMeta(!1);return Reduction.query(s.guess,l.left,n,l.right,r,a,i)}));t=new l.default({fun:t,args:u},i)}else if(e)throw h.default.error("Something's wrong",i);if(!(t.type instanceof f.default&&t.type.isSimple))throw h.default.error("Subject is not reducible",i);if(!(n instanceof Array)||n.map((t=>t instanceof h.default)).some((t=>!t)))throw h.default.error("Assertion failed",i);var d=t.type.left,p=n.map((t=>t.type));if(d.length!=p.length)throw h.default.error(`Invalid number of arguments (expected ${d.length}): ${p.length}`,i);for(let t=0;t<d.length;t++)if(!d[t].equals(p[t]))throw h.default.error(`Illegal argument type (expected ${d[t]}): ${p[t]}`,i);super(i,null,null,t.type.right),this.subject=t,this.leftargs=n;var m=t.expandMeta(!0);if(!(m instanceof c.default))throw h.default.error("Assertion failed",i);var _=n.map((t=>t.expandMeta(!0)));for(let t=0;t<m.left.length;t++)if(!m.left[t].equals(_[t],a))throw h.default.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${m.left[t].expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${n[t].expandMeta(!0)}\n----------------`,i);if(r){if(!m.right.equals(r,a))throw h.default.error(`RHS failed to match:\n\n--- EXPECTED ---\n${m.right.expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${r.expandMeta(!0)}\n----------------`,i);this.reduced=r}else this.reduced=m.right}isProved(t){return t=t||[],super.isProved(t)||this.subject.isProved(t)&&this.leftargs.every((e=>e.isProved(t)))}substitute(t){return this.reduced.substitute(t)}expandMeta(t){return this.reduced.expandMeta(t)}getEqualsPriority(){return u.EqualsPriority.FOUR}equalsInternal(t,e){return this.reduced.equals(t,e)}static query(t,e,n,r,a,i,s){if(0==t.length)throw h.default.error("wut",s);var o,u;if("r"==t[0]){if(!a)throw h.default.error("Cannot dereference @"+t,s);o=r,u=a}else{var f=Number(t[0]);if(!(1<=f&&f<=n.length))throw h.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);o=e[f-1],u=n[f-1]}return function recurse(t,e,n,r){if(n=n.expandMeta(!0),t.length<=r)return n;if(/[0-9]/.test(t[r])){var a=Number(t[r]);if(e instanceof c.default&&n instanceof c.default){if(e.left.length!=n.left.length)throw h.default.error(`Cannot dereference @${t}: antecedent length mismatch`,s);if(!(1<=a&&a<=n.left.length))throw h.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);return recurse(t,e.left[a-1],n.left[a-1],r+1)}for(;;){if(!(e instanceof l.default&&n instanceof l.default))throw h.default.error("Cannot dereference @"+t,s);if(e.fun.equals(n.fun,i))break;if(!n.isExpandable(i))throw h.default.error("Cannot dereference @"+t,s);n=n.expandOnce(i)}if(!n.args||!(1<=a&&a<=n.args.length))throw h.default.error("Cannot dereference @"+t,s);return recurse(t,e.args[a-1],n.args[a-1],r+1)}if("r"==t[r]){if(e instanceof c.default&&n instanceof c.default)return recurse(t,e.right,n.right,r+1);throw h.default.error("Cannot dereference @"+t,s)}throw h.default.error("Cannot dereference @"+t,s)}(t,o,u,1)}toIndentedString(t,e){var n=this.leftargs.map((e=>e.toIndentedString(t+1)));return n.join("").length<=50?(n=(n=this.leftargs.map((e=>e.toIndentedString(t)))).join(", "),[this.subject.toIndentedString(t)+"[",n,"]"].join("")):(n=n.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+n,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map((t=>t.toTeXString(h.default.PREC_COMMA))).join(", ")}]`}}e.default=Reduction},function(t,e,n){var r;r=n(16).default;var a=n(17).default;t.exports={grammar:r,Program:a}},function(t,e,n){"use strict";n.r(e),e.default='start =\n\t_ lines:(a:line _ {return a})* {return lines}\n\nline =\n\timport\n\t/ typedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\nevaluable =\n\t_ e:evaluable_internal _ {return e}\n\nevaluable_internal =\n\ttypedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\t/ metaexpr\n\nimport =\n\t\'import\' __\n\tfilename:ident _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: \'import\',\n\t\t\tfilename,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ntypedef =\n\tdoc:(documentation __)?\n\tbase:("base" __)?\n\t"type" __\n\torigin:(o:ftype __ {return o})?\n\tname:ident _ sem\n\t{\n\t\treturn {\n\t\t\t_type: \'typedef\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\tbase: !!base,\n\t\t\torigin,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefv =\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: false,\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefparam =\n\ttex:(tex __)? type:type __ name:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschemaparam =\n\ttex:(tex __)? type:type __ name:ident\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tguess,\n\t\t\tlocation: location()\n\t\t}\n\t}\n \ndefun =\n\tdoc:(documentation __)?\n\ttex:(tex __)?\n\tsealed:(\'sealed\' __)?\n\trettype:type __\n\tname:ident _\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\texpr:(\n\t\t"{" _\n\t\texpr:expr0 _\n\t\t"}"\n\t\t{return expr}\n\t\t/ sem {return null}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'defun\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\tsealed: !!sealed,\n\t\t\trettype,\n\t\t\tname,\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschema =\n\tdoc:(documentation __)?\n\tannotations: (a:annotation __ {return a})*\n\taxiomatic:("axiomatic" __)?\n\t"schema" __\n\tname:ident _\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defschemaparam _\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\tusing:(\n\t\t\'using\' __\n\t\tx:(\n\t\t\thead:ident _\n\t\t\ttail:(\',\' _ n:ident _ {return n})*\n\t\t\t{return [head].concat(tail)}\n\t\t)\n\t\t{return x}\n\t)?\n\t"{" _\n\tdefdollars: (d:defdollar _ {return d})* _\n\texpr:metaexpr _\n\t"}"\n\t{\n\t\treturn {\n\t\t\t_type: \'defschema\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\tannotations,\n\t\t\taxiomatic: !!axiomatic,\n\t\t\tname,\n\t\t\tparams,\n\t\t\tusing: using || [],\n\t\t\tdef$s: defdollars,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// var[...]\n// foo(...)[...]\n// foo[...][...]\n// (metaexpr)[...]\n// schema(?, ...)[...]\nreduction =\n\tsubject:(\n\t\tschemacall\n\t\t/ var\n\t\t/ "(" _\n\t\te:metaexpr _\n\t\t")"\n\t\t{return e}\n\t) _\n\tguesses:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:(\'?\' {return null} / expr0) _\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)?\n\tleftargs:(\n\t\t"[" _\n\t\ta:(\n\t\t\thead:metaexpr _\n\t\t\ttail:(";" _ e:metaexpr _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t"]"\n\t\tb:(\n\t\t\t_ \'[\' _\n\t\t\t\'as\' __\n\t\t\tm:metaexpr\n\t\t\t\']\'\n\t\t\t{return m}\n\t\t)?\n\t\t{return {a: a || [], b: b || null}}\n\t)+\n\t{\n\t\tvar ret = {\n\t\t\t_type: \'reduction\',\n\t\t\tsubject,\n\t\t\tguesses,\n\t\t\tleftargs: leftargs[0].a,\n\t\t\texpected: leftargs[0].b,\n\t\t\tlocation: location()\n\t\t};\n\n\t\tfor (var i = 1; i < leftargs.length; i++) {\n\t\t\tret = {\n\t\t\t\t_type: \'reduction\',\n\t\t\t\tsubject: ret,\n\t\t\t\tguesses: null,\n\t\t\t\tleftargs: leftargs[i].a,\n\t\t\t\texpected: leftargs[i].b,\n\t\t\t\tlocation: location()\n\t\t\t};\n\t\t}\n\n\t\treturn ret;\n\t}\n\n// var(...)\n// (metaexpr)(...)\nschemacall =\n\tschema:(\n\t\tvar\n\t\t/ "(" _ e:metaexpr _ ")"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:("," _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'schemacall\',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// forall(f, g)\n// (expr0)(f, g)\nfuncall =\n\tschema:(\n\t\tvar\n\t\t/ "(" _\n\t\te:expr0 _\n\t\t")"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:("," _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'funcall\',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => expr0\n// (T t) => { expr0 }\nfunexpr =\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\t"=>" _\n\texpr:(\n\t\texpr0\n\t\t/ "{" _ e:expr0 _ "}" {return e}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'funexpr\',\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => metaexpr_internal_1\n// (T t) => { $foo = ...; metaexpr }\nschemaexpr =\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\t"=>" _\n\tfoo:(\n\t\texpr:metaexpr_internal_1\n\t\t{return {defdollars: [], expr}}\n\t\t/ "{" _\n\t\tdefdollars: (d:defdollar _ {return d})* _\n\t\texpr:metaexpr _\n\t\t"}"\n\t\t{return {defdollars, expr}}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'schemaexpr\',\n\t\t\tparams,\n\t\t\tdef$s: foo.defdollars,\n\t\t\texpr: foo.expr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nmetaexpr =\n\tleft:(\n\t\tl:(\n\t\t\thead:metaexpr_internal_1 _\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)? {return l || []}\n\t)\n\t"|-" _\n\tdefdollars: (d:defdollar _ {return d})* _\n\tright:metaexpr\n\t{\n\t\treturn {\n\t\t\t_type: \'tee\',\n\t\t\tdef$s: defdollars,\n\t\t\tleft,\n\t\t\tright,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\t/ metaexpr_internal_1\n\n/*\n * 다음이 성립하여야 한다.\n *\n * - reduction이 schemacall보다 앞이다.\n * - schemacall이 var보다 앞이다.\n *\n */\nmetaexpr_internal_1 =\n\treduction\n\t/ schemacall\n\t/ var\n\t/ schemaexpr\n\t/ "(" _ e:metaexpr _ ")" {return e}\n\nexpr0 =\n\tfuncall\n\t/ funexpr\n\t/ var\n\t/ "(" _ e:expr0 _ ")" {return e}\n\ndefdollar =\n\tname:dollar_ident _\n\t\'=\' _\n\texpr:metaexpr _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: \'def$\',\n\t\t\tname,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t};\n\t}\n\ntype =\n\tstype\n\t/ ftype\n\nstype =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'type\',\n\t\t\tftype: false,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nftype =\n\t"[" _\n\tfrom:(\n\t\ttype:type {return [type]}\n\t\t/ (\n\t\t\ttt:(\n\t\t\t\t"(" _\n\t\t\t\thead: type\n\t\t\t\ttail:(_ "," _ t:type {return t})*\n\t\t\t\t_ ")"\n\t\t\t\t{return [head].concat(tail)}\n\t\t\t)\n\t\t\t{return tt}\n\t\t)\n\t) _\n\t"->" _\n\tto:type _\n\t"]"\n\t{\n\t\treturn {\n\t\t\t_type: \'type\',\n\t\t\tftype: true,\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nvar =\n\tat_var\n\t/ dollar_var\n\t/ plain_var\n\nat_var =\n\tname:at_ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'@\',\n\t\t\tname: name.slice(1),\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndollar_var =\n\tname:dollar_ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'$\',\n\t\t\tname: name,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nplain_var =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'normal\',\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nkeyword =\n\t\'as\'\n\t/ \'axiomatic\'\n\t/ \'base\'\n\t/ \'import\'\n\t/ \'schema\'\n\t/ \'sealed\'\n\t/ \'type\'\n\t/ \'using\'\n\nannotation =\n\t\'@discouraged\'\n\t/ \'@deprecated\'\n\nident =\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\n\nat_ident =\n\t$(\'@\' [a-zA-Z0-9_]+)\n\ndollar_ident =\n\t$(\'$\' [a-zA-Z0-9_]+)\n\ndocumentation =\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\n\t\treturn b\n\t}\n\ntex =\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\n\t\treturn b\n\t}\n\ncomment =\n\t"#" (!newline .)*\n\t/ "//" (!newline .)*\n\t/ "/*" (!"*/" .)* "*/"\n\nnewline =\n\t"\\r\\n" / "\\r" / "\\n"\n\n// optional whitespace\n_ =\n\t([ \\t\\n\\r] / comment)*\n\n// mandatory whitespace\n__ =\n\t([ \\t\\n\\r] / comment)+\n\nsem =\n\t";"'},function(t,e,n){"use strict";var r=this&&this.__awaiter||function(t,e,n,r){return new(n||(n=Promise))((function(a,i){function fulfilled(t){try{step(r.next(t))}catch(t){i(t)}}function rejected(t){try{step(r.throw(t))}catch(t){i(t)}}function step(t){t.done?a(t.value):function adopt(t){return t instanceof n?t:new n((function(e){e(t)}))}(t.value).then(fulfilled,rejected)}step((r=r.apply(t,e||[])).next())}))},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const i=a(n(18)),s=a(n(20)),o=a(n(21));e.default=class Program{constructor(t){if(this.scopeMap=new Map,!t)throw Error("no");this.parser=t}loadModule(t,e){return r(this,void 0,void 0,(function*(){return this.scope=yield this.loadModuleInternal(t,e)}))}loadModuleInternal(t,e){return r(this,void 0,void 0,(function*(){if(this.scopeMap.has(t))return this.scopeMap.get(t);var{fileUri:n,code:r}=yield e(t),a=new o.default(n,null),i=this.parser.parse(r);return yield this.feed(i,a,e),this.scopeMap.set(t,a),a}))}feed(t,e=this.scope,n){return r(this,void 0,void 0,(function*(){for(var r=0;r<t.length;r++){var a=t[r];switch(a._type){case"import":var s=yield this.loadModuleInternal(a.filename,n);e.importMap.set(a.filename,s);break;case"typedef":var o=i.default.type(a,e);if(e.hasType(o.name))throw e.error(`Type ${o.name} has already been declared`);e.addType(o);break;case"defv":var l=i.default.variable(a,e);if(e.hasVariable(l.name))throw e.error(`Definition ${l.name} has already been declared`);e.addVariable(l);break;case"defun":var u=i.default.fun(a,e);if(e.hasVariable(u.name))throw e.error(`Definition ${u.name} has already been declared`);e.addFun(u);break;case"defschema":var f=i.default.schema(a,e,null);if(e.hasSchema(f.name))throw e.error(`Schema ${f.name} has already been declared`);e.addSchema(f);break;default:throw Error("Unknown line type "+a._type)}}}))}evaluate(t){var e=new o.default("<repl>",this.scope);switch(t._type){case"typedef":return i.default.type(t,e);case"defv":return i.default.variable(t,e);case"defun":return i.default.fun(t,e);case"defschema":case"schemaexpr":return i.default.schema(t,e,null);case"tee":return i.default.tee(t,e,null);case"reduction":return i.default.reduction(t,e,null);case"schemacall":return i.default.schemacall(t,e,null);case"var":return i.default.metavar(t,e);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){return s.default.get(this.scope,t,e)}}},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(19)),i=r(n(4)),s=r(n(6)),o=r(n(7)),l=r(n(2)),u=r(n(14)),f=r(n(10)),h=r(n(11)),c=r(n(5));function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var n=e.extend("type",t.name,t.location),r=t.origin?n.getType(typeObjToNestedArr(t.origin)):null,a=t.name,i=t.doc,s=t.base;if(s&&r)throw n.error("Base type should not be an alias");return r?new l.default({name:a,doc:i,base:s,origin:r}):new l.default({functional:!1,name:a,doc:i,base:s})}static variable(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var n=e.extend("variable",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw n.error(`Variable type ${t.type} not allowed`);if(!n.hasVariable(t.name))throw n.error("Undefined identifier "+t.name);return n.getVariable(t.name)}if(!n.hasType(typeObjToNestedArr(t.type)))throw n.error(`Type ${typeObjToString(t.type)} is not defined`);var r=n.getType(typeObjToNestedArr(t.type));return new c.default({type:r,isParam:!!t.isParam,guess:t.guess||null,name:t.name,doc:t.doc,tex:t.tex},n.trace)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var n=null,r=null,a=null,i=!1;"defun"==t._type&&(n=(t=t).name,r=t.doc,a=t.tex,i=t.sealed);var s=e.extend("fun",n,t.location),u=null,f=t.params.map((t=>{if(!s.hasType(typeObjToNestedArr(t.type)))throw s.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,s);if(s.hasOwnVariable(e.name))throw s.error(`Parameter ${e.name} has already been declared`);return s.addVariable(e)})),h=null;switch(t._type){case"defun":if(!s.hasType(typeObjToNestedArr(t.rettype)))throw s.error(`Type ${typeObjToString(t.rettype)} is not defined`);var c=s.getType(typeObjToNestedArr(t.rettype));if(t.expr){if(h=PI.expr0(t.expr,s),!c.equals(h.type))throw s.error(`Expression type ${h.type} failed to match the return type ${c} of fun ${n}`)}else u=new l.default({functional:!0,from:f.map((t=>t.type)),to:c});break;case"funexpr":h=PI.expr0(t.expr,s),u=null;break;default:throw Error("wut")}if(!h&&i)throw s.error("Cannot seal a primitive fun");return new o.default({annotations:[],sealed:i,type:u,name:n,params:f,expr:h,doc:r,tex:a},s.trace)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var n=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),r=PI.expr0(t.schema,n),a=t.args.map((t=>PI.expr0(t,n)));return new s.default({fun:r,args:a},n.trace)}static metaexpr(t,e,n){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r,n);case"reduction":return PI.reduction(t,r,n);case"schemacall":return PI.schemacall(t,r,n);case"schemaexpr":return PI.schema(t,r,n);case"var":return PI.metavar(t,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var n=e;switch(t._type){case"funcall":return PI.funcall(t,n);case"funexpr":return PI.fun(t,n);case"var":return PI.variable(t,n);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var n=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var r=Number(t.name.slice(1))-1;if(r>=n.hypotheses.length)throw n.error(`Hypothesis #${r+1} not found`);return n.hypotheses[r]}throw n.error("Unknown selector query @"+t.name);case"$":if(!n.has$(t.name))throw n.error(t.name+" is not defined");return n.get$(t.name);case"normal":if(!n.hasSchema(t.name))throw n.error(`Schema ${t.name} is not defined`);return n.getSchema(t.name);default:throw n.error("Unknown type "+t.type)}}static tee(t,e,n){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),a=t.left.map((t=>PI.metaexpr(t,r,n))),i=r.extend("tee.right",null,t.right.location);a.forEach((t=>i.hypotheses.push(t)));var s=t.def$s.map((t=>{var e=PI.def$(t,i,n);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),o=PI.metaexpr(t.right,i,n);return new h.default({left:a,def$s:s,right:o},r.trace)}static def$(t,e,n){if("def$"!=t._type)throw Error("Assertion failed");var r=e.extend("def$",t.name,t.location),a=PI.metaexpr(t.expr,r,n);return new i.default({name:t.name,expr:a},r.trace)}static schema(t,e,n){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");var r="defschema"==t._type?t.name:null,i=e.extend("schema",r,t.location),s=!1,l=null,u=[],h=n;if("defschema"==t._type){if(s=t.axiomatic,l=t.doc,u=t.annotations,n)throw console.log(n),Error("duh");var c=t.using.map((t=>{if(!i.hasVariable(t))throw i.error(`Variable ${t} is not defined`);var e=i.getVariable(t);if(!(e instanceof o.default))throw i.error(t+" is not a macro");return e}));h=new a.default(c)}var d=t.params.map((t=>{if(!i.hasType(typeObjToNestedArr(t.type)))throw i.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,i);if(i.hasOwnVariable(e.name))throw i.error(`Parameter ${e.name} has already been declared`);return i.addVariable(e)})),p=t.def$s.map((t=>{var e=PI.def$(t,i,h);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),m=PI.metaexpr(t.expr,i,h);return new f.default({doc:l,annotations:u,axiomatic:s,name:r,params:d,context:h,def$s:p,expr:m},i.trace)}static schemacall(t,e,n){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),a=PI.metaexpr(t.schema,r,n),i=t.args.map((t=>PI.expr0(t,r)));return new s.default({fun:a,args:i},r.trace)}static reduction(t,e,n){if("reduction"!=t._type)throw Error("Assertion failed");if(!n)throw Error("duh");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),a=PI.metaexpr(t.subject,r,n),i=t.guesses?t.guesses.map((t=>t&&PI.expr0(t,r))):null,s=t.leftargs.map((t=>PI.metaexpr(t,r,n))),o=t.expected&&PI.metaexpr(t.expected,r,n);return new u.default({subject:a,guesses:i,leftargs:s,expected:o},n,r.trace)}}e.default=PI},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class ExecutionContext{constructor(t){this.usingList=t||[]}uses(t){return this.usingList.includes(t)}}},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(4)),i=r(n(3)),s=r(n(6)),o=n(13),l=r(n(7)),u=r(n(14)),f=r(n(10)),h=r(n(11)),c=r(n(5));e.default=class ProofExplorer{static get(t,e,n){var r="&#x25C7;";if(!t.hasSchema(e))throw Error("wut");var d=t.getSchema(e),p=function recurse(t){return t instanceof u.default?Math.max(...t.leftargs.map(recurse),t.subject instanceof i.default&&t.subject.name||t.subject instanceof s.default&&o.isNameable(t.subject.fun)&&t.subject.fun.name?0:recurse(t.subject),1):t instanceof f.default?Math.max(...t.def$s.map((t=>recurse(t.expr))),recurse(t.expr))+1:t instanceof l.default?recurse(t.expr)+1:t instanceof h.default?Math.max(...t.left.map(recurse),...t.def$s.map((t=>recurse(t.expr))),recurse(t.right))+1:1}(d);function getHtmlLine(t,e,r,a,i){for(var s=e.length,{bbb:o=!1,rrb:l=!1}=i||{},u=e.map(((t,e,r)=>`<td class="${l&&e==r.length-1?"rrb":"brb"}">${t.map((t=>n(t.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),f=0;f<e.length;f++)for(;e[f].length;)e[f].pop();return`<tr><th>${t}</th>${u}<td ${o?'class="bbb" ':""}colspan="${p-s}">${r}</td>${a instanceof Array?a.map((t=>`<td>${t}</td>`)).join(""):`<td colspan="2">${a}</td>`}</tr>`}function exprToHtml(t,e){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:n(e?t.expandMeta(!0).toTeXString(!0):t.toTeXString(!0))}var m=0,_=function getTree(t,e,n){if(e.has(t))return[{_type:"R",ctr:++m,num:e.get(t),expr:t}];if(n.has(t))return[{_type:"R",ctr:++m,num:n.get(t),expr:t}];if(t instanceof u.default){var r=[],l=t.leftargs.map((t=>{if(e.has(t))return e.get(t);if(n.has(t))return n.get(t);var a=getTree(t,e,n);return r=r.concat(a),a[a.length-1].ctr})),p=null,_=[],g=e.get(t.subject)||n.get(t.subject)||!!(t.subject instanceof s.default&&n.has(t.subject.fun))&&(p=t.subject.args,n.get(t.subject.fun))||((w=t.subject)instanceof i.default&&w.name||w instanceof s.default&&o.isNameable(w.fun)&&w.fun.name?t.subject:(_=getTree(t.subject,e,n))[_.length-1].ctr);return[...r,..._,{_type:"E",ctr:++m,subject:g,args:p,leftargs:l,reduced:t.reduced}]}if(t instanceof s.default){if(e.has(t.fun))return[{_type:"RC",ctr:++m,schema:e.get(t.fun),args:t.args,expr:t}];if(n.has(t.fun))return[{_type:"RC",ctr:++m,schema:n.get(t.fun),args:t.args,expr:t}];if(t.fun instanceof f.default&&t.fun.name)return[{_type:"RCX",ctr:++m,expr:t}];if(!(t.fun instanceof f.default))return[{_type:"NP",ctr:++m,expr:t}];var y=getTree(t.fun,e,n);return[...y,{_type:"RC",ctr:++m,schema:y[y.length-1].ctr,args:t.args,expr:t}]}if(t instanceof c.default)return[{_type:"NP",ctr:++m,expr:t}];if(t instanceof i.default){if(t instanceof f.default&&t.name&&t!=d)return[{_type:"RS",ctr:++m,expr:t}];if(!t.expr)return[{_type:"NP",ctr:++m,expr:t}];n=new Map(n);var x=m+1,b=[];return t instanceof f.default&&t.def$s.forEach((t=>{var r=getTree(t.expr,e,n);b=b.concat(r);var a=r[r.length-1].ctr;n.set(t,a)})),[{_type:"V",$lines:b,lines:getTree(t.expr,e,n),params:t.params.slice(),ctr:[x,m]}]}if(t instanceof h.default){e=new Map(e);var v=[];x=m+1;t.left.forEach((t=>{e.set(t,++m),v.push({_type:"H",ctr:m,expr:t})})),n=new Map(n);b=[];return t.def$s.forEach((t=>{var r=getTree(t.expr,e,n);b=b.concat(r);var a=r[r.length-1].ctr;n.set(t,a)})),[{_type:"T",leftlines:v,$lines:b,rightlines:getTree(t.right,e,n),ctr:[x,m]}]}if(t instanceof a.default){if(!n.has(t))throw Error(t.name+" is not defined");return[{_type:"R",ctr:++m,num:n.get(t),expr:t.expr}]}return console.log("Unknown metaexpr",t),[{_type:"?",ctr:++m,expr:t}];var w}(d,new Map,new Map),g='<table class="explorer">';return g+=`<tr><th>#</th><th colspan="${p}">expr</th><th colspan="2">rule</th></tr>`,g+=function tree2html(t,e){return t.map((t=>{switch(t._type){case"V":return tree2html(t.$lines,e.concat([t.params]))+tree2html(t.lines,e.concat([t.params]));case"T":var n=e.concat([[]]),a="";if(0==t.leftlines.length)a+=getHtmlLine("",Array(e.length+1).fill([]),"","",{bbb:!0,rrb:!0});else a+=t.leftlines.map(((t,e,r)=>getHtmlLine(t.ctr,n,exprToHtml(t.expr,!0),"assumption",{bbb:e==r.length-1,rrb:!0}))).join("");return a+=tree2html(t.$lines,n),a+=tree2html(t.rightlines,n);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,`${exprToHtml(t.schema)} (${t.args.map((t=>exprToHtml(t))).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)}${t.args?" ("+t.args.map((t=>exprToHtml(t))).join(", ")+")":""} [${t.leftargs.map((t=>exprToHtml(t))).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(t.ctr,e,"Unknown type "+t._type,"")}})).join("")}(_[0].$lines.concat(_[0].lines),[]),g+="</table>"}}},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(4)),i=r(n(3)),s=r(n(7)),o=r(n(2)),l=r(n(5)),u=r(n(22));class Scope{constructor(t,e,n){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.fileUri=t,this.parent=e,this.root=e?e.root:this,n&&!(n instanceof u.default))throw Error("Assertion failed");this.trace=n||new u.default(t),this.baseType=e?e.baseType:null}extend(t,e,n){var r=new Scope(this.fileUri,this,this.trace.extend({type:t,name:e,location:n}));return this.hypotheses.forEach((t=>r.hypotheses.push(t))),r}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnType(t)));if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasOwnType(t))).every((t=>t))}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasType(t))).every((t=>t))}addType(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)||[...this.importMap.values()].filter((e=>e.hasType(t)))[0].getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map((t=>this.getType(t))),n=this.getType(t[t.length-1]);return new o.default({functional:!0,from:e,to:n})}hasOwnVariable(t){return this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnVariable(t)))}hasVariable(t){return this.hasOwnVariable(t)||!!this.parent&&this.parent.hasVariable(t)}addVariable(t){if(!(t instanceof l.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getVariable(t){if(!this.hasVariable(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getVariable(t)||[...this.importMap.values()].filter((e=>e.hasVariable(t)))[0].getVariable(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnSchema(t)))}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)||[...this.importMap.values()].filter((e=>e.hasSchema(t)))[0].getSchema(t)}hasOwn$(t){return this.$Map.has(t)||[...this.importMap.values()].some((e=>e.hasOwn$(t)))}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$ variable ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$ variable ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)||[...this.importMap.values()].filter((e=>e.has$(t)))[0].get$(t)}}e.default=Scope},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t,e){this.fileUri=t,this.stack=e||[]}extend(t){return new StackTrace(this.fileUri,[t].concat(this.stack))}error(t){var e=this.fileUri||"<unknown>";return new Error(t+"\n\tat "+(this.stack.length?this.stack.map((({type:t,name:n,location:r})=>`${t} ${n||"<anonymous>"} (${e}:${r.start.line}:${r.start.column})`)).join("\n\tat "):`<root> (${e}:1:1)`))}}e.default=StackTrace}])}));
//# sourceMappingURL=math.min.js.map