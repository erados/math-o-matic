!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=9)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=0;class Node{constructor(t){this._id=++n,this.scope=t}toString(){return this.toIndentedString(0)}error(t){return this.scope?this.scope.error(t):new Error(t)}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t]))}static parseTeX(t){var e=!1,r=t.replace(/^!<prec=([0-9]+)>/,(t,r)=>(e=1*r,""));return{precedence:e,code:r}}isProved(t){return!!(t=t||[]).some(t=>a.default.equals(t,this))}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<r[0]||e[0]==r[0]&&e[1]<r[1])}makeTeX(t,e,r){e=e||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,(t,r)=>e[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`).replace(/<<(.+?)>>/,(e,r)=>`\\href{#${t}}{${r}}`)}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5;const a=r(1)},function(t,e,r){"use strict";function iscall(t){return"schemacall"==t._type}function callee(t){if(iscall(t))return t.schema;throw console.log(t),Error()}function makecall(t,e){if("typevar"==t._type||"schema"==t._type)return new a.default({schema:t,args:e});throw console.log(t),Error()}Object.defineProperty(e,"__esModule",{value:!0});class ER{static substitute(t,e){switch(t._type){case"schemacall":return new a.default({schema:ER.substitute(t.schema,e),args:t.args.map(t=>ER.substitute(t,e))});case"schema":if(!t.expr)return e.get(t)||t;if(t.name)return e.get(t)||t;if(t.params.some(t=>e.has(t)))throw Error("Parameter collision");return new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.substitute(t.expr,e)});case"typevar":return e.get(t)||t;case"tee":var r=t.left.map(t=>ER.substitute(t,e)),s=ER.substitute(t.right,e);return new i.default({left:r,right:s});case"reduction":return ER.substitute(t.reduced,e);default:throw Error("Unknown type "+t._type)}}static call(t,e){if(!function iscallable(t){return"schema"==t._type}(t))throw console.log(t),Error("Illegal type");if(!t.expr)throw Error("Cannot call a callable without a body");if(t.params.length!=e.length)throw Error("Illegal arguments length");for(var r=new Map,n=0;n<t.params.length;n++)r.set(t.params[n],e[n]);return ER.substitute(t.expr,r)}static expandCallOnce(t){if(!iscall(t))throw Error("Illegal type");if(iscall(callee(t)))return makecall(ER.expandCallOnce(callee(t)),t.args);var e=callee(t);if("schema"!=e._type)throw Error("Something's wrong");if(!e.expr)throw Error("Could not expand");return ER.call(e,t.args)}static expandMeta(t){if("native"in t&&t.native)return t;switch(t._type){case"tee":var e=t.left.map(ER.expandMeta),r=ER.expandMeta(t.right);return new i.default({left:e,right:r});case"schemacall":var s=ER.expandMeta(t.schema),o=t.args;return!s.expr||s.name&&!s.shouldValidate?new a.default({schema:s,args:o}):ER.expandMeta(ER.call(s,o));case"reduction":return ER.expandMeta(t.reduced);case"schema":return t.expr?"type"==t.type._type&&t.name?t:new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMeta(t.expr)}):t;case"typevar":return t;default:throw console.log(t),Error("Unknown metaexpr")}}static expandMetaAndFuncalls(t){switch(t._type){case"tee":var e=t.left.map(ER.expandMetaAndFuncalls),r=ER.expandMetaAndFuncalls(t.right);return new i.default({left:e,right:r});case"schema":return t.expr?"type"==t.type._type&&t.name?t:new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMetaAndFuncalls(t.expr)}):t;case"schemacall":var s=ER.expandMetaAndFuncalls(t.schema),o=t.args.map(ER.expandMetaAndFuncalls);return!s.expr||s.name&&!s.shouldValidate?new a.default({schema:s,args:o}):ER.expandMetaAndFuncalls(ER.call(s,o));case"reduction":return ER.expandMetaAndFuncalls(t.reduced);case"typevar":return t;default:throw console.log(t),Error("Unknown metaexpr")}}static equals(t,e){var r=function recurse(t,e,n){if(t==e)return!0;if(!t.type.equals(e.type))return!1;if("reduction"==t._type)return r(t.reduced,e,n+1);if("reduction"==e._type)return r(t,e.reduced,n+1);if(iscall(t)&&iscall(e)){if(iscall(callee(t)))return r(ER.expandCallOnce(t),e,n+1);if(iscall(callee(e)))return r(t,ER.expandCallOnce(e),n+1);if(callee(t)==callee(e)||!callee(t).expr&&!callee(e).expr){if(callee(t)!=callee(e))return!1;if(!callee(t).expr&&!callee(e).expr){for(var a=0;a<t.args.length;a++)if(!r(t.args[a],e.args[a],n+1))return!1;return!0}if(t.args.every((a,i)=>r(t.args[i],e.args[i],n+1)))return!0}return callee(t).expr?r(ER.expandCallOnce(t),e,n+1):r(t,ER.expandCallOnce(e),n+1)}if(iscall(t))return(iscall(callee(t))||!!callee(t).expr)&&r(ER.expandCallOnce(t),e,n+1);if(iscall(e))return(iscall(callee(e))||!!callee(e).expr)&&r(t,ER.expandCallOnce(e),n+1);if("tee"==t._type){for(a=0;a<t.left.length;a++)if(!r(t.left[a],e.left[a],n+1))return!1;return r(t.right,e.right,n+1)}if(t.type.isFunctional){var i=[],o=t.type.resolve().from.length;for(a=0;a<o;a++)i.push(new s.default({type:t.type.resolve().from[a],name:"$"+a}));return r(makecall(t,i),makecall(e,i),n+1)}return!1};ER.nequalscall++;var n=r(t,e,0);return n&&ER.nequalstrue++,n}static chain(t){if(!t.every(t=>"tee"==t._type))throw Error("no");return ER.expandMetaAndFuncalls(t.reduceRight((t,e)=>{for(var r=0;r<t.left.length;r++)if(ER.equals(e.right,t.left[r])){var n=t.left.slice(0,r).concat(e.left).concat(t.left.slice(r+1));return new i.default({left:n,right:t.right})}throw Error(`Chaining failed:\n\n--- LEFT ---\n${e}\n------------\n\n--- RIGHT ---\n${t}\n-------------`)}))}}e.default=ER,ER.nequalscall=0,ER.nequalstrue=0,ER.nrecursecall=0,ER.nrecursetrue=0;const n=r(4),a=r(5),i=r(6),s=r(2)},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Typevar extends n.default{constructor({type:t,isParam:e,guess:r,name:n,doc:a,tex:i},s){if(super(s),this._type="typevar",this.doc=a,this.tex=i,this.isParam=!!e,this.guess=r||null,t=t,"string"!=typeof n)throw this.error("Assertion failed");this.type=t,this.name=n}isProved(t){return t=t||[],super.isProved(t)}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`)}}`}}e.default=Typevar},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(t){if(super(),this._type="type",this.doc=t.doc,this.isBaseType=!!t.base,t.origin){if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");if(this.name=t.name,!(t.origin instanceof Type))throw this.error("!(o.origin instanceof Type)");this.isFunctional=t.origin.isFunctional,this.isSimple=t.origin.isSimple,this.origin=t.origin}else{if("boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.map(t=>t instanceof Type).some(t=>!t))throw this.error("o.from.map(f => f instanceof Type).some(e => !e)");if(!(t.to instanceof Type))throw this.error("!(o.to instanceof Type)");this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map(t=>t.toSimpleString()).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+"\\left["+this.resolve().from.map(t=>t.toTeXString()).join(" \\times ")+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof Type))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=Type},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(3),i=r(7),s=r(1),o=r(2);class Schema extends n.default{constructor({doc:t,tex:e,shouldValidate:r,axiomatic:s,type:l,name:c,native:u,params:h,expr:p},f){if(super(f),this._type="schema",this.doc=t,this.shouldValidate=r,e){var{precedence:d,code:m}=n.default.parseTeX(e);this.precedence=d,this.tex=m}else this.precedence=!1,this.tex=null;if(!c&&!u&&!p)throw this.error("Anonymous fun cannot be primitive");if(l&&p||p&&u||u&&l)throw this.error("no");if(!l&&!u&&!p)throw this.error("Cannot guess the type of a primitive fun");if(null!==c&&"string"!=typeof c)throw this.error("Assertion failed");if(!u&&p&&!(p.type instanceof a.default||p.type instanceof i.default))throw this.error("Assertion failed");if(this.axiomatic=s,this.name=c,u)this.native=u,this.expr=null,this.type=null;else{if(!(h instanceof Array)||h.map(t=>t instanceof o.default).some(t=>!t))throw this.error("Assertion failed");if(null!==p&&!(p instanceof n.default))throw this.error("Assertion failed");this.type=l||new(p.type instanceof a.default?a.default:i.default)({functional:!0,from:h.map(t=>t.type),to:p.type}),this.params=h,this.expr=p}this.proved=this.isProved()}isProved(t){return t=t||[],this.proved||!this.native&&super.isProved(t)||this.axiomatic||this.expr&&this.expr.isProved(t)}toIndentedString(t,e){return this.native?`∫ ${this.name} <native>`:[`∫ ${this.name||""}(${this.params.map(e=>e.toIndentedString(t)).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=n.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")}\\right)`,"\\mapsto "+s.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");if(this.shouldValidate){var r=`schema-${this.proved?"p":"np"}-${this.name}`;return e?this.native?`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}\\ (\\textrm{native})`:`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}(${this.params.map(t=>t.toTeXString(n.default.PREC_COMMA)+(t.guess?`: \\texttt{@${t.guess}}`:"")).join(", ")}):\\\\\\quad`+s.default.expandMetaAndFuncalls(this.expr).toTeXString(!0):`\\href{#${r}}\\mathsf{${n.default.escapeTeX(this.name)}}`}return e?this.expr?this.funcallToTeXString(this.params,n.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(n.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}\\mathrm{${n.default.escapeTeX(this.name)}}`}funcallToTeXString(t,e){return t=t.map(t=>t.toTeXString(this.tex?this.precedence:n.default.PREC_COMMA)),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`(${t.join(", ")})`}}e.default=Schema},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(2),i=r(4);class Schemacall extends n.default{constructor({schema:t,args:e},r){if(super(r),this._type="schemacall",t.type.isSimple)throw this.error(t.name+" is not callable");if(!(e instanceof Array)||e.map(t=>t instanceof n.default).some(t=>!t))throw this.error("Assertion failed");var a=t.type.resolve(),i=a.from,s=e.map(t=>t.type);if(i.length!=s.length)throw this.error(`Invalid number of arguments (expected ${i.length}): ${s.length}`);for(var o=0;o<i.length;o++)if(!i[o].equals(s[o]))throw this.error(`Argument #${o+1} has illegal argument type (expected ${i[o]}): ${s[o]}`);this.schema=t,this.type=a.to,this.args=e}isProved(t){return t=t||[],super.isProved(t)||this.schema.isProved(t)}toIndentedString(t,e){var r=this.args.map(e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1));return r.join("").length<=50?(r=(r=this.args.map(e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t))).join(", "),this.schema.shouldValidate?[(this.schema.name||`(${this.schema})`)+"(",r,")"].join(""):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(t)+")")+"(",r,")"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),this.schema.shouldValidate?[(this.schema.name||`(${this.schema.toIndentedString(t)})`)+"(","\t"+r,")"].join("\n"+"\t".repeat(t)):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(t)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.schema.shouldValidate)return(this.schema.name?`\\href{#schema-${this.schema.proved?"p":"np"}-${this.schema.name}}{\\textsf{${n.default.escapeTeX(this.schema.name)}}}`:this.schema.toTeXString(!1))+`(${this.args.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")})`;if(this.schema instanceof i.default)return this.schema.funcallToTeXString(this.args,t);var r=this.args.map(t=>t.toTeXString(n.default.PREC_COMMA));return(this.schema.name&&"typevar"!=this.schema._type?1==this.schema.name.length?n.default.escapeTeX(this.schema.name):`\\mathrm{${n.default.escapeTeX(this.schema.name)}}`:this.schema.toTeXString(!1))+`(${r.join(", ")})`}}e.default=Schemacall},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(7),i=r(1);class Tee extends n.default{constructor({left:t,right:e},r){if(super(r),this._type="tee",!(t instanceof Array&&t.every(t=>["type","metatype"].includes(t.type._type))))throw console.log(t),this.error("Assertion failed");if(!["type","metatype"].includes(e.type._type))throw console.log(e),this.error("Assertion failed");if(e.type.isFunctional)throw this.error("RHS of a rule cannot be a schema");this.left=t.reduce((t,e)=>{for(var r=0;r<t.length;r++)if(i.default.equals(t[r],e))return t;return t.push(e),t},[]),this.right=e,this.type=new a.default({functional:!1,left:t.map(t=>t.type),right:e.type})}isProved(t){return t=t||[],super.isProved(t)||this.right.isProved(t.concat(this.left))}toIndentedString(t,e){return this.left.length?["\t"+this.left.map(e=>e.toIndentedString(t+1)).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var r=i.default.expandMetaAndFuncalls(this);return[this.shouldConsolidate(t)?"\\left(":"",`{${r.left.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")} \\vdash ${r.right.toTeXString(n.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee,Tee.precedence=n.default.PREC_COMMA},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(3);class MetaType extends n.default{constructor(t){if(super(),this._type="metatype","boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.some(t=>!(t instanceof a.default)))throw this.error("o.from.some(f => !(f instanceof Type))");if(!(t.to instanceof MetaType))throw this.error("!(o.to instanceof MetaType)");if(t.to.isFunctional)throw this.error("Functional metatype in functional metatype is not supported");this.from=t.from,this.to=t.to}else{if(!(t.left instanceof Array))throw this.error("left should be an array");this.left=t.left,this.right=t.right}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Ruleset extends n.default{constructor({axiomatic:t,name:e,native:r,doc:n},a){if(super(a),this._type="ruleset",this.doc=n,"string"!=typeof e)throw this.error("Assertion failed");if(!r)throw this.error("Assertion failed");this.axiomatic=t,this.name=e,this.native=r||!1}isProved(t){return t=t||[],super.isProved(t)||this.axiomatic}toIndentedString(t,e){return"RS "+this.name+(this.native?" <native>":" <error>")}toTeXString(t,e){return`\\href{#ruleset-${this.name}}{\\mathsf{${n.default.escapeTeX(this.name)}}}`+(this.native?"\\ (\\textrm{native})":"\\ (\\textit{error})")}}e.default=Ruleset},function(t,e,r){var n;n=r(10).default;var a=r(11).default;t.exports={grammar:n,Program:a}},function(t,e,r){"use strict";r.r(e),e.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defruleset\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defruleset\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\tdoc = doc && doc[0];\r\n\t\t\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\t// native schemata\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"native" __\r\n\t"schema" __\r\n\tname:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tnative: true,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/\r\n\t// non-native schemata\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tnative: false,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefruleset =\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"native" __\r\n\t"ruleset" __\r\n\tname:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defruleset\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tnative: true,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:("," _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\t{return a || []}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0],\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i],\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:expr0 _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _ expr:expr0 _ "}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _ expr:metaexpr _ "}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\t// right associativity\r\n\ta:(\r\n\t\tmetaexpr_internal_1\r\n\t) _ "~" _ b:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject: {\r\n\t\t\t\t_type: \'var\',\r\n\t\t\t\ttype: \'normal\',\r\n\t\t\t\tname: \'cut\',\r\n\t\t\t\tlocation: location()\r\n\t\t\t},\r\n\t\t\tleftargs: [a, b],\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\nmetaexpr_internal_1 =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_2 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_2 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tright:metaexpr_internal_1\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_2\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_2 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\trulesetName:(id:ident _ "." _ {return id})?\r\n\tname:ident\r\n\t{\r\n\t\treturn rulesetName\r\n\t\t\t? {\r\n\t\t\t\t_type: \'var\',\r\n\t\t\t\ttype: \'ruleset\',\r\n\t\t\t\trulesetName,\r\n\t\t\t\tname,\r\n\t\t\t\tlocation: location()\r\n\t\t\t}\r\n\t\t\t: {\r\n\t\t\t\t_type: \'var\',\r\n\t\t\t\ttype: \'normal\',\r\n\t\t\t\tname,\r\n\t\t\t\tlocation: location()\r\n\t\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"axiomatic"\r\n\t/ "base"\r\n\t/ "native"\r\n\t/ "ruleset"\r\n\t/ "schema"\r\n\t/ "type";\r\n\r\nident =\r\n\t$(!keyword [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(12),a=r(15),i=r(1);e.default=class Program{constructor(){this.scope=new n.default(null),this.ExpressionResolver=i.default}feed(t,e){t.forEach(t=>{switch(t._type){case"typedef":var r=a.default.type(t,this.scope);if(this.scope.hasType(r.name))throw r.scope.error(`Type ${r.name} has already been declared`);this.scope.addType(r);break;case"defv":var n=a.default.typevar(t,this.scope);if(this.scope.hasTypevar(n.name))throw n.scope.error(`Definition ${n.name} has already been declared`);this.scope.addTypevar(n);break;case"defun":var i=a.default.fun(t,this.scope);if(this.scope.hasTypevar(i.name))throw i.scope.error(`Definition ${i.name} has already been declared`);this.scope.addFun(i);break;case"defruleset":var s=a.default.ruleset(t,this.scope,e);if(this.scope.hasRuleset(s.name))throw s.scope.error(`Ruleset ${s.name} has already been declared`);this.scope.addRuleset(s);break;case"defschema":var o=a.default.schema(t,this.scope,e);if(this.scope.hasSchema(o.name))throw o.scope.error(`Schema ${o.name} has already been declared`);this.scope.addSchema(o);break;default:throw Error("Unknown line type "+t._type)}})}evaluate(t){switch(t._type){case"typedef":case"defv":case"defun":case"defruleset":case"defschema":case"tee":case"reduction":case"schemacall":case"var":case"schemaexpr":return a.default[{typedef:"type",defv:"typevar",defun:"fun",defruleset:"ruleset",defschema:"schema",tee:"tee",reduction:"reduction",schemacall:"schemacall",var:"metavar",schemaexpr:"schemaexpr"}[t._type]](t,this.scope);default:throw Error("Unknown line type "+t._type)}}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(3),a=r(2),i=r(6),s=r(8),o=r(4),l=r(5),c=r(13);class Scope{constructor(t,e){if(this.typedefMap={},this.defMap={},this.schemaMap={},this.rulesetMap={},this.Type=n.default,this.Typevar=a.default,this.Tee=i.default,this.Ruleset=s.default,this.Schema=o.default,this.Schemacall=l.default,this.parent=t,this.root=t?t.root:this,e&&!(e instanceof c.default))throw Error("Assertion failed");this.trace=e||new c.default,this.baseType=t?t.baseType:null}extend(t,e,r){return new Scope(this,this.trace.extend(t,e,r))}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return!!this.typedefMap[t];if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map(t=>this.hasOwnType(t)).every(t=>t)}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map(t=>this.hasType(t)).every(t=>t)}addType(t){if(!(t instanceof n.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap[t.name]=t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap[t]||!!this.parent&&this.parent.getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map(t=>this.getType(t)),r=this.getType(t[t.length-1]);return new n.default({functional:!0,from:e,to:r})}hasOwnTypevar(t){return!!this.defMap[t]}hasTypevar(t){return this.hasOwnTypevar(t)||!!this.parent&&this.parent.hasTypevar(t)}addTypevar(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnTypevar(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap[t.name]=t}addFun(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnTypevar(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap[t.name]=t}getTypevar(t){if(!this.hasTypevar(t))throw this.error(`Definition ${t} is not defined`);return this.defMap[t]||!!this.parent&&this.parent.getTypevar(t)}hasOwnRuleset(t){return!!this.rulesetMap[t]}hasRuleset(t){return this.hasOwnRuleset(t)||!!this.parent&&this.parent.hasRuleset(t)}addRuleset(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(this.hasOwnRuleset(t.name))throw this.error(`Ruleset ${t.name} has already been declared`);return this.rulesetMap[t.name]=t}getRuleset(t){if(!this.hasRuleset(t))throw this.error(`Ruleset ${t} is not defined`);return this.rulesetMap[t]||!!this.parent&&this.parent.getRuleset(t)}hasOwnSchema(t){return!!this.schemaMap[t]||!!this.defMap[t]}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap[t.name]=t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap[t]||this.defMap[t]||!!this.parent&&this.parent.getSchema(t)}}e.default=Scope},function(t,e,r){"use strict";(function(t){Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t){this.stack=t||[]}extend(t,e,r){return new StackTrace([[t,e,r]].concat(this.stack))}error(e){var r=void 0!==t&&t.argv[2];return new Error(e+"\n\tat "+(this.stack.length?this.stack.map(([t,e,n])=>`${t} ${e||"<anonymous>"} (${r||"code.math"}:${n.start.line}:${n.start.column})`).join("\n\tat "):`<root> (${r||"code.math"}:1:1)`))}}e.default=StackTrace}).call(this,r(14))},function(t,e){var r,n,a=t.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(t){if(r===setTimeout)return setTimeout(t,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){n=defaultClearTimeout}}();var i,s=[],o=!1,l=-1;function cleanUpNextTick(){o&&i&&(o=!1,i.length?s=i.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!o){var t=runTimeout(cleanUpNextTick);o=!0;for(var e=s.length;e;){for(i=s,s=[];++l<e;)i&&i[l].run();l=-1,e=s.length}i=null,o=!1,function runClearTimeout(t){if(n===clearTimeout)return clearTimeout(t);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{return n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];s.push(new Item(t,e)),1!==s.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(t){return[]},a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(3),a=r(2),i=r(6),s=r(8),o=r(4),l=r(5),c=r(16),u=r(1);function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var r=e.extend("type",t.name,t.location),a=t.origin?r.getType(typeObjToNestedArr(t.origin)):null,i=t.name,s=t.doc,o=t.base;if(o&&a)throw r.error("Base type should not be an alias");return a?new n.default({name:i,doc:s,base:o,origin:a}):new n.default({functional:!1,name:i,doc:s,base:o})}static typevar(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var r=e.extend("typevar",t.name,t.location);if("var"==t._type){if(!r.hasTypevar(t.name))throw r.error("Undefined identifier "+t.name);return r.getTypevar(t.name)}if(!r.hasType(typeObjToNestedArr(t.type)))throw r.error(`Type ${typeObjToString(t.type)} is not defined`);var n=r.getType(typeObjToNestedArr(t.type));return new a.default({type:n,isParam:!!t.isParam,guess:t.guess||null,name:t.name,doc:t.doc,tex:t.tex},r)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var r=null,a=null,i=null;"defun"==t._type&&(r=(t=t).name,a=t.doc,i=t.tex);var s=e.extend("fun",r,t.location),l=null,c=t.params.map(t=>{if(!s.hasType(typeObjToNestedArr(t.type)))throw s.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.typevar(t,s);if(s.hasOwnTypevar(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return s.addTypevar(e)}),u=null;switch(t._type){case"defun":if(!s.hasType(typeObjToNestedArr(t.rettype)))throw s.error(`Type ${typeObjToString(t.rettype)} is not defined`);var h=s.getType(typeObjToNestedArr(t.rettype));if(t.expr){if(u=PI.expr0(t.expr,s),!h.equals(u.type))throw s.error(`Expression type ${u.type} failed to match the return type ${h} of fun ${r}`)}else l=new n.default({functional:!0,from:c.map(t=>t.type),to:h});break;case"funexpr":u=PI.expr0(t.expr,s),l=null;break;default:throw Error("wut")}return new o.default({shouldValidate:!1,name:r,type:l,params:c,expr:u,doc:a,tex:i},s)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var r=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),n=PI.expr0(t.schema,r),a=t.args.map(t=>PI.expr0(t,r));return new l.default({schema:n,args:a},r)}static metaexpr(t,e){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r);case"reduction":return PI.reduction(t,r);case"schemacall":return PI.schemacall(t,r);case"schemaexpr":return PI.schema(t,r);case"var":return PI.metavar(t,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var r=e;switch(t._type){case"funcall":return PI.funcall(t,r);case"funexpr":return PI.fun(t,r);case"var":return PI.typevar(t,r);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var r=e;switch(t.type){case"ruleset":if(!r.hasRuleset(t.rulesetName))throw r.error(`Ruleset ${t.rulesetName} is not defined`);var n=r.getRuleset(t.rulesetName);if(!n.native)throw r.error("Behavior undefined for non-native rulesets");var a=n.native.get(t.name,r);if(!a)throw r.error(`Schema ${function varObjToString(t){switch(t.type){case"ruleset":return`${t.rulesetName}.${t.name}`;case"normal":return""+t.name;default:throw Error("Unknown type "+t.type)}}(t)} is not defined`);return a;case"normal":if(!r.hasSchema(t.name))throw r.error(`Schema ${t.name} is not defined`);return r.getSchema(t.name);default:throw r.error("Unknown type "+t.type)}}static tee(t,e){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),foo=t=>PI.metaexpr(t,r),n=t.left.map(foo),a=foo(t.right);return new i.default({left:n,right:a},r)}static schema(t,e,r){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");r=r||{};var n=null,a=!1,i=null;"defschema"==t._type&&(n=t.name,a=t.axiomatic,i=t.doc);var s=e.extend("schema",n,t.location);if("defschema"==t._type&&t.native){if(!r.schema[n])throw s.error(`Native code for native schema ${n} not found`);var l={get:t=>r.schema[n].get(t,s,u.default)};return new o.default({shouldValidate:!0,axiomatic:a,name:n,native:l,doc:t.doc},s)}var c=t.params.map(t=>{if(!s.hasType(typeObjToNestedArr(t.type)))throw s.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.typevar(t,s);if(s.hasOwnTypevar(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return s.addTypevar(e)}),h=PI.metaexpr(t.expr,s);return new o.default({shouldValidate:!0,axiomatic:a,name:n,params:c,expr:h,doc:i},s)}static schemacall(t,e){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),n=PI.metaexpr(t.schema,r);if("type"==n.type._type)return PI.funcall({_type:"funcall",schema:t.schema,args:t.args,location:t.location},e);var a=t.args.map(t=>PI.expr0(t,r));return new l.default({schema:n,args:a},r)}static ruleset(t,e,r){if("defruleset"!=t._type)throw Error("Assertion failed");o=o||{};var n=e.extend("ruleset",t.name,t.location),a=t.axiomatic,i=t.name;if(!t.native)throw n.error("Assertion failed");if(!r.ruleset[i])throw n.error(`Native code for native ruleset ${i} not found`);var o=r.ruleset[i];return new s.default({axiomatic:a,name:i,native:o,doc:t.doc},n)}static reduction(t,e){if("reduction"!=t._type)throw Error("Assertion failed");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),n=PI.metaexpr(t.subject,r),a=t.guesses?t.guesses.map(t=>t&&PI.expr0(t,r)):null,i=t.leftargs.map(t=>PI.metaexpr(t,r));return new c.default({subject:n,guesses:a,leftargs:i},r)}}e.default=PI},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(5),i=r(1);class Reduction extends n.default{constructor({subject:t,guesses:e,leftargs:r},s){if(super(s),this._type="reduction",t.native||"schema"!=t._type){if(e)throw this.error("Something's wrong")}else{t.params.forEach((t,r)=>{if(!(e&&e[r]||t.guess))throw this.error(`Argument #${r+1} could not be guessed`)});var o=t.params.map((n,a)=>e&&e[a]?e[a]:this.query(n.guess,i.default.expandMeta(t.expr).left,r));t=new a.default({schema:t,args:o},s)}if(!(t.native||"metatype"==t.type._type&&t.type.isSimple))throw this.error("Subject is not reducible");if(!(r instanceof Array)||r.map(t=>t instanceof n.default).some(t=>!t))throw this.error("Assertion failed");if(this.subject=t,this.leftargs=r,t.native)this.reduced=t.native.get(r),this.type=this.reduced.type;else{var l=t.type.left,c=r.map(t=>t.type);if(l.length!=c.length)throw this.error(`Invalid number of arguments (expected ${l.length}): ${c.length}`);for(let t=0;t<l.length;t++)if(!l[t].equals(c[t]))throw this.error(`Illegal argument type (expected ${l[t]}): ${c[t]}`);this.type=t.type.right;var u=i.default.expandMetaAndFuncalls(t);if("tee"!=u._type)throw this.error("Assertion failed");for(let t=0;t<u.left.length;t++)if(!i.default.equals(u.left[t],r[t]))throw this.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${i.default.expandMetaAndFuncalls(u.left[t])}\n----------------\n\n--- RECEIVED ---\n${i.default.expandMetaAndFuncalls(r[t])}\n----------------`);this.reduced=u.right}}isProved(t){return t=t||[],super.isProved(t)||this.subject.isProved(t)&&this.leftargs.every(e=>e.isProved(t))}query(t,e,r){if(0==t.length)throw this.error("wut");if(!(1<=1*t[0]&&1*t[0]<=r.length))throw this.error(`Cannot dereference @${t}: antecedent index out of range`);var n=e[1*t[0]-1],a=r[1*t[0]-1],s=this;return function recurse(t,e,r,n){if(r=i.default.expandMetaAndFuncalls(r),t.length<=n)return r;if(/[0-9]/.test(t[n])){var a=1*t[n];if("tee"==e._type&&"tee"==r._type){if(e.left.length!=r.left.length)throw s.error(`Cannot dereference @${t}: antecedent length mismatch`);if(!(1<=a&&a<=r.left.length))throw s.error(`Cannot dereference @${t}: antecedent index out of range`);return recurse(t,e.left[a-1],r.left[a-1],n+1)}for(;;){if(!e.schema||!r.schema)throw s.error("Cannot dereference @"+t);if(i.default.equals(e.schema,r.schema))break;if(!r.schema.expr)throw s.error("Cannot dereference @"+t);r=i.default.expandCallOnce(r)}if(!r.args||!(1<=a&&a<=r.args.length))throw s.error("Cannot dereference @"+t);return recurse(t,e.args[a-1],r.args[a-1],n+1)}if("r"==t[n]){if("tee"==e._type&&"tee"==r._type)return recurse(t,e.right,r.right,n+1);throw s.error("Cannot dereference @"+t)}throw s.error("Cannot dereference @"+t)}(t,n,a,1)}toIndentedString(t,e){var r=this.leftargs.map(e=>e.toIndentedString(t+1));return r.join("").length<=50?(r=(r=this.leftargs.map(e=>e.toIndentedString(t))).join(", "),[this.subject.toIndentedString(t)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+r,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")}]`}}e.default=Reduction}])}));
//# sourceMappingURL=math.min.js.map