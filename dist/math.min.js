!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=15)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=0;class Node{constructor(t,e,r){this._id=++n,this.doc=e,this.tex=r}toString(){return this.toIndentedString(0)}static error(t,e){return e?e.error(t):new Error(t)}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t])))}static parseTeX(t){var e=!1,r=t.replace(/^!<prec=([0-9]+)>/,((t,r)=>(e=1*r,"")));return{precedence:e,code:r}}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return!1}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<r[0]||e[0]==r[0]&&e[1]<r[1])}makeTeX(t,e,r){e=e||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,((t,r)=>e[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`)).replace(/<<(.+?)>>/,((e,r)=>`\\href{#${t}}{${r}}`))}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.EqualsPriority=void 0;const n=r(0);!function(t){t[t.ZERO=0]="ZERO",t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR"}(e.EqualsPriority||(e.EqualsPriority={}));class Metaexpr extends n.default{constructor(t,e,r,a){if(super(t,e,r),!a)throw n.default.error("Assertion failed",t);this.type=a}equals(t){return this===t||!!this.type.equals(t.type)&&(t.getEqualsPriority()>this.getEqualsPriority()?t.equalsInternal(this):this.equalsInternal(t))}}e.default=Metaexpr},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(12);class ObjectType extends a.default{constructor(t){if(t.origin){if(super(null,t.doc,null,t.origin.isFunctional),this.isBaseType=!!t.base,"string"!=typeof t.name)throw n.default.error("typeof o.name != 'string'",null);if(this.name=t.name,!(t.origin instanceof ObjectType))throw n.default.error("!(o.origin instanceof ObjectType)",null);this.origin=t.origin}else{if(super(null,t.doc,null,t.functional),this.isBaseType=!!t.base,"boolean"!=typeof t.functional)throw n.default.error("typeof o.functional != 'boolean'",null);if(t.functional){if(t.from.map((t=>t instanceof ObjectType)).some((t=>!t)))throw n.default.error("o.from.map(f => f instanceof ObjectType).some(e => !e)",null);if(!(t.to instanceof ObjectType))throw n.default.error("!(o.to instanceof ObjectType)",null);this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw n.default.error("typeof o.name != 'string'",null);this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map((t=>t.toSimpleString())).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map((t=>t.toTeXString())).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof ObjectType))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=ObjectType},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(7),a=r(6),i=r(1),s=r(8),o=r(0),l=r(2),u=r(5);class Fun extends n.default{constructor({doc:t,tex:e,annotations:r,sealed:n,type:a,name:i,params:u,expr:f},h){if(!i&&!f)throw o.default.error("Anonymous fun cannot be primitive",h);if(a&&f)throw o.default.error("no",h);if(!a&&!f)throw o.default.error("Cannot guess the type of a primitive fun",h);var c=!1;if(e){var d=o.default.parseTeX(e);c=d.precedence,e=d.code}else e=null;super(h,t,e,a||new(f.type instanceof l.default?l.default:s.default)({functional:!0,from:u.map((t=>t.type)),to:f.type})),this.annotations=r,this.sealed=n,this.precedence=c,this.name=i,this.params=u,this.expr=f}isProved(t){return t=t||[],super.isProved(t)||this.expr&&this.expr.isProved(t)}getEqualsPriority(){return i.EqualsPriority.ONE}equalsInternal(t){if((!this.expr||this.sealed)&&(!(t instanceof Fun&&t.expr)||t.sealed))return!1;for(var e=[],r=this.type.resolve().from,n=0;n<r.length;n++)e.push(new u.default({isParam:!0,type:r[n],name:"$"+n}));var i=this.expr&&!this.sealed?this.call(e):new a.default({fun:this,unseal:!1,args:e}),s=t instanceof Fun&&t.expr&&!t.sealed?t.call(e):new a.default({fun:t,unseal:!1,args:e});return i.equals(s)}call(t){if(!this.expr)throw Error("Cannot call a primitive fun");if(this.params.length!=t.length)throw Error("Illegal arguments length");for(var e=new Map,r=0;r<this.params.length;r++)e.set(this.params[r],t[r]);return this.expr.substitute(e)}}e.default=Fun},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(1),a=r(0);class $Variable extends n.default{constructor({name:t,expr:e},r){if(super(r,null,null,e.type),!t||!e)throw a.default.error("Assertion failed",r);this.name=t,this.expr=e}isProved(t){return t=t||[],super.isProved(t)||this.expr.isProved(t)}substitute(t){return this.expr.substitute(t)}expandMeta(t){return this.expr.expandMeta(t)}getEqualsPriority(){return n.EqualsPriority.FOUR}equalsInternal(t){return this.expr.equals(t)}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${a.default.escapeTeX(this.name)}}`}}e.default=$Variable},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(7),a=r(1),i=r(0);class Variable extends n.default{constructor({doc:t,tex:e,type:r,name:n,isParam:a,guess:s},o){if(super(o,t,e,r),this.isParam=!!a,this.guess=s||null,"string"!=typeof n)throw i.default.error("Assertion failed",o);this.name=n}isProved(t){return t=t||[],super.isProved(t)}substitute(t){return t.get(this)||this}expandMeta(t){return this}getEqualsPriority(){return a.EqualsPriority.ZERO}equalsInternal(t){return!1}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?i.default.escapeTeX(this.name):`\\mathrm{${i.default.escapeTeX(this.name)}}`)}}`}toTeXStringWithId(t,e){if(!this.isParam)throw Error("wut");return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(t,e),"}"].join("")}}e.default=Variable},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(7),i=r(3),s=r(1),o=r(13),l=r(0),u=r(9),f=r(10),h=r(5);class Funcall extends a.default{constructor({fun:t,unseal:e,args:r},n){if(t.type.isSimple){var a=o.isNameable(t)?t.name:"<anonymous>";throw l.default.error(a+" is not callable",n)}if(!(r instanceof Array)||r.map((t=>t instanceof l.default)).some((t=>!t)))throw l.default.error("Assertion failed",n);var i=t.type.resolve(),s=i.from,u=r.map((t=>t.type));if(s.length!=u.length)throw l.default.error(`Invalid number of arguments (expected ${s.length}): ${u.length}`,n);for(var f=0;f<s.length;f++)if(!s[f].equals(u[f]))throw l.default.error(`Argument #${f+1} has illegal argument type (expected ${s[f]}): ${u[f]}`,n);super(n,null,null,i.to),this.fun=t,this.unseal=e,this.args=r}isProved(t){return t=t||[],super.isProved(t)||this.fun.isProved(t)}substitute(t){return new Funcall({fun:this.fun.substitute(t),unseal:this.unseal,args:this.args.map((e=>e.substitute(t)))})}expandMeta(t){var e=this.fun.expandMeta(t),r=this.unseal,n=this.args.map((e=>e.expandMeta(t)));return e instanceof i.default&&e.expr&&(!e.name||e instanceof f.default)?e.call(n).expandMeta(t):new Funcall({fun:e,unseal:r,args:n})}isExpandable(){for(var t=this.fun;t instanceof n.default;)t=t.expr;return t instanceof Funcall?t.isExpandable():t instanceof i.default&&(t.expr&&!(t.sealed&&!this.unseal))}expandOnce(){if(!this.isExpandable())throw Error("Cannot expand");for(var t=this.fun;t instanceof n.default;)t=t.expr;if(t instanceof Funcall)return new Funcall({fun:t.expandOnce(),unseal:this.unseal,args:this.args});if(!(t instanceof i.default))throw Error("Something's wrong");return t.call(this.args)}getEqualsPriority(){return s.EqualsPriority.THREE}equalsInternal(t){if(!(t instanceof Funcall))return!!this.isExpandable()&&this.expandOnce().equals(t);if(this.fun.equals(t.fun)){for(var e=0;e<this.args.length;e++)if(!this.args[e].equals(t.args[e]))return!1;return!0}if(this.fun instanceof Funcall&&this.fun.isExpandable())return this.expandOnce().equals(t);if(t.fun instanceof Funcall&&t.fun.isExpandable())return this.equals(t.expandOnce());var r=this.isExpandable(),n=t.isExpandable();if(this.fun==t.fun||!r&&!n){if(this.fun!=t.fun)return!1;if(!r&&!n){for(e=0;e<this.args.length;e++)if(!this.args[e].equals(t.args[e]))return!1;return!0}if(this.args.every(((e,r)=>this.args[r].equals(t.args[r]))))return!0}return r?this.expandOnce().equals(t):this.equals(t.expandOnce())}toIndentedString(t,e){var r=this.args.map((e=>e instanceof h.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.args.map((e=>e instanceof h.default?`${e.name}<${e._id}>`:e.toIndentedString(t)))).join(", "),this.fun instanceof f.default?`${this.fun.name||`(${this.fun})`}(${r})`:[this.fun instanceof i.default&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")",`(${r})`].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),this.fun instanceof f.default?[this.fun.name||`(${this.fun.toIndentedString(t)})`,"(","\t"+r,")"].join("\n"+"\t".repeat(t)):[(this.fun instanceof i.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.fun instanceof f.default)return(this.fun.name?`\\href{#schema-${this.fun.isProved()?"p":"np"}-${this.fun.name}}{\\textsf{${l.default.escapeTeX(this.fun.name)}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((t=>t.toTeXString(l.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof u.default)return this.fun.funcallToTeXString(this.args,t);var r=this.args.map((t=>t.toTeXString(l.default.PREC_COMMA)));return(!o.isNameable(this.fun)||!this.fun.name||this.fun instanceof h.default?this.fun.toTeXString(!1):1==this.fun.name.length?l.default.escapeTeX(this.fun.name):`\\mathrm{${l.default.escapeTeX(this.fun.name)}}`)+`\\mathord{\\left(${r.join(", ")}\\right)}`}}e.default=Funcall},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(1);class Expr0 extends n.default{}e.default=Expr0},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(2),i=r(12);class MetaType extends i.default{constructor(t){if(super(null,null,null,t.functional),"boolean"!=typeof t.functional)throw n.default.error("typeof o.functional != 'boolean'",null);if(0==t.functional){if(!(t.left instanceof Array))throw n.default.error("left should be an array",null);this.left=t.left,this.right=t.right}else{if(t.from.some((t=>!(t instanceof a.default))))throw n.default.error("o.from.some(f => !(f instanceof ObjectType))",null);if(!(t.to instanceof MetaType))throw n.default.error("!(o.to instanceof MetaType)",null);if(t.to.isFunctional)throw n.default.error("Functional metatype in functional metatype is not supported",null);this.from=t.from,this.to=t.to}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(3),a=r(0),i=r(2);class ObjectFun extends n.default{constructor({doc:t,tex:e,annotations:r,sealed:n,type:a,name:i,params:s,expr:o},l){super({doc:t,tex:e,annotations:r,sealed:n,type:a,name:i,params:s,expr:o},l)}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new ObjectFun({annotations:this.annotations,sealed:this.sealed,name:null,params:this.params,expr:this.expr.substitute(t)})}expandMeta(t){return this.expr?this.type instanceof i.default&&this.name?this:new ObjectFun({annotations:this.annotations,sealed:this.sealed,name:null,params:this.params,expr:this.expr.expandMeta(t)}):this}toIndentedString(t,e){return this.name?this.name:[`ƒ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){return this.name?e?this.expr?this.funcallToTeXString(this.params,a.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(a.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}\\mathrm{${a.default.escapeTeX(this.name)}}`:(this.precedence=a.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(a.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join(""))}funcallToTeXString(t,e){return t=t.map((t=>t.toTeXString(this.tex?this.precedence:a.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?a.default.escapeTeX(this.name):`\\mathrm{${a.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`\\mathord{\\left(${t.join(", ")}\\right)}`}}e.default=ObjectFun},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(3),a=r(0),i=r(2);class Schema extends n.default{constructor({doc:t,tex:e,annotations:r,axiomatic:n,name:a,params:i,def$s:s,expr:o},l){super({doc:t,tex:e,annotations:r,sealed:!1,type:null,name:a,params:i,expr:o},l),this.axiomatic=n,this.def$s=s||[]}isProved(t){if(this._isProvedCache)return!0;if(!t&&"boolean"==typeof this._isProvedCache)return this._isProvedCache;var e=!t;t=t||[];var r=this.axiomatic||super.isProved(t);return e&&(this._isProvedCache=r),r}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new Schema({annotations:this.annotations,axiomatic:this.axiomatic,name:null,params:this.params,def$s:this.def$s,expr:this.expr.substitute(t)})}expandMeta(t){return this.expr?this.type instanceof i.default&&this.name?this:new Schema({annotations:this.annotations,axiomatic:this.axiomatic,name:null,params:this.params,def$s:this.def$s,expr:this.expr.expandMeta(t)}):this}toIndentedString(t,e){return[`∫ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.expandMeta(!0).toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=a.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(a.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");var r=`schema-${this.isProved()?"p":"np"}-${this.name}`;return e?`\\href{#${r}}{\\mathsf{${a.default.escapeTeX(this.name)}}}\\mathord{\\left(${this.params.map((t=>t.toTeXStringWithId(a.default.PREC_COMMA)+(t.guess?`: \\texttt{@${t.guess}}`:""))).join(", ")}\\right)}:\\\\\\quad`+this.expr.expandMeta(!0).toTeXString(!0):`\\href{#${r}}\\mathsf{${a.default.escapeTeX(this.name)}}`}}e.default=Schema},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(1),i=r(8),s=r(0),o=r(2);class Tee extends a.default{constructor({left:t,def$s:e,right:r},a){if(!(t instanceof Array&&t.every((t=>t.type instanceof o.default||t.type instanceof i.default))))throw console.log(t),s.default.error("Assertion failed",a);if(e&&!(e instanceof Array&&e.every((t=>t instanceof n.default))))throw s.default.error("Assertion failed",a);if(!(r.type instanceof o.default||r.type instanceof i.default))throw console.log(r),s.default.error("Assertion failed",a);if(r.type.isFunctional)throw s.default.error("RHS of a rule cannot be a schema",a);super(a,null,null,new i.default({functional:!1,left:t.map((t=>t.type)),right:r.type})),this.left=t,this.def$s=e||[],this.right=r,this.precedence=s.default.PREC_COMMA}isProved(t){return t=t||[],super.isProved(t)||this.right.isProved(t.concat(this.left))}substitute(t){var e=this.left.map((e=>e.substitute(t))),r=this.right.substitute(t);return new Tee({left:e,right:r})}expandMeta(t){var e=this.left.map((e=>e.expandMeta(t))),r=this.right.expandMeta(t);return new Tee({left:e,right:r})}getEqualsPriority(){return a.EqualsPriority.TWO}equalsInternal(t){if(!(t instanceof Tee))throw Error("Assertion failed");if(this.left.length!=t.left.length)throw Error("Assertion failed");for(var e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return this.right.equals(t.right)}toIndentedString(t,e){return this.left.length?["\t"+this.left.map((e=>e.toIndentedString(t+1))).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var r=this.expandMeta(!0);return[this.shouldConsolidate(t)?"\\left(":"",`{${r.left.map((t=>t.toTeXString(s.default.PREC_COMMA))).join(", ")} \\vdash ${r.right.toTeXString(s.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(t,e,r,n){super(t,e,r),this.isFunctional=n,this.isSimple=!n}}e.default=Type},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNameable=void 0,e.isNameable=function isNameable(t){return"name"in t}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(3),a=r(6),i=r(1),s=r(8),o=r(0),l=r(11);class Reduction extends i.default{constructor({subject:t,guesses:e,leftargs:r,expected:i},u){if(e){let r=t.type.resolve().from,n=e.map((t=>t&&t.type));if(r.length!=n.length)throw o.default.error(`Invalid number of arguments (expected ${r.length}): ${n.length}`,u);for(var f=0;f<r.length;f++)if(n[f]&&!r[f].equals(n[f]))throw o.default.error(`Argument #${f+1} has illegal argument type (expected ${r[f]}): ${n[f]}`,u)}if(t instanceof n.default){t.params.forEach(((t,r)=>{if(!(e&&e[r]||t.guess))throw o.default.error(`Argument #${r+1} could not be guessed`,u)}));var h=t.params.map(((n,a)=>{if(e&&e[a])return e[a];var s=t.expr.expandMeta(!1);return Reduction.query(n.guess,s.left,r,s.right,i,u)}));t=new a.default({fun:t,unseal:!1,args:h},u)}else if(e)throw o.default.error("Something's wrong",u);if(!(t.type instanceof s.default&&t.type.isSimple))throw o.default.error("Subject is not reducible",u);if(!(r instanceof Array)||r.map((t=>t instanceof o.default)).some((t=>!t)))throw o.default.error("Assertion failed",u);var c=t.type.left,d=r.map((t=>t.type));if(c.length!=d.length)throw o.default.error(`Invalid number of arguments (expected ${c.length}): ${d.length}`,u);for(let t=0;t<c.length;t++)if(!c[t].equals(d[t]))throw o.default.error(`Illegal argument type (expected ${c[t]}): ${d[t]}`,u);super(u,null,null,t.type.right),this.subject=t,this.leftargs=r;var p=t.expandMeta(!0);if(!(p instanceof l.default))throw o.default.error("Assertion failed",u);for(let t=0;t<p.left.length;t++)if(!p.left[t].equals(r[t]))throw o.default.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${p.left[t].expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${r[t].expandMeta(!0)}\n----------------`,u);if(i){if(!p.right.equals(i))throw o.default.error(`RHS failed to match:\n\n--- EXPECTED ---\n${p.right.expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${i.expandMeta(!0)}\n----------------`,u);this.reduced=i}else this.reduced=p.right}isProved(t){return t=t||[],super.isProved(t)||this.subject.isProved(t)&&this.leftargs.every((e=>e.isProved(t)))}substitute(t){return this.reduced.substitute(t)}expandMeta(t){return this.reduced.expandMeta(t)}getEqualsPriority(){return i.EqualsPriority.FOUR}equalsInternal(t){return this.reduced.equals(t)}static query(t,e,r,n,i,s){if(0==t.length)throw o.default.error("wut",s);var u,f;if("r"==t[0]){if(!i)throw o.default.error("Cannot dereference @"+t,s);u=n,f=i}else{if(!(1<=1*t[0]&&1*t[0]<=r.length))throw o.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);u=e[1*t[0]-1],f=r[1*t[0]-1]}return function recurse(t,e,r,n){if(r=r.expandMeta(!0),t.length<=n)return r;if(/[0-9]/.test(t[n])){var i=1*t[n];if(e instanceof l.default&&r instanceof l.default){if(e.left.length!=r.left.length)throw o.default.error(`Cannot dereference @${t}: antecedent length mismatch`,s);if(!(1<=i&&i<=r.left.length))throw o.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);return recurse(t,e.left[i-1],r.left[i-1],n+1)}for(;;){if(!(e instanceof a.default&&r instanceof a.default))throw o.default.error("Cannot dereference @"+t,s);if(e.fun.equals(r.fun))break;if(!r.isExpandable())throw o.default.error("Cannot dereference @"+t,s);r=r.expandOnce()}if(!r.args||!(1<=i&&i<=r.args.length))throw o.default.error("Cannot dereference @"+t,s);return recurse(t,e.args[i-1],r.args[i-1],n+1)}if("r"==t[n]){if(e instanceof l.default&&r instanceof l.default)return recurse(t,e.right,r.right,n+1);throw o.default.error("Cannot dereference @"+t,s)}throw o.default.error("Cannot dereference @"+t,s)}(t,u,f,1)}toIndentedString(t,e){var r=this.leftargs.map((e=>e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.leftargs.map((e=>e.toIndentedString(t)))).join(", "),[this.subject.toIndentedString(t)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+r,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map((t=>t.toTeXString(o.default.PREC_COMMA))).join(", ")}]`}}e.default=Reduction},function(t,e,r){var n;n=r(16).default;var a=r(17).default;t.exports={grammar:n,Program:a}},function(t,e,r){"use strict";r.r(e),e.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\timport\r\n\t/ typedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\nimport =\r\n\t\'import\' __\r\n\tfilename:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'import\',\r\n\t\t\tfilename,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc: doc ? doc[0] : null,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc ? doc[0] : null,\r\n\t\t\ttex: tex ? tex[0] : null,\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex ? tex[0] : null,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex ? tex[0] : null,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\tsealed:(\'sealed\' __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc ? doc[0] : null,\r\n\t\t\ttex: tex ? tex[0] : null,\r\n\t\t\tsealed: !!sealed,\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\tdoc:(documentation __)?\r\n\tannotations: (a:annotation __ {return a})*\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc ? doc[0] : null,\r\n\t\t\tannotations,\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:(";" _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\tb:(\r\n\t\t\t_ \'[\' _\r\n\t\t\t\'as\' __\r\n\t\t\tm:metaexpr\r\n\t\t\t\']\'\r\n\t\t\t{return m}\r\n\t\t)?\r\n\t\t{return {a: a || [], b: b || null}}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0].a,\r\n\t\t\texpected: leftargs[0].b,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i].a,\r\n\t\t\t\texpected: leftargs[i].b,\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschemaAndUnseal:(\r\n\t\tschema:var\r\n\t\tunseal:(_ \'+\')?\r\n\t\t{return {schema, unseal: !!unseal}}\r\n\t\t/ "(" _ schema:metaexpr _ ")"\r\n\t\t{return {schema, unseal: false}}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema: schemaAndUnseal.schema,\r\n\t\t\tunseal: schemaAndUnseal.unseal,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschemaAndUnseal:(\r\n\t\tschema:var\r\n\t\tunseal:(_ \'+\')?\r\n\t\t{return {schema, unseal: !!unseal}}\r\n\t\t/ "(" _ schema:expr0 _ ")"\r\n\t\t{return {schema, unseal: false}}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema: schemaAndUnseal.schema,\r\n\t\t\tunseal: schemaAndUnseal.unseal,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => expr0\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\texpr:(\r\n\t\texpr0\r\n\t\t/ "{" _ e:expr0 _ "}" {return e}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => metaexpr_internal_1\r\n// (T t) => { $foo = ...; metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\tfoo:(\r\n\t\texpr:metaexpr_internal_1\r\n\t\t{return {defdollars: [], expr}}\r\n\t\t/ "{" _\r\n\t\tdefdollars: (d:defdollar _ {return d})* _\r\n\t\texpr:metaexpr _\r\n\t\t"}"\r\n\t\t{return {defdollars, expr}}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\tdef$s: foo.defdollars,\r\n\t\t\texpr: foo.expr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_1 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\tright:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tdef$s: defdollars,\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_1 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ndefdollar =\r\n\tname:dollar_ident _\r\n\t\'=\' _\r\n\texpr:metaexpr _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'def$\',\r\n\t\t\tname,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\t}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\tat_var\r\n\t/ dollar_var\r\n\t/ plain_var\r\n\r\nat_var =\r\n\tname:at_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'@\',\r\n\t\t\tname: name.slice(1),\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndollar_var =\r\n\tname:dollar_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'$\',\r\n\t\t\tname: name,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nplain_var =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'normal\',\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"as"\r\n\t/ "axiomatic"\r\n\t/ "base"\r\n\t/ "import"\r\n\t/ "schema"\r\n\t/ "sealed"\r\n\t/ "type"\r\n\r\nannotation =\r\n\t\'@discouraged\'\r\n\t/ \'@deprecated\'\r\n\r\nident =\r\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\r\n\r\nat_ident =\r\n\t$(\'@\' [a-zA-Z0-9_]+)\r\n\r\ndollar_ident =\r\n\t$(\'$\' [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(a,i){function fulfilled(t){try{step(n.next(t))}catch(t){i(t)}}function rejected(t){try{step(n.throw(t))}catch(t){i(t)}}function step(t){t.done?a(t.value):function adopt(t){return t instanceof r?t:new r((function(e){e(t)}))}(t.value).then(fulfilled,rejected)}step((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0});const a=r(18),i=r(19),s=r(20);e.default=class Program{constructor(t){if(this.scope=new s.default(null),this.scopeMap=new Map,!t)throw Error("no");this.parser=t}loadModule(t,e){return n(this,void 0,void 0,(function*(){return this.scope=yield this.loadModuleInternal(t,e)}))}loadModuleInternal(t,e){return n(this,void 0,void 0,(function*(){if(this.scopeMap.has(t))return this.scopeMap.get(t);var r=new s.default(null),n=yield e(t),a=this.parser.parse(n);return yield this.feed(a,r,e),this.scopeMap.set(t,r),r}))}feed(t,e=this.scope,r){return n(this,void 0,void 0,(function*(){for(var n=0;n<t.length;n++){var i=t[n];switch(i._type){case"import":var s=yield this.loadModuleInternal(i.filename,r);e.importMap.set(i.filename,s);break;case"typedef":var o=a.default.type(i,e);if(e.hasType(o.name))throw e.error(`Type ${o.name} has already been declared`);e.addType(o);break;case"defv":var l=a.default.variable(i,e);if(e.hasVariable(l.name))throw e.error(`Definition ${l.name} has already been declared`);e.addVariable(l);break;case"defun":var u=a.default.fun(i,e);if(e.hasVariable(u.name))throw e.error(`Definition ${u.name} has already been declared`);e.addFun(u);break;case"defschema":var f=a.default.schema(i,e);if(e.hasSchema(f.name))throw e.error(`Schema ${f.name} has already been declared`);e.addSchema(f);break;default:throw Error("Unknown line type "+i._type)}}}))}evaluate(t){switch(t._type){case"typedef":return a.default.type(t,this.scope);case"defv":return a.default.variable(t,this.scope);case"defun":return a.default.fun(t,this.scope);case"defschema":case"schemaexpr":return a.default.schema(t,this.scope);case"tee":return a.default.tee(t,this.scope);case"reduction":return a.default.reduction(t,this.scope);case"schemacall":return a.default.schemacall(t,this.scope);case"var":return a.default.metavar(t,this.scope);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){return i.default.get(this.scope,t,e)}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(6),i=r(9),s=r(2),o=r(14),l=r(10),u=r(11),f=r(5);function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var r=e.extend("type",t.name,t.location),n=t.origin?r.getType(typeObjToNestedArr(t.origin)):null,a=t.name,i=t.doc,o=t.base;if(o&&n)throw r.error("Base type should not be an alias");return n?new s.default({name:a,doc:i,base:o,origin:n}):new s.default({functional:!1,name:a,doc:i,base:o})}static variable(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var r=e.extend("variable",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw r.error(`Variable type ${t.type} not allowed`);if(!r.hasVariable(t.name))throw r.error("Undefined identifier "+t.name);return r.getVariable(t.name)}if(!r.hasType(typeObjToNestedArr(t.type)))throw r.error(`Type ${typeObjToString(t.type)} is not defined`);var n=r.getType(typeObjToNestedArr(t.type));return new f.default({type:n,isParam:!!t.isParam,guess:t.guess||null,name:t.name,doc:t.doc,tex:t.tex},r)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var r=null,n=null,a=null,o=!1;"defun"==t._type&&(r=(t=t).name,n=t.doc,a=t.tex,o=t.sealed);var l=e.extend("fun",r,t.location),u=null,f=t.params.map((t=>{if(!l.hasType(typeObjToNestedArr(t.type)))throw l.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,l);if(l.hasOwnVariable(e.name))throw l.error(`Parameter ${e.name} has already been declared`);return l.addVariable(e)})),h=null;switch(t._type){case"defun":if(!l.hasType(typeObjToNestedArr(t.rettype)))throw l.error(`Type ${typeObjToString(t.rettype)} is not defined`);var c=l.getType(typeObjToNestedArr(t.rettype));if(t.expr){if(h=PI.expr0(t.expr,l),!c.equals(h.type))throw l.error(`Expression type ${h.type} failed to match the return type ${c} of fun ${r}`)}else u=new s.default({functional:!0,from:f.map((t=>t.type)),to:c});break;case"funexpr":h=PI.expr0(t.expr,l),u=null;break;default:throw Error("wut")}if(!h&&o)throw l.error("Cannot seal a primitive fun");return new i.default({annotations:[],sealed:o,type:u,name:r,params:f,expr:h,doc:n,tex:a},l)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var r=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),n=PI.expr0(t.schema,r),i=t.args.map((t=>PI.expr0(t,r)));return new a.default({fun:n,unseal:t.unseal,args:i},r)}static metaexpr(t,e){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r);case"reduction":return PI.reduction(t,r);case"schemacall":return PI.schemacall(t,r);case"schemaexpr":return PI.schema(t,r);case"var":return PI.metavar(t,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var r=e;switch(t._type){case"funcall":return PI.funcall(t,r);case"funexpr":return PI.fun(t,r);case"var":return PI.variable(t,r);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var r=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var n=Number(t.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query @"+t.name);case"$":if(!r.has$(t.name))throw r.error(t.name+" is not defined");return r.get$(t.name);case"normal":if(!r.hasSchema(t.name))throw r.error(`Schema ${t.name} is not defined`);return r.getSchema(t.name);default:throw r.error("Unknown type "+t.type)}}static tee(t,e){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),n=t.left.map((t=>PI.metaexpr(t,r))),a=r.extend("tee.right",null,t.right.location);n.forEach((t=>a.hypotheses.push(t)));var i=t.def$s.map((t=>{var e=PI.def$(t,a);if(a.hasOwn$(e.name))throw a.error(t.name+" has already been declared");return a.add$(e)})),s=PI.metaexpr(t.right,a);return new u.default({left:n,def$s:i,right:s},r)}static def$(t,e){if("def$"!=t._type)throw Error("Assertion failed");var r=e.extend("def$",t.name,t.location),a=PI.metaexpr(t.expr,r);return new n.default({name:t.name,expr:a},r)}static schema(t,e){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");var r=null,n=!1,a=null,i=[];"defschema"==t._type&&(r=t.name,n=t.axiomatic,a=t.doc,i=t.annotations);var s=e.extend("schema",r,t.location),o=t.params.map((t=>{if(!s.hasType(typeObjToNestedArr(t.type)))throw s.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,s);if(s.hasOwnVariable(e.name))throw s.error(`Parameter ${e.name} has already been declared`);return s.addVariable(e)})),u=t.def$s.map((t=>{var e=PI.def$(t,s);if(s.hasOwn$(e.name))throw s.error(t.name+" has already been declared");return s.add$(e)})),f=PI.metaexpr(t.expr,s);return new l.default({doc:a,annotations:i,axiomatic:n,name:r,params:o,def$s:u,expr:f},s)}static schemacall(t,e){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),n=PI.metaexpr(t.schema,r),i=t.args.map((t=>PI.expr0(t,r)));return new a.default({fun:n,unseal:t.unseal,args:i},r)}static reduction(t,e){if("reduction"!=t._type)throw Error("Assertion failed");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),n=PI.metaexpr(t.subject,r),a=t.guesses?t.guesses.map((t=>t&&PI.expr0(t,r))):null,i=t.leftargs.map((t=>PI.metaexpr(t,r))),s=t.expected&&PI.metaexpr(t.expected,r);return new o.default({subject:n,guesses:a,leftargs:i,expected:s},r)}}e.default=PI},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(3),i=r(6),s=r(13),o=r(9),l=r(14),u=r(10),f=r(11),h=r(5);e.default=class ProofExplorer{static get(t,e,r){var c="&#x25C7;";if(!t.hasSchema(e))throw Error("wut");var d=t.getSchema(e),p=function recurse(t){return t instanceof l.default?Math.max(...t.leftargs.map(recurse),t.subject instanceof a.default&&t.subject.name||t.subject instanceof i.default&&s.isNameable(t.subject.fun)&&t.subject.fun.name?0:recurse(t.subject),1):t instanceof u.default?Math.max(...t.def$s.map((t=>recurse(t.expr))),recurse(t.expr))+1:t instanceof o.default?recurse(t.expr)+1:t instanceof f.default?Math.max(...t.left.map(recurse),...t.def$s.map((t=>recurse(t.expr))),recurse(t.right))+1:1}(d);function getHtmlLine(t,e,n,a,i){for(var s=e.length,{bbb:o=!1,rrb:l=!1}=i||{},u=e.map(((t,e,n)=>`<td class="${l&&e==n.length-1?"rrb":"brb"}">${t.map((t=>r(t.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),f=0;f<e.length;f++)for(;e[f].length;)e[f].pop();return`<tr><th>${t}</th>${u}<td ${o?'class="bbb" ':""}colspan="${p-s}">${n}</td>${a instanceof Array?a.map((t=>`<td>${t}</td>`)).join(""):`<td colspan="2">${a}</td>`}</tr>`}function exprToHtml(t,e){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:r(e?t.expandMeta(!0).toTeXString(!0):t.toTeXString(!0))}var m=0,g=function getTree(t,e,r){if(e.has(t))return[{_type:"R",ctr:++m,num:e.get(t),expr:t}];if(r.has(t))return[{_type:"R",ctr:++m,num:r.get(t),expr:t}];if(t instanceof l.default){var o=[],c=t.leftargs.map((t=>{if(e.has(t))return e.get(t);if(r.has(t))return r.get(t);var n=getTree(t,e,r);return o=o.concat(n),n[n.length-1].ctr})),p=null,g=[],y=e.get(t.subject)||r.get(t.subject)||!!(t.subject instanceof i.default&&r.has(t.subject.fun))&&(p=t.subject.args,r.get(t.subject.fun))||((v=t.subject)instanceof a.default&&v.name||v instanceof i.default&&s.isNameable(v.fun)&&v.fun.name?t.subject:(g=getTree(t.subject,e,r))[g.length-1].ctr);return[...o,...g,{_type:"E",ctr:++m,subject:y,args:p,leftargs:c,reduced:t.reduced}]}if(t instanceof i.default){if(e.has(t.fun))return[{_type:"RC",ctr:++m,schema:e.get(t.fun),args:t.args,expr:t}];if(r.has(t.fun))return[{_type:"RC",ctr:++m,schema:r.get(t.fun),args:t.args,expr:t}];if(t.fun instanceof u.default&&t.fun.name)return[{_type:"RCX",ctr:++m,expr:t}];if(!(t.fun instanceof u.default))return[{_type:"NP",ctr:++m,expr:t}];var _=getTree(t.fun,e,r);return[..._,{_type:"RC",ctr:++m,schema:_[_.length-1].ctr,args:t.args,expr:t}]}if(t instanceof h.default)return[{_type:"NP",ctr:++m,expr:t}];if(t instanceof a.default){if(t instanceof u.default&&t.name&&t!=d)return[{_type:"RS",ctr:++m,expr:t}];if(!t.expr)return[{_type:"NP",ctr:++m,expr:t}];r=new Map(r);var x=m+1,b=[];return t instanceof u.default&&t.def$s.forEach((t=>{var n=getTree(t.expr,e,r);b=b.concat(n);var a=n[n.length-1].ctr;r.set(t,a)})),[{_type:"V",$lines:b,lines:getTree(t.expr,e,r),params:t.params.slice(),ctr:[x,m]}]}if(t instanceof f.default){e=new Map(e);var w=[];x=m+1;t.left.forEach((t=>{e.set(t,++m),w.push({_type:"H",ctr:m,expr:t})})),r=new Map(r);b=[];return t.def$s.forEach((t=>{var n=getTree(t.expr,e,r);b=b.concat(n);var a=n[n.length-1].ctr;r.set(t,a)})),[{_type:"T",leftlines:w,$lines:b,rightlines:getTree(t.right,e,r),ctr:[x,m]}]}if(t instanceof n.default){if(!r.has(t))throw Error(t.name+" is not defined");return[{_type:"R",ctr:++m,num:r.get(t),expr:t.expr}]}return console.log("Unknown metaexpr",t),[{_type:"?",ctr:++m,expr:t}];var v}(d,new Map,new Map),y='<table class="explorer">';return y+=`<tr><th>#</th><th colspan="${p}">expr</th><th colspan="2">rule</th></tr>`,y+=function tree2html(t,e){return t.map((t=>{switch(t._type){case"V":return tree2html(t.$lines,e.concat([t.params]))+tree2html(t.lines,e.concat([t.params]));case"T":var r=e.concat([[]]),n="";if(0==t.leftlines.length)n+=getHtmlLine("",Array(e.length+1).fill([]),"","",{bbb:!0,rrb:!0});else n+=t.leftlines.map(((t,e,n)=>getHtmlLine(t.ctr,r,exprToHtml(t.expr,!0),"assumption",{bbb:e==n.length-1,rrb:!0}))).join("");return n+=tree2html(t.$lines,r),n+=tree2html(t.rightlines,r);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[c,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[c,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[c,`${exprToHtml(t.schema)} (${t.args.map((t=>exprToHtml(t))).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)}${t.args?" ("+t.args.map((t=>exprToHtml(t))).join(", ")+")":""} [${t.leftargs.map((t=>exprToHtml(t))).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(t.ctr,e,"Unknown type "+t._type,"")}})).join("")}(g[0].$lines.concat(g[0].lines),[]),y+="</table>"}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(3),i=r(2),s=r(5),o=r(21);class Scope{constructor(t,e){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.parent=t,this.root=t?t.root:this,e&&!(e instanceof o.default))throw Error("Assertion failed");this.trace=e||new o.default,this.baseType=t?t.baseType:null}extend(t,e,r){var n=new Scope(this,this.trace.extend(t,e,r));return this.hypotheses.forEach((t=>n.hypotheses.push(t))),n}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnType(t)));if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasOwnType(t))).every((t=>t))}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasType(t))).every((t=>t))}addType(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)||[...this.importMap.values()].filter((e=>e.hasType(t)))[0].getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map((t=>this.getType(t))),r=this.getType(t[t.length-1]);return new i.default({functional:!0,from:e,to:r})}hasOwnVariable(t){return this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnVariable(t)))}hasVariable(t){return this.hasOwnVariable(t)||!!this.parent&&this.parent.hasVariable(t)}addVariable(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getVariable(t){if(!this.hasVariable(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getVariable(t)||[...this.importMap.values()].filter((e=>e.hasVariable(t)))[0].getVariable(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnSchema(t)))}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)||[...this.importMap.values()].filter((e=>e.hasSchema(t)))[0].getSchema(t)}hasOwn$(t){return this.$Map.has(t)||[...this.importMap.values()].some((e=>e.hasOwn$(t)))}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof n.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$ variable ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$ variable ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)||[...this.importMap.values()].filter((e=>e.has$(t)))[0].get$(t)}}e.default=Scope},function(t,e,r){"use strict";(function(t){Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t){this.stack=t||[]}extend(t,e,r){return new StackTrace([[t,e,r]].concat(this.stack))}error(e){var r=void 0!==t&&t.argv[2];return new Error(e+"\n\tat "+(this.stack.length?this.stack.map((([t,e,n])=>`${t} ${e||"<anonymous>"} (${r||"<unknown>"}:${n.start.line}:${n.start.column})`)).join("\n\tat "):`<root> (${r||"<unknown>"}:1:1)`))}}e.default=StackTrace}).call(this,r(22))},function(t,e){var r,n,a=t.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(t){if(r===setTimeout)return setTimeout(t,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){n=defaultClearTimeout}}();var i,s=[],o=!1,l=-1;function cleanUpNextTick(){o&&i&&(o=!1,i.length?s=i.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!o){var t=runTimeout(cleanUpNextTick);o=!0;for(var e=s.length;e;){for(i=s,s=[];++l<e;)i&&i[l].run();l=-1,e=s.length}i=null,o=!1,function runClearTimeout(t){if(n===clearTimeout)return clearTimeout(t);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{return n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];s.push(new Item(t,e)),1!==s.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(t){return[]},a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}}])}));
//# sourceMappingURL=math.min.js.map