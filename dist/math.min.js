!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=10)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=0;class Node{constructor(t){this._id=++n,this.scope=t}toString(){return this.toIndentedString(0)}error(t){return this.scope?this.scope.error(t):new Error(t)}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t]))}static parseTeX(t){var e=!1,r=t.replace(/^!<prec=([0-9]+)>/,(t,r)=>(e=1*r,""));return{precedence:e,code:r}}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return!1}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<r[0]||e[0]==r[0]&&e[1]<r[1])}makeTeX(t,e,r){e=e||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,(t,r)=>e[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`).replace(/<<(.+?)>>/,(e,r)=>`\\href{#${t}}{${r}}`)}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Typevar extends n.default{constructor({type:t,isParam:e,guess:r,name:n,doc:a,tex:s},i){if(super(i),this._type="typevar",this.doc=a,this.tex=s,this.isParam=!!e,this.guess=r||null,t=t,"string"!=typeof n)throw this.error("Assertion failed");this.type=t,this.name=n}isProved(t){return t=t||[],super.isProved(t)}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`)}}`}}e.default=Typevar},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(t){if(super(),this._type="type",this.doc=t.doc,this.isBaseType=!!t.base,t.origin){if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");if(this.name=t.name,!(t.origin instanceof Type))throw this.error("!(o.origin instanceof Type)");this.isFunctional=t.origin.isFunctional,this.isSimple=t.origin.isSimple,this.origin=t.origin}else{if("boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.map(t=>t instanceof Type).some(t=>!t))throw this.error("o.from.map(f => f instanceof Type).some(e => !e)");if(!(t.to instanceof Type))throw this.error("!(o.to instanceof Type)");this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map(t=>t.toSimpleString()).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+"\\left["+this.resolve().from.map(t=>t.toTeXString()).join(" \\times ")+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof Type))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=Type},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(2),s=r(8),i=r(4),o=r(1);class Schema extends n.default{constructor({doc:t,tex:e,shouldValidate:r,axiomatic:i,type:l,name:c,native:h,params:u,def$s:p,expr:f},d){if(super(d),this._type="schema",this.doc=t,this.shouldValidate=r,e){var{precedence:m,code:y}=n.default.parseTeX(e);this.precedence=m,this.tex=y}else this.precedence=!1,this.tex=null;if(!c&&!h&&!f)throw this.error("Anonymous fun cannot be primitive");if(l&&f||f&&h||h&&l)throw this.error("no");if(!l&&!h&&!f)throw this.error("Cannot guess the type of a primitive fun");if(null!==c&&"string"!=typeof c)throw this.error("Assertion failed");if(!h&&f&&!(f.type instanceof a.default||f.type instanceof s.default))throw this.error("Assertion failed");if(this.axiomatic=i,this.name=c,h)this.native=h,this.def$s=[],this.expr=null,this.type=null;else{if(!(u instanceof Array)||u.map(t=>t instanceof o.default).some(t=>!t))throw this.error("Assertion failed");if(null!==f&&!(f instanceof n.default))throw this.error("Assertion failed");this.type=l||new(f.type instanceof a.default?a.default:s.default)({functional:!0,from:u.map(t=>t.type),to:f.type}),this.params=u,this.def$s=p||[],this.expr=f}this.proved=this.isProved()}isProved(t){return t=t||[],this.proved||!this.native&&super.isProved(t)||this.axiomatic||this.expr&&this.expr.isProved(t)}toIndentedString(t,e){return this.native?`∫ ${this.name} <native>`:[`∫ ${this.name||""}(${this.params.map(e=>e.toIndentedString(t)).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=n.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")}\\right)`,"\\mapsto "+i.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");if(this.shouldValidate){var r=`schema-${this.proved?"p":"np"}-${this.name}`;return e?this.native?`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}\\ (\\textrm{native})`:`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}(${this.params.map(t=>t.toTeXString(n.default.PREC_COMMA)+(t.guess?`: \\texttt{@${t.guess}}`:"")).join(", ")}):\\\\\\quad`+i.default.expandMetaAndFuncalls(this.expr).toTeXString(!0):`\\href{#${r}}\\mathsf{${n.default.escapeTeX(this.name)}}`}return e?this.expr?this.funcallToTeXString(this.params,n.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(n.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}\\mathrm{${n.default.escapeTeX(this.name)}}`}funcallToTeXString(t,e){return t=t.map(t=>t.toTeXString(this.tex?this.precedence:n.default.PREC_COMMA)),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`(${t.join(", ")})`}}e.default=Schema},function(t,e,r){"use strict";function iscall(t){return"schemacall"==t._type}function callee(t){if(iscall(t))return t.schema;throw console.log(t),Error()}function makecall(t,e){if("typevar"==t._type||"schema"==t._type)return new a.default({schema:t,args:e});throw console.log(t),Error()}Object.defineProperty(e,"__esModule",{value:!0});class ER{static substitute(t,e){switch(t._type){case"schemacall":return new a.default({schema:ER.substitute(t.schema,e),args:t.args.map(t=>ER.substitute(t,e))});case"schema":if(!t.expr)return e.get(t)||t;if(t.name)return e.get(t)||t;if(t.params.some(t=>e.has(t)))throw Error("Parameter collision");return new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.substitute(t.expr,e)});case"typevar":return e.get(t)||t;case"tee":var r=t.left.map(t=>ER.substitute(t,e)),i=ER.substitute(t.right,e);return new s.default({left:r,right:i});case"reduction":return ER.substitute(t.reduced,e);case"$var":return ER.substitute(t.expr,e);default:throw Error("Unknown type "+t._type)}}static call(t,e){if("schema"!=t._type)throw console.log(t),Error("Illegal type");if(!t.expr)throw Error("Cannot call a callable without a body");if(t.params.length!=e.length)throw Error("Illegal arguments length");for(var r=new Map,n=0;n<t.params.length;n++)r.set(t.params[n],e[n]);return ER.substitute(t.expr,r)}static expandCallOnce(t){if(!iscall(t))throw Error("Illegal type");if(iscall(callee(t)))return makecall(ER.expandCallOnce(callee(t)),t.args);var e=callee(t);if("schema"!=e._type)throw Error("Something's wrong");if(!e.expr)throw Error("Could not expand");return ER.call(e,t.args)}static expandMeta(t){if("native"in t&&t.native)return t;switch(t._type){case"tee":var e=t.left.map(ER.expandMeta),r=ER.expandMeta(t.right);return new s.default({left:e,right:r});case"schemacall":var i=ER.expandMeta(t.schema),o=t.args;return!i.expr||i.name&&!i.shouldValidate?new a.default({schema:i,args:o}):ER.expandMeta(ER.call(i,o));case"reduction":return ER.expandMeta(t.reduced);case"schema":return t.expr?"type"==t.type._type&&t.name?t:new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMeta(t.expr)}):t;case"typevar":return t;case"$var":return ER.expandMeta(t.expr);default:throw console.log(t),Error("Unknown metaexpr")}}static expandMetaAndFuncalls(t){switch(t._type){case"tee":var e=t.left.map(ER.expandMetaAndFuncalls),r=ER.expandMetaAndFuncalls(t.right);return new s.default({left:e,right:r});case"schema":return t.expr?"type"==t.type._type&&t.name?t:new n.default({shouldValidate:t.shouldValidate,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMetaAndFuncalls(t.expr)}):t;case"schemacall":var i=ER.expandMetaAndFuncalls(t.schema),o=t.args.map(ER.expandMetaAndFuncalls);return!i.expr||i.name&&!i.shouldValidate?new a.default({schema:i,args:o}):ER.expandMetaAndFuncalls(ER.call(i,o));case"reduction":return ER.expandMetaAndFuncalls(t.reduced);case"typevar":return t;case"$var":return ER.expandMetaAndFuncalls(t.expr);default:throw console.log(t),Error("Unknown metaexpr")}}static equals(t,e){var r=function recurse(t,e,n){if(t==e)return!0;if(!t.type.equals(e.type))return!1;if("reduction"==t._type)return r(t.reduced,e,n+1);if("reduction"==e._type)return r(t,e.reduced,n+1);if("$var"==t._type)return r(t.expr,e,n+1);if("$var"==e._type)return r(t,e.expr,n+1);if(iscall(t)&&iscall(e)){if(iscall(callee(t)))return r(ER.expandCallOnce(t),e,n+1);if(iscall(callee(e)))return r(t,ER.expandCallOnce(e),n+1);if(callee(t)==callee(e)||!callee(t).expr&&!callee(e).expr){if(callee(t)!=callee(e))return!1;if(!callee(t).expr&&!callee(e).expr){for(var a=0;a<t.args.length;a++)if(!r(t.args[a],e.args[a],n+1))return!1;return!0}if(t.args.every((a,s)=>r(t.args[s],e.args[s],n+1)))return!0}return callee(t).expr?r(ER.expandCallOnce(t),e,n+1):r(t,ER.expandCallOnce(e),n+1)}if(iscall(t))return(iscall(callee(t))||!!callee(t).expr)&&r(ER.expandCallOnce(t),e,n+1);if(iscall(e))return(iscall(callee(e))||!!callee(e).expr)&&r(t,ER.expandCallOnce(e),n+1);if("tee"==t._type){e=e;for(a=0;a<t.left.length;a++)if(!r(t.left[a],e.left[a],n+1))return!1;return r(t.right,e.right,n+1)}if(t.type.isFunctional){var s=[],o=t.type.resolve().from.length;for(a=0;a<o;a++)s.push(new i.default({isParam:!0,type:t.type.resolve().from[a],name:"$"+a}));return r(makecall(t,s),makecall(e,s),n+1)}return!1};ER.nequalscall++;var n=r(t,e,0);return n&&ER.nequalstrue++,n}static chain(t){if(!t.every(t=>"tee"==t._type))throw Error("no");return ER.expandMetaAndFuncalls(t.reduceRight((t,e)=>{for(var r=0;r<t.left.length;r++)if(ER.equals(e.right,t.left[r])){var n=t.left.slice(0,r).concat(e.left).concat(t.left.slice(r+1));return new s.default({left:n,right:t.right})}throw Error(`Chaining failed:\n\n--- LEFT ---\n${e}\n------------\n\n--- RIGHT ---\n${t}\n-------------`)}))}}e.default=ER,ER.nequalscall=0,ER.nequalstrue=0,ER.nrecursecall=0,ER.nrecursetrue=0;const n=r(3),a=r(5),s=r(6),i=r(1)},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(1),s=r(3);class Schemacall extends n.default{constructor({schema:t,args:e},r){if(super(r),this._type="schemacall",t.type.isSimple)throw this.error(t.name+" is not callable");if(!(e instanceof Array)||e.map(t=>t instanceof n.default).some(t=>!t))throw this.error("Assertion failed");var a=t.type.resolve(),s=a.from,i=e.map(t=>t.type);if(s.length!=i.length)throw this.error(`Invalid number of arguments (expected ${s.length}): ${i.length}`);for(var o=0;o<s.length;o++)if(!s[o].equals(i[o]))throw this.error(`Argument #${o+1} has illegal argument type (expected ${s[o]}): ${i[o]}`);this.schema=t,this.type=a.to,this.args=e}isProved(t){return t=t||[],super.isProved(t)||this.schema.isProved(t)}toIndentedString(t,e){var r=this.args.map(e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1));return r.join("").length<=50?(r=(r=this.args.map(e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t))).join(", "),this.schema.shouldValidate?[(this.schema.name||`(${this.schema})`)+"(",r,")"].join(""):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(t)+")")+"(",r,")"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),this.schema.shouldValidate?[(this.schema.name||`(${this.schema.toIndentedString(t)})`)+"(","\t"+r,")"].join("\n"+"\t".repeat(t)):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(t)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.schema.shouldValidate)return(this.schema.name?`\\href{#schema-${this.schema.proved?"p":"np"}-${this.schema.name}}{\\textsf{${n.default.escapeTeX(this.schema.name)}}}`:this.schema.toTeXString(!1))+`(${this.args.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")})`;if(this.schema instanceof s.default)return this.schema.funcallToTeXString(this.args,t);var r=this.args.map(t=>t.toTeXString(n.default.PREC_COMMA));return(this.schema.name&&"typevar"!=this.schema._type?1==this.schema.name.length?n.default.escapeTeX(this.schema.name):`\\mathrm{${n.default.escapeTeX(this.schema.name)}}`:this.schema.toTeXString(!1))+`(${r.join(", ")})`}}e.default=Schemacall},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(8),s=r(4);class Tee extends n.default{constructor({left:t,def$s:e,right:r},i){if(super(i),this._type="tee",this.precedence=n.default.PREC_COMMA,!(t instanceof Array&&t.every(t=>["type","metatype"].includes(t.type._type))))throw console.log(t),this.error("Assertion failed");if(e&&!(e instanceof Array&&e.every(t=>"$var"==t._type)))throw this.error("Assertion failed");if(!["type","metatype"].includes(r.type._type))throw console.log(r),this.error("Assertion failed");if(r.type.isFunctional)throw this.error("RHS of a rule cannot be a schema");this.left=t.reduce((t,e)=>{for(var r=0;r<t.length;r++)if(s.default.equals(t[r],e))return t;return t.push(e),t},[]),this.def$s=e||[],this.right=r,this.type=new a.default({functional:!1,left:t.map(t=>t.type),right:r.type})}isProved(t){return t=t||[],super.isProved(t)||this.right.isProved(t.concat(this.left))}toIndentedString(t,e){return this.left.length?["\t"+this.left.map(e=>e.toIndentedString(t+1)).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var r=s.default.expandMetaAndFuncalls(this);return[this.shouldConsolidate(t)?"\\left(":"",`{${r.left.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")} \\vdash ${r.right.toTeXString(n.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},,function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(2);class MetaType extends n.default{constructor(t){if(super(),this._type="metatype","boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.some(t=>!(t instanceof a.default)))throw this.error("o.from.some(f => !(f instanceof Type))");if(!(t.to instanceof MetaType))throw this.error("!(o.to instanceof MetaType)");if(t.to.isFunctional)throw this.error("Functional metatype in functional metatype is not supported");this.from=t.from,this.to=t.to}else{if(!(t.left instanceof Array))throw this.error("left should be an array");this.left=t.left,this.right=t.right}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class $var extends n.default{constructor({name:t,expr:e},r){if(super(r),this._type="$var",!t||!e)throw this.error("Assertion failed");this.type=e.type,this.name=t,this.expr=e}isProved(t){return t=t||[],super.isProved(t)||this.expr.isProved(t)}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${n.default.escapeTeX(this.name)}}`}}e.default=$var},function(t,e,r){var n;n=r(11).default;var a=r(12).default;t.exports={grammar:n,Program:a}},function(t,e,r){"use strict";r.r(e),e.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\tdoc = doc && doc[0];\r\n\t\t\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\t// native schemata\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"native" __\r\n\t"schema" __\r\n\tname:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tnative: true,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/\r\n\t// non-native schemata\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tnative: false,\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:("," _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\t{return a || []}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0],\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i],\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:expr0 _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _ expr:expr0 _ "}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\t// right associativity\r\n\ta:(\r\n\t\tmetaexpr_internal_1\r\n\t) _ "~" _ b:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject: {\r\n\t\t\t\t_type: \'var\',\r\n\t\t\t\ttype: \'normal\',\r\n\t\t\t\tname: \'cut\',\r\n\t\t\t\tlocation: location()\r\n\t\t\t},\r\n\t\t\tleftargs: [a, b],\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\nmetaexpr_internal_1 =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_2 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_2 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\tright:metaexpr_internal_1\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tdef$s: defdollars,\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_2\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_2 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ndefdollar =\r\n\tname:dollar_ident _\r\n\t\'=\' _\r\n\texpr:metaexpr _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'def$\',\r\n\t\t\tname,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\t}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\tat_var\r\n\t/ dollar_var\r\n\t/ plain_var\r\n\r\nat_var =\r\n\tname:at_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'@\',\r\n\t\t\tname: name.slice(1),\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndollar_var =\r\n\tname:dollar_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'$\',\r\n\t\t\tname: name,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nplain_var =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'normal\',\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"axiomatic"\r\n\t/ "base"\r\n\t/ "native"\r\n\t/ "schema"\r\n\t/ "type";\r\n\r\nident =\r\n\t$(!keyword [a-zA-Z0-9_]+)\r\n\r\nat_ident =\r\n\t$(\'@\' [a-zA-Z0-9_]+)\r\n\r\ndollar_ident =\r\n\t$(\'$\' [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(13),a=r(16),s=r(4),i=r(6),o=r(2);e.default=class Program{constructor(){this.scope=new n.default(null),this.nativeMap={schema:{cut:{get:(t,e)=>s.default.chain(t.map(s.default.expandMeta))},mpu:{get:(t,e)=>{if(1!=t.length)throw Error("wut");var r=t[0];if(!e.baseType)throw Error("Base type not found");var n=e.baseType,a=s.default.expandMeta(r),l=s.default.expandMetaAndFuncalls(a.right);if("tee"!=a._type)throw Error("wut");if(!e.hasTypevar("I"))throw Error("Typevar I not found");var c=e.getTypevar("I");if(!c.type.equals(new o.default({functional:!0,from:[n,n],to:n})))throw Error("Wrong type for I");if("schemacall"!=l._type||l.schema!=c)throw console.log(l),Error("wut");return new i.default({left:a.left.concat([l.args[0]]),right:l.args[1]})}}}}}feed(t){t.forEach(t=>{switch(t._type){case"typedef":var e=a.default.type(t,this.scope);if(this.scope.hasType(e.name))throw e.scope.error(`Type ${e.name} has already been declared`);this.scope.addType(e);break;case"defv":var r=a.default.typevar(t,this.scope);if(this.scope.hasTypevar(r.name))throw r.scope.error(`Definition ${r.name} has already been declared`);this.scope.addTypevar(r);break;case"defun":var n=a.default.fun(t,this.scope);if(this.scope.hasTypevar(n.name))throw n.scope.error(`Definition ${n.name} has already been declared`);this.scope.addFun(n);break;case"defschema":var s=a.default.schema(t,this.scope,this.nativeMap);if(this.scope.hasSchema(s.name))throw s.scope.error(`Schema ${s.name} has already been declared`);this.scope.addSchema(s);break;default:throw Error("Unknown line type "+t._type)}})}evaluate(t){switch(t._type){case"typedef":case"defv":case"defun":case"defschema":case"tee":case"reduction":case"schemacall":case"var":case"schemaexpr":return a.default[{typedef:"type",defv:"typevar",defun:"fun",defschema:"schema",tee:"tee",reduction:"reduction",schemacall:"schemacall",var:"metavar",schemaexpr:"schemaexpr"}[t._type]](t,this.scope);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){var r="&#x25C7;";if(!this.scope.schemaMap.has(t))throw Error("wut");var n=this.scope.schemaMap.get(t),a=function recurse(t){switch(t._type){case"reduction":return Math.max(...t.leftargs.map(recurse),"schema"==t.subject._type&&t.subject.name||"schemacall"==t.subject._type&&t.subject.schema.name?0:recurse(t.subject),1);case"schema":return recurse(t.expr)+1;case"tee":return Math.max(...t.left.map(recurse),...t.def$s.map(t=>recurse(t.expr)),recurse(t.right))+1;case"schemacall":default:return 1}}(n);function getHtmlLine(t,r,n,s,i){for(var o=r.length,l=r.map(t=>`<td class="brb">${t.map(t=>e(t.toTeXString(!0))).join(", ")}</td>`).join(""),c=0;c<r.length;c++)for(;r[c].length;)r[c].pop();return`<tr><th>${t}</th>${l}<td ${i?'class="bbb"':""} colspan="${a-o}">${n}</td>${s instanceof Array?s.map(t=>`<td>${t}</td>`).join(""):`<td colspan="2">${s}</td>`}</tr>`}function exprToHtml(t,r){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:e(r?s.default.expandMetaAndFuncalls(t).toTeXString(!0):t.toTeXString(!0))}var i=0,o=function getTree(t,e,r){if(e.has(t))return[{_type:"R",ctr:++i,num:e.get(t),expr:t}];if(r.has(t))return[{_type:"R",ctr:++i,num:r.get(t),expr:t}];switch(t._type){case"reduction":var a=[],s=t.leftargs.map(t=>{if(e.has(t))return e.get(t);if(r.has(t))return r.get(t);var n=getTree(t,e,r);return a=a.concat(n),n[n.length-1].ctr}),o=[],l=e.get(t.subject)||r.get(t.subject)||("schema"==(f=t.subject)._type&&f.name||"schemacall"==f._type&&f.schema.name?t.subject:(o=getTree(t.subject,e,r))[o.length-1].ctr);return[...a,...o,{_type:"E",ctr:++i,subject:l,leftargs:s,reduced:t.reduced}];case"schemacall":if(e.has(t.schema))return[{_type:"RC",ctr:++i,schema:e.get(t.schema),args:t.args,expr:t}];if(r.has(t.schema))return[{_type:"RC",ctr:++i,schema:r.get(t.schema),args:t.args,expr:t}];if(t.schema.shouldValidate&&t.schema.name)return[{_type:"RCX",ctr:++i,expr:t}];if(!t.schema.shouldValidate)return[{_type:"NP",ctr:++i,expr:t}];var c=getTree(t.schema,e,r);return[...c,{_type:"RC",ctr:++i,schema:c[c.length-1].ctr,args:t.args,expr:t}];case"typevar":return[{_type:"NP",ctr:++i,expr:t}];case"schema":if(t.shouldValidate&&t.name&&t!=n)return[{_type:"RS",ctr:++i,expr:t}];if(!t.expr)return[{_type:"NP",ctr:++i,expr:t}];r=new Map(r);var h=[];return t.def$s.forEach(t=>{var n=getTree(t.expr,e,r);h=h.concat(n);var a=n[n.length-1].ctr;r.set(t,a)}),[{_type:"V",$lines:h,lines:getTree(t.expr,e,r),params:t.params.slice(),ctr:i}];case"tee":e=new Map(e);var u=[],p=i+1;t.left.forEach(t=>{e.set(t,++i),u.push({_type:"H",ctr:i,expr:t})}),r=new Map(r);h=[];return t.def$s.forEach(t=>{var n=getTree(t.expr,e,r);h=h.concat(n);var a=n[n.length-1].ctr;r.set(t,a)}),[{_type:"T",leftlines:u,$lines:h,rightlines:getTree(t.right,e,r),ctr:[p,i]}];case"$var":if(!r.has(t))throw Error(t.name+" is not defined");return[{_type:"R",ctr:++i,num:r.get(t),expr:t.expr}];default:return console.error(t.error("Unknown type "+t._type)),[{_type:"?",ctr:++i,expr:t}]}var f}(n,new Map,new Map),l='<table class="explorer">';return l+=`<tr><th>#</th><th colspan="${a}">expr</th><th colspan="2">rule</th></tr>`,l+=function tree2html(t,e){return t.map(t=>{switch(t._type){case"V":return tree2html(t.$lines,e.concat([t.params]))+tree2html(t.lines,e.concat([t.params]));case"T":var n=e.concat([[]]),a="";if(0==t.leftlines.length)a+=getHtmlLine("",Array(e.length+1).fill([]),"","",!0);else a+=t.leftlines.map((t,e,r)=>getHtmlLine(t.ctr,n,exprToHtml(t.expr,!0),"assumption",e==r.length-1)).join("");return a+=tree2html(t.$lines,n),a+=tree2html(t.rightlines,n);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,`${exprToHtml(t.schema)} (${t.args.map(t=>exprToHtml(t)).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)} [${t.leftargs.map(t=>exprToHtml(t)).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(t.ctr,e,"Unknown type "+t._type,"")}}).join("")}(o[0].$lines.concat(o[0].lines),[]),l+="</table>"}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(2),a=r(1),s=r(3),i=r(14),o=r(9);class Scope{constructor(t,e){if(this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.parent=t,this.root=t?t.root:this,e&&!(e instanceof i.default))throw Error("Assertion failed");this.trace=e||new i.default,this.baseType=t?t.baseType:null}extend(t,e,r){var n=new Scope(this,this.trace.extend(t,e,r));return this.hypotheses.forEach(t=>n.hypotheses.push(t)),n}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map(t=>this.hasOwnType(t)).every(t=>t)}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map(t=>this.hasType(t)).every(t=>t)}addType(t){if(!(t instanceof n.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map(t=>this.getType(t)),r=this.getType(t[t.length-1]);return new n.default({functional:!0,from:e,to:r})}hasOwnTypevar(t){return this.defMap.has(t)}hasTypevar(t){return this.hasOwnTypevar(t)||!!this.parent&&this.parent.hasTypevar(t)}addTypevar(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnTypevar(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnTypevar(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getTypevar(t){if(!this.hasTypevar(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getTypevar(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)}hasOwn$(t){return this.$Map.has(t)}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$var ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$var ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)}}e.default=Scope},function(t,e,r){"use strict";(function(t){Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t){this.stack=t||[]}extend(t,e,r){return new StackTrace([[t,e,r]].concat(this.stack))}error(e){var r=void 0!==t&&t.argv[2];return new Error(e+"\n\tat "+(this.stack.length?this.stack.map(([t,e,n])=>`${t} ${e||"<anonymous>"} (${r||"code.math"}:${n.start.line}:${n.start.column})`).join("\n\tat "):`<root> (${r||"code.math"}:1:1)`))}}e.default=StackTrace}).call(this,r(15))},function(t,e){var r,n,a=t.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(t){if(r===setTimeout)return setTimeout(t,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){n=defaultClearTimeout}}();var s,i=[],o=!1,l=-1;function cleanUpNextTick(){o&&s&&(o=!1,s.length?i=s.concat(i):l=-1,i.length&&drainQueue())}function drainQueue(){if(!o){var t=runTimeout(cleanUpNextTick);o=!0;for(var e=i.length;e;){for(s=i,i=[];++l<e;)s&&s[l].run();l=-1,e=i.length}s=null,o=!1,function runClearTimeout(t){if(n===clearTimeout)return clearTimeout(t);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{return n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];i.push(new Item(t,e)),1!==i.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(t){return[]},a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(2),a=r(1),s=r(6),i=r(3),o=r(5),l=r(17),c=r(9);function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var r=e.extend("type",t.name,t.location),a=t.origin?r.getType(typeObjToNestedArr(t.origin)):null,s=t.name,i=t.doc,o=t.base;if(o&&a)throw r.error("Base type should not be an alias");return a?new n.default({name:s,doc:i,base:o,origin:a}):new n.default({functional:!1,name:s,doc:i,base:o})}static typevar(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var r=e.extend("typevar",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw r.error(`Variable type ${t.type} not allowed`);if(!r.hasTypevar(t.name))throw r.error("Undefined identifier "+t.name);return r.getTypevar(t.name)}if(!r.hasType(typeObjToNestedArr(t.type)))throw r.error(`Type ${typeObjToString(t.type)} is not defined`);var n=r.getType(typeObjToNestedArr(t.type));return new a.default({type:n,isParam:!!t.isParam,guess:t.guess||null,name:t.name,doc:t.doc,tex:t.tex},r)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var r=null,a=null,s=null;"defun"==t._type&&(r=(t=t).name,a=t.doc,s=t.tex);var o=e.extend("fun",r,t.location),l=null,c=t.params.map(t=>{if(!o.hasType(typeObjToNestedArr(t.type)))throw o.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.typevar(t,o);if(o.hasOwnTypevar(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return o.addTypevar(e)}),h=null;switch(t._type){case"defun":if(!o.hasType(typeObjToNestedArr(t.rettype)))throw o.error(`Type ${typeObjToString(t.rettype)} is not defined`);var u=o.getType(typeObjToNestedArr(t.rettype));if(t.expr){if(h=PI.expr0(t.expr,o),!u.equals(h.type))throw o.error(`Expression type ${h.type} failed to match the return type ${u} of fun ${r}`)}else l=new n.default({functional:!0,from:c.map(t=>t.type),to:u});break;case"funexpr":h=PI.expr0(t.expr,o),l=null;break;default:throw Error("wut")}return new i.default({shouldValidate:!1,name:r,type:l,params:c,expr:h,doc:a,tex:s},o)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var r=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),n=PI.expr0(t.schema,r),a=t.args.map(t=>PI.expr0(t,r));return new o.default({schema:n,args:a},r)}static metaexpr(t,e){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r);case"reduction":return PI.reduction(t,r);case"schemacall":return PI.schemacall(t,r);case"schemaexpr":return PI.schema(t,r);case"var":return PI.metavar(t,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var r=e;switch(t._type){case"funcall":return PI.funcall(t,r);case"funexpr":return PI.fun(t,r);case"var":return PI.typevar(t,r);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var r=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var n=Number(t.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query @"+t.name);case"$":if(!r.has$(t.name))throw r.error(t.name+" is not defined");return r.get$(t.name);case"normal":if(!r.hasSchema(t.name))throw r.error(`Schema ${t.name} is not defined`);return r.getSchema(t.name);default:throw r.error("Unknown type "+t.type)}}static tee(t,e){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),n=t.left.map(t=>PI.metaexpr(t,r)),a=r.extend("tee.right",null,t.right.location);n.forEach(t=>a.hypotheses.push(t));var i=t.def$s.map(t=>{var e=PI.def$(t,a);if(a.hasOwn$(e.name))throw a.error(t.name+" has already been declared");return a.add$(e)}),o=PI.metaexpr(t.right,a);return new s.default({left:n,def$s:i,right:o},r)}static def$(t,e){if("def$"!=t._type)throw Error("Assertion failed");var r=e.extend("def$",t.name,t.location),n=PI.metaexpr(t.expr,r);return new c.default({name:t.name,expr:n},r)}static schema(t,e,r){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");r=r||{};var n=null,a=!1,s=null;"defschema"==t._type&&(n=t.name,a=t.axiomatic,s=t.doc);var o=e.extend("schema",n,t.location);if("defschema"==t._type&&t.native){if(!r.schema[n])throw o.error(`Native code for native schema ${n} not found`);var l={get:t=>r.schema[n].get(t,o)};return new i.default({shouldValidate:!0,axiomatic:a,name:n,native:l,doc:t.doc},o)}var c=t.params.map(t=>{if(!o.hasType(typeObjToNestedArr(t.type)))throw o.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.typevar(t,o);if(o.hasOwnTypevar(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return o.addTypevar(e)}),h=t.def$s.map(t=>{var e=PI.def$(t,o);if(o.hasOwn$(e.name))throw o.error(t.name+" has already been declared");return o.add$(e)}),u=PI.metaexpr(t.expr,o);return new i.default({shouldValidate:!0,axiomatic:a,name:n,params:c,def$s:h,expr:u,doc:s},o)}static schemacall(t,e){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),n=PI.metaexpr(t.schema,r),a=t.args.map(t=>PI.expr0(t,r));return new o.default({schema:n,args:a},r)}static reduction(t,e){if("reduction"!=t._type)throw Error("Assertion failed");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),n=PI.metaexpr(t.subject,r),a=t.guesses?t.guesses.map(t=>t&&PI.expr0(t,r)):null,s=t.leftargs.map(t=>PI.metaexpr(t,r));return new l.default({subject:n,guesses:a,leftargs:s},r)}}e.default=PI},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(5),s=r(4);class Reduction extends n.default{constructor({subject:t,guesses:e,leftargs:r},i){if(super(i),this._type="reduction",t.native||"schema"!=t._type){if(e)throw this.error("Something's wrong")}else{t.params.forEach((t,r)=>{if(!(e&&e[r]||t.guess))throw this.error(`Argument #${r+1} could not be guessed`)});var o=t.params.map((n,a)=>e&&e[a]?e[a]:this.query(n.guess,s.default.expandMeta(t.expr).left,r));t=new a.default({schema:t,args:o},i)}if(!(t.native||"metatype"==t.type._type&&t.type.isSimple))throw this.error("Subject is not reducible");if(!(r instanceof Array)||r.map(t=>t instanceof n.default).some(t=>!t))throw this.error("Assertion failed");if(this.subject=t,this.leftargs=r,t.native)this.reduced=t.native.get(r),this.type=this.reduced.type;else{var l=t.type.left,c=r.map(t=>t.type);if(l.length!=c.length)throw this.error(`Invalid number of arguments (expected ${l.length}): ${c.length}`);for(let t=0;t<l.length;t++)if(!l[t].equals(c[t]))throw this.error(`Illegal argument type (expected ${l[t]}): ${c[t]}`);this.type=t.type.right;var h=s.default.expandMetaAndFuncalls(t);if("tee"!=h._type)throw this.error("Assertion failed");for(let t=0;t<h.left.length;t++)if(!s.default.equals(h.left[t],r[t]))throw this.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${s.default.expandMetaAndFuncalls(h.left[t])}\n----------------\n\n--- RECEIVED ---\n${s.default.expandMetaAndFuncalls(r[t])}\n----------------`);this.reduced=h.right}}isProved(t){return t=t||[],super.isProved(t)||this.subject.isProved(t)&&this.leftargs.every(e=>e.isProved(t))}query(t,e,r){if(0==t.length)throw this.error("wut");if(!(1<=1*t[0]&&1*t[0]<=r.length))throw this.error(`Cannot dereference @${t}: antecedent index out of range`);var n=e[1*t[0]-1],a=r[1*t[0]-1],i=this;return function recurse(t,e,r,n){if(r=s.default.expandMetaAndFuncalls(r),t.length<=n)return r;if(/[0-9]/.test(t[n])){var a=1*t[n];if("tee"==e._type&&"tee"==r._type){if(e.left.length!=r.left.length)throw i.error(`Cannot dereference @${t}: antecedent length mismatch`);if(!(1<=a&&a<=r.left.length))throw i.error(`Cannot dereference @${t}: antecedent index out of range`);return recurse(t,e.left[a-1],r.left[a-1],n+1)}for(;;){if(!e.schema||!r.schema)throw i.error("Cannot dereference @"+t);if(s.default.equals(e.schema,r.schema))break;if(!r.schema.expr)throw i.error("Cannot dereference @"+t);r=s.default.expandCallOnce(r)}if(!r.args||!(1<=a&&a<=r.args.length))throw i.error("Cannot dereference @"+t);return recurse(t,e.args[a-1],r.args[a-1],n+1)}if("r"==t[n]){if("tee"==e._type&&"tee"==r._type)return recurse(t,e.right,r.right,n+1);throw i.error("Cannot dereference @"+t)}throw i.error("Cannot dereference @"+t)}(t,n,a,1)}toIndentedString(t,e){var r=this.leftargs.map(e=>e.toIndentedString(t+1));return r.join("").length<=50?(r=(r=this.leftargs.map(e=>e.toIndentedString(t))).join(", "),[this.subject.toIndentedString(t)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+r,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map(t=>t.toTeXString(n.default.PREC_COMMA)).join(", ")}]`}}e.default=Reduction}])}));
//# sourceMappingURL=math.min.js.map