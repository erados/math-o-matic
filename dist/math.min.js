!function webpackUniversalModuleDefinition(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.math=t():e.math=t()}("undefined"!=typeof self?self:this,(function(){return function(e){var t={};function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},__webpack_require__.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.t=function(e,t){if(1&t&&(e=__webpack_require__(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)__webpack_require__.d(r,n,function(t){return e[t]}.bind(null,n));return r},__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=9)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=0;class Node{constructor(e){this._id=++n,this.scope=e}toString(){return this.toIndentedString(0)}error(e){return this.scope?this.scope.error(e):new Error(e)}static escapeTeX(e){return e.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,e=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[e]))}static parseTeX(e){var t=!1,r=e.replace(/^!<prec=([0-9]+)>/,(e,r)=>(t=1*r,""));return{precedence:t,code:r}}isProved(e){e=e||[];for(var t=0;t<e.length;t++)if(e[t]==this)return!0;return!1}static normalizePrecedence(e){if(!1===e)return[0,0];if(!0===e)return[2,0];if("number"==typeof e)return[0,e];if(!(e instanceof Array&&2==e.length))throw console.log(e),Error("wut");return e}shouldConsolidate(e){var t=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(e||!1);return(0!=t[0]||0!=t[1])&&!(t[0]<r[0]||t[0]==r[0]&&t[1]<r[1])}makeTeX(e,t,r){t=t||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,(e,r)=>t[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`).replace(/<<(.+?)>>/,(t,r)=>`\\href{#${e}}{${r}}`)}}t.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0);class Typevar extends n.default{constructor({type:e,isParam:t,guess:r,name:n,doc:a,tex:s},i){if(super(i),this._type="typevar",this.doc=a,this.tex=s,this.isParam=!!t,this.guess=r||null,e=e,"string"!=typeof n)throw this.error("Assertion failed");this.type=e,this.name=n}isProved(e){return e=e||[],super.isProved(e)}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(e,t){return`${t?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(e,t){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`)}}`}}t.default=Typevar},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(e){if(super(),this._type="type",this.doc=e.doc,this.isBaseType=!!e.base,e.origin){if("string"!=typeof e.name)throw this.error("typeof o.name != 'string'");if(this.name=e.name,!(e.origin instanceof Type))throw this.error("!(o.origin instanceof Type)");this.isFunctional=e.origin.isFunctional,this.isSimple=e.origin.isSimple,this.origin=e.origin}else{if("boolean"!=typeof e.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=e.functional,this.isSimple=!e.functional,e.functional){if(e.from.map(e=>e instanceof Type).some(e=>!e))throw this.error("o.from.map(f => f instanceof Type).some(e => !e)");if(!(e.to instanceof Type))throw this.error("!(o.to instanceof Type)");this.from=e.from,this.to=e.to}else{if("string"!=typeof e.name)throw this.error("typeof o.name != 'string'");this.name=e.name}}}toSimpleString(){if(this.name)return this.name;var e=this.resolve();return`[${e.from.map(e=>e.toSimpleString()).join(", ")} -> ${e.to.toSimpleString()}]`}toIndentedString(e){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(e){return this.isSimple||!e&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map(e=>e.toTeXString()).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(e){if(!(e instanceof Type))return!1;if(this.origin)return this.origin.equals(e);if(e.origin)return this.equals(e.origin);if(this.isSimple!=e.isSimple)return!1;if(this.isSimple)return this===e;if(this.from.length!=e.from.length)return!1;for(var t=0;t<this.from.length;t++)if(!this.from[t].equals(e.from[t]))return!1;return this.to.equals(e.to)}}t.default=Type},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(2),s=r(6),i=r(4),o=r(1);class Schema extends n.default{constructor({doc:e,tex:t,shouldValidate:r,axiomatic:i,type:l,name:c,params:h,def$s:u,expr:p},f){if(super(f),this._type="schema",this.doc=e,this.shouldValidate=r,t){var{precedence:d,code:m}=n.default.parseTeX(t);this.precedence=d,this.tex=m}else this.precedence=!1,this.tex=null;if(!c&&!p)throw this.error("Anonymous fun cannot be primitive");if(l&&p)throw this.error("no");if(!l&&!p)throw this.error("Cannot guess the type of a primitive fun");if(null!==c&&"string"!=typeof c)throw this.error("Assertion failed");if(p&&!(p.type instanceof a.default||p.type instanceof s.default))throw this.error("Assertion failed");if(this.axiomatic=i,this.name=c,!(h instanceof Array)||h.map(e=>e instanceof o.default).some(e=>!e))throw this.error("Assertion failed");if(null!==p&&!(p instanceof n.default))throw this.error("Assertion failed");this.type=l||new(p.type instanceof a.default?a.default:s.default)({functional:!0,from:h.map(e=>e.type),to:p.type}),this.params=h,this.def$s=u||[],this.expr=p,this.proved=this.isProved()}isProved(e){return e=e||[],this.proved||super.isProved(e)||this.axiomatic||this.expr&&this.expr.isProved(e)}toIndentedString(e,t){return[`∫ ${this.name||""}(${this.params.map(t=>t.toIndentedString(e)).join(", ")}) => {`,"\t"+this.expr.toIndentedString(e+1),"}"].join("\n"+"\t".repeat(e))}toTeXString(e,t){if(!this.name)return this.precedence=n.default.PREC_FUNEXPR,[this.shouldConsolidate(e)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map(e=>e.toTeXString(n.default.PREC_COMMA)).join(", ")}\\right)`,"\\mapsto "+i.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(e)?"\\right)":""].join("");if(this.shouldValidate){var r=`schema-${this.proved?"p":"np"}-${this.name}`;return t?`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}(${this.params.map(e=>e.toTeXString(n.default.PREC_COMMA)+(e.guess?`: \\texttt{@${e.guess}}`:"")).join(", ")}):\\\\\\quad`+i.default.expandMetaAndFuncalls(this.expr).toTeXString(!0):`\\href{#${r}}\\mathsf{${n.default.escapeTeX(this.name)}}`}return t?this.expr?this.funcallToTeXString(this.params,n.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(n.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,e):`\\href{#def-${this.name}}\\mathrm{${n.default.escapeTeX(this.name)}}`}funcallToTeXString(e,t){return e=e.map(e=>e.toTeXString(this.tex?this.precedence:n.default.PREC_COMMA)),this.tex?this.makeTeX("def-"+this.name,e,t):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`(${e.join(", ")})`}}t.default=Schema},function(e,t,r){"use strict";function iscall(e){return"schemacall"==e._type}function callee(e){if(iscall(e))return e.schema;throw console.log(e),Error()}function makecall(e,t){if("typevar"==e._type||"schema"==e._type)return new a.default({schema:e,args:t});throw console.log(e),Error()}Object.defineProperty(t,"__esModule",{value:!0});class ER{static substitute(e,t){switch(e._type){case"schemacall":return new a.default({schema:ER.substitute(e.schema,t),args:e.args.map(e=>ER.substitute(e,t))});case"schema":if(!e.expr)return t.get(e)||e;if(e.name)return t.get(e)||e;if(e.params.some(e=>t.has(e)))throw Error("Parameter collision");return new n.default({shouldValidate:e.shouldValidate,axiomatic:e.axiomatic,name:null,params:e.params,expr:ER.substitute(e.expr,t)});case"typevar":return t.get(e)||e;case"tee":var r=e.left.map(e=>ER.substitute(e,t)),i=ER.substitute(e.right,t);return new s.default({left:r,right:i});case"reduction":return ER.substitute(e.reduced,t);case"$var":return ER.substitute(e.expr,t);default:throw Error("Unknown type "+e._type)}}static call(e,t){if("schema"!=e._type)throw console.log(e),Error("Illegal type");if(!e.expr)throw Error("Cannot call a callable without a body");if(e.params.length!=t.length)throw Error("Illegal arguments length");for(var r=new Map,n=0;n<e.params.length;n++)r.set(e.params[n],t[n]);return ER.substitute(e.expr,r)}static expandCallOnce(e){if(!iscall(e))throw Error("Illegal type");if(iscall(callee(e)))return makecall(ER.expandCallOnce(callee(e)),e.args);var t=callee(e);if("schema"!=t._type)throw Error("Something's wrong");if(!t.expr)throw Error("Could not expand");return ER.call(t,e.args)}static expandMeta(e){switch(e._type){case"tee":var t=e.left.map(ER.expandMeta),r=ER.expandMeta(e.right);return new s.default({left:t,right:r});case"schemacall":var i=ER.expandMeta(e.schema),o=e.args;return!i.expr||i.name&&!i.shouldValidate?new a.default({schema:i,args:o}):ER.expandMeta(ER.call(i,o));case"reduction":return ER.expandMeta(e.reduced);case"schema":return e.expr?"type"==e.type._type&&e.name?e:new n.default({shouldValidate:e.shouldValidate,axiomatic:e.axiomatic,name:null,params:e.params,expr:ER.expandMeta(e.expr)}):e;case"typevar":return e;case"$var":return ER.expandMeta(e.expr);default:throw console.log(e),Error("Unknown metaexpr")}}static expandMetaAndFuncalls(e){switch(e._type){case"tee":var t=e.left.map(ER.expandMetaAndFuncalls),r=ER.expandMetaAndFuncalls(e.right);return new s.default({left:t,right:r});case"schema":return e.expr?"type"==e.type._type&&e.name?e:new n.default({shouldValidate:e.shouldValidate,axiomatic:e.axiomatic,name:null,params:e.params,expr:ER.expandMetaAndFuncalls(e.expr)}):e;case"schemacall":var i=ER.expandMetaAndFuncalls(e.schema),o=e.args.map(ER.expandMetaAndFuncalls);return!i.expr||i.name&&!i.shouldValidate?new a.default({schema:i,args:o}):ER.expandMetaAndFuncalls(ER.call(i,o));case"reduction":return ER.expandMetaAndFuncalls(e.reduced);case"typevar":return e;case"$var":return ER.expandMetaAndFuncalls(e.expr);default:throw console.log(e),Error("Unknown metaexpr")}}static equals(e,t){var r=function recurse(e,t,n){if(e==t)return!0;if(!e.type.equals(t.type))return!1;if("reduction"==e._type)return r(e.reduced,t,n+1);if("reduction"==t._type)return r(e,t.reduced,n+1);if("$var"==e._type)return r(e.expr,t,n+1);if("$var"==t._type)return r(e,t.expr,n+1);if(iscall(e)&&iscall(t)){if(iscall(callee(e)))return r(ER.expandCallOnce(e),t,n+1);if(iscall(callee(t)))return r(e,ER.expandCallOnce(t),n+1);if(callee(e)==callee(t)||!callee(e).expr&&!callee(t).expr){if(callee(e)!=callee(t))return!1;if(!callee(e).expr&&!callee(t).expr){for(var a=0;a<e.args.length;a++)if(!r(e.args[a],t.args[a],n+1))return!1;return!0}if(e.args.every((a,s)=>r(e.args[s],t.args[s],n+1)))return!0}return callee(e).expr?r(ER.expandCallOnce(e),t,n+1):r(e,ER.expandCallOnce(t),n+1)}if(iscall(e))return(iscall(callee(e))||!!callee(e).expr)&&r(ER.expandCallOnce(e),t,n+1);if(iscall(t))return(iscall(callee(t))||!!callee(t).expr)&&r(e,ER.expandCallOnce(t),n+1);if("tee"==e._type){t=t;for(a=0;a<e.left.length;a++)if(!r(e.left[a],t.left[a],n+1))return!1;return r(e.right,t.right,n+1)}if(e.type.isFunctional){var s=[],o=e.type.resolve().from.length;for(a=0;a<o;a++)s.push(new i.default({isParam:!0,type:e.type.resolve().from[a],name:"$"+a}));return r(makecall(e,s),makecall(t,s),n+1)}return!1};ER.nequalscall++;var n=r(e,t,0);return n&&ER.nequalstrue++,n}static chain(e){if(!e.every(e=>"tee"==e._type))throw Error("no");return ER.expandMetaAndFuncalls(e.reduceRight((e,t)=>{for(var r=0;r<e.left.length;r++)if(ER.equals(t.right,e.left[r])){var n=e.left.slice(0,r).concat(t.left).concat(e.left.slice(r+1));return new s.default({left:n,right:e.right})}throw Error(`Chaining failed:\n\n--- LEFT ---\n${t}\n------------\n\n--- RIGHT ---\n${e}\n-------------`)}))}}t.default=ER,ER.nequalscall=0,ER.nequalstrue=0,ER.nrecursecall=0,ER.nrecursetrue=0;const n=r(3),a=r(5),s=r(7),i=r(1)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(1),s=r(3);class Schemacall extends n.default{constructor({schema:e,args:t},r){if(super(r),this._type="schemacall",e.type.isSimple)throw this.error(e.name+" is not callable");if(!(t instanceof Array)||t.map(e=>e instanceof n.default).some(e=>!e))throw this.error("Assertion failed");var a=e.type.resolve(),s=a.from,i=t.map(e=>e.type);if(s.length!=i.length)throw this.error(`Invalid number of arguments (expected ${s.length}): ${i.length}`);for(var o=0;o<s.length;o++)if(!s[o].equals(i[o]))throw this.error(`Argument #${o+1} has illegal argument type (expected ${s[o]}): ${i[o]}`);this.schema=e,this.type=a.to,this.args=t}isProved(e){return e=e||[],super.isProved(e)||this.schema.isProved(e)}toIndentedString(e,t){var r=this.args.map(t=>t instanceof a.default?`${t.name}<${t._id}>`:t.toIndentedString(e+1));return r.join("").length<=50?(r=(r=this.args.map(t=>t instanceof a.default?`${t.name}<${t._id}>`:t.toIndentedString(e))).join(", "),this.schema.shouldValidate?[(this.schema.name||`(${this.schema})`)+"(",r,")"].join(""):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(e)+")")+"(",r,")"].join("")):(r=r.join(",\n"+"\t".repeat(e+1)),this.schema.shouldValidate?[(this.schema.name||`(${this.schema.toIndentedString(e)})`)+"(","\t"+r,")"].join("\n"+"\t".repeat(e)):[("schema"==this.schema._type&&this.schema.name?this.schema.name:"("+this.schema.toIndentedString(e)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(e)))}toTeXString(e,t){if(this.schema.shouldValidate)return(this.schema.name?`\\href{#schema-${this.schema.proved?"p":"np"}-${this.schema.name}}{\\textsf{${n.default.escapeTeX(this.schema.name)}}}`:this.schema.toTeXString(!1))+`(${this.args.map(e=>e.toTeXString(n.default.PREC_COMMA)).join(", ")})`;if(this.schema instanceof s.default)return this.schema.funcallToTeXString(this.args,e);var r=this.args.map(e=>e.toTeXString(n.default.PREC_COMMA));return(this.schema.name&&"typevar"!=this.schema._type?1==this.schema.name.length?n.default.escapeTeX(this.schema.name):`\\mathrm{${n.default.escapeTeX(this.schema.name)}}`:this.schema.toTeXString(!1))+`(${r.join(", ")})`}}t.default=Schemacall},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(2);class MetaType extends n.default{constructor(e){if(super(),this._type="metatype","boolean"!=typeof e.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=e.functional,this.isSimple=!e.functional,e.functional){if(e.from.some(e=>!(e instanceof a.default)))throw this.error("o.from.some(f => !(f instanceof Type))");if(!(e.to instanceof MetaType))throw this.error("!(o.to instanceof MetaType)");if(e.to.isFunctional)throw this.error("Functional metatype in functional metatype is not supported");this.from=e.from,this.to=e.to}else{if(!(e.left instanceof Array))throw this.error("left should be an array");this.left=e.left,this.right=e.right}}resolve(){return this}toIndentedString(e){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(e,t){throw new Error("Method not implemented.")}equals(e){if(!(e instanceof MetaType))return!1;if(this.isSimple!=e.isSimple)return!1;if(this.isSimple){if(this.left.length!=e.left.length)return!1;for(let t=0;t<this.left.length;t++)if(!this.left[t].equals(e.left[t]))return!1;return!!this.right.equals(e.right)}if(this.from.length!=e.from.length)return!1;for(let t=0;t<this.from.length;t++)if(!this.from[t].equals(e.from[t]))return!1;return this.to.equals(e.to)}}t.default=MetaType},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(6),s=r(4);class Tee extends n.default{constructor({left:e,def$s:t,right:r},i){if(super(i),this._type="tee",this.precedence=n.default.PREC_COMMA,!(e instanceof Array&&e.every(e=>["type","metatype"].includes(e.type._type))))throw console.log(e),this.error("Assertion failed");if(t&&!(t instanceof Array&&t.every(e=>"$var"==e._type)))throw this.error("Assertion failed");if(!["type","metatype"].includes(r.type._type))throw console.log(r),this.error("Assertion failed");if(r.type.isFunctional)throw this.error("RHS of a rule cannot be a schema");this.left=e.reduce((e,t)=>{for(var r=0;r<e.length;r++)if(s.default.equals(e[r],t))return e;return e.push(t),e},[]),this.def$s=t||[],this.right=r,this.type=new a.default({functional:!1,left:e.map(e=>e.type),right:r.type})}isProved(e){return e=e||[],super.isProved(e)||this.right.isProved(e.concat(this.left))}toIndentedString(e,t){return this.left.length?["\t"+this.left.map(t=>t.toIndentedString(e+1)).join(",\n"+"\t".repeat(e+1)),"|-","\t"+this.right.toIndentedString(e+1)].join("\n"+"\t".repeat(e)):"|- "+this.right.toIndentedString(e)}toTeXString(e,t){var r=s.default.expandMetaAndFuncalls(this);return[this.shouldConsolidate(e)?"\\left(":"",`{${r.left.map(e=>e.toTeXString(n.default.PREC_COMMA)).join(", ")} \\vdash ${r.right.toTeXString(n.default.PREC_COMMA)}}`,this.shouldConsolidate(e)?"\\right)":""].join("")}}t.default=Tee},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0);class $var extends n.default{constructor({name:e,expr:t},r){if(super(r),this._type="$var",!e||!t)throw this.error("Assertion failed");this.type=t.type,this.name=e,this.expr=t}isProved(e){return e=e||[],super.isProved(e)||this.expr.isProved(e)}toIndentedString(e,t){return this.name}toTeXString(e,t){return`\\mathtt{${n.default.escapeTeX(this.name)}}`}}t.default=$var},function(e,t,r){var n;n=r(10).default;var a=r(11).default;e.exports={grammar:n,Program:a}},function(e,t,r){"use strict";r.r(t),t.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\tdoc = doc && doc[0];\r\n\t\t\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\tdoc:(documentation __)?\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:("," _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\t{return a || []}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0],\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i],\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:expr0 _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _ expr:expr0 _ "}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => { metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_1 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\tright:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tdef$s: defdollars,\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_1 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ndefdollar =\r\n\tname:dollar_ident _\r\n\t\'=\' _\r\n\texpr:metaexpr _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'def$\',\r\n\t\t\tname,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\t}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\tat_var\r\n\t/ dollar_var\r\n\t/ plain_var\r\n\r\nat_var =\r\n\tname:at_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'@\',\r\n\t\t\tname: name.slice(1),\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndollar_var =\r\n\tname:dollar_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'$\',\r\n\t\t\tname: name,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nplain_var =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'normal\',\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"axiomatic"\r\n\t/ "base"\r\n\t/ "schema"\r\n\t/ "type";\r\n\r\nident =\r\n\t$(!keyword [a-zA-Z0-9_]+)\r\n\r\nat_ident =\r\n\t$(\'@\' [a-zA-Z0-9_]+)\r\n\r\ndollar_ident =\r\n\t$(\'$\' [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(12),a=r(15),s=r(4);t.default=class Program{constructor(){this.scope=new n.default(null)}feed(e){e.forEach(e=>{switch(e._type){case"typedef":var t=a.default.type(e,this.scope);if(this.scope.hasType(t.name))throw t.scope.error(`Type ${t.name} has already been declared`);this.scope.addType(t);break;case"defv":var r=a.default.typevar(e,this.scope);if(this.scope.hasTypevar(r.name))throw r.scope.error(`Definition ${r.name} has already been declared`);this.scope.addTypevar(r);break;case"defun":var n=a.default.fun(e,this.scope);if(this.scope.hasTypevar(n.name))throw n.scope.error(`Definition ${n.name} has already been declared`);this.scope.addFun(n);break;case"defschema":var s=a.default.schema(e,this.scope);if(this.scope.hasSchema(s.name))throw s.scope.error(`Schema ${s.name} has already been declared`);this.scope.addSchema(s);break;default:throw Error("Unknown line type "+e._type)}})}evaluate(e){switch(e._type){case"typedef":case"defv":case"defun":case"defschema":case"tee":case"reduction":case"schemacall":case"var":case"schemaexpr":return a.default[{typedef:"type",defv:"typevar",defun:"fun",defschema:"schema",tee:"tee",reduction:"reduction",schemacall:"schemacall",var:"metavar",schemaexpr:"schemaexpr"}[e._type]](e,this.scope);default:throw Error("Unknown line type "+e._type)}}getProofExplorer(e,t){var r="&#x25C7;";if(!this.scope.schemaMap.has(e))throw Error("wut");var n=this.scope.schemaMap.get(e),a=function recurse(e){switch(e._type){case"reduction":return Math.max(...e.leftargs.map(recurse),"schema"==e.subject._type&&e.subject.name||"schemacall"==e.subject._type&&e.subject.schema.name?0:recurse(e.subject),1);case"schema":return recurse(e.expr)+1;case"tee":return Math.max(...e.left.map(recurse),...e.def$s.map(e=>recurse(e.expr)),recurse(e.right))+1;case"schemacall":default:return 1}}(n);function getHtmlLine(e,r,n,s,i){for(var o=r.length,l=r.map(e=>`<td class="brb">${e.map(e=>t(e.toTeXString(!0))).join(", ")}</td>`).join(""),c=0;c<r.length;c++)for(;r[c].length;)r[c].pop();return`<tr><th>${e}</th>${l}<td ${i?'class="bbb"':""} colspan="${a-o}">${n}</td>${s instanceof Array?s.map(e=>`<td>${e}</td>`).join(""):`<td colspan="2">${s}</td>`}</tr>`}function exprToHtml(e,r){return"number"==typeof e?`<b>${e}</b>`:e instanceof Array?`<b>${e[0]}&ndash;${e[1]}</b>`:t(r?s.default.expandMetaAndFuncalls(e).toTeXString(!0):e.toTeXString(!0))}var i=0,o=function getTree(e,t,r){if(t.has(e))return[{_type:"R",ctr:++i,num:t.get(e),expr:e}];if(r.has(e))return[{_type:"R",ctr:++i,num:r.get(e),expr:e}];switch(e._type){case"reduction":var a=[],s=e.leftargs.map(e=>{if(t.has(e))return t.get(e);if(r.has(e))return r.get(e);var n=getTree(e,t,r);return a=a.concat(n),n[n.length-1].ctr}),o=[],l=t.get(e.subject)||r.get(e.subject)||("schema"==(f=e.subject)._type&&f.name||"schemacall"==f._type&&f.schema.name?e.subject:(o=getTree(e.subject,t,r))[o.length-1].ctr);return[...a,...o,{_type:"E",ctr:++i,subject:l,leftargs:s,reduced:e.reduced}];case"schemacall":if(t.has(e.schema))return[{_type:"RC",ctr:++i,schema:t.get(e.schema),args:e.args,expr:e}];if(r.has(e.schema))return[{_type:"RC",ctr:++i,schema:r.get(e.schema),args:e.args,expr:e}];if(e.schema.shouldValidate&&e.schema.name)return[{_type:"RCX",ctr:++i,expr:e}];if(!e.schema.shouldValidate)return[{_type:"NP",ctr:++i,expr:e}];var c=getTree(e.schema,t,r);return[...c,{_type:"RC",ctr:++i,schema:c[c.length-1].ctr,args:e.args,expr:e}];case"typevar":return[{_type:"NP",ctr:++i,expr:e}];case"schema":if(e.shouldValidate&&e.name&&e!=n)return[{_type:"RS",ctr:++i,expr:e}];if(!e.expr)return[{_type:"NP",ctr:++i,expr:e}];r=new Map(r);var h=[];return e.def$s.forEach(e=>{var n=getTree(e.expr,t,r);h=h.concat(n);var a=n[n.length-1].ctr;r.set(e,a)}),[{_type:"V",$lines:h,lines:getTree(e.expr,t,r),params:e.params.slice(),ctr:i}];case"tee":t=new Map(t);var u=[],p=i+1;e.left.forEach(e=>{t.set(e,++i),u.push({_type:"H",ctr:i,expr:e})}),r=new Map(r);h=[];return e.def$s.forEach(e=>{var n=getTree(e.expr,t,r);h=h.concat(n);var a=n[n.length-1].ctr;r.set(e,a)}),[{_type:"T",leftlines:u,$lines:h,rightlines:getTree(e.right,t,r),ctr:[p,i]}];case"$var":if(!r.has(e))throw Error(e.name+" is not defined");return[{_type:"R",ctr:++i,num:r.get(e),expr:e.expr}];default:return console.error(e.error("Unknown type "+e._type)),[{_type:"?",ctr:++i,expr:e}]}var f}(n,new Map,new Map),l='<table class="explorer">';return l+=`<tr><th>#</th><th colspan="${a}">expr</th><th colspan="2">rule</th></tr>`,l+=function tree2html(e,t){return e.map(e=>{switch(e._type){case"V":return tree2html(e.$lines,t.concat([e.params]))+tree2html(e.lines,t.concat([e.params]));case"T":var n=t.concat([[]]),a="";if(0==e.leftlines.length)a+=getHtmlLine("",Array(t.length+1).fill([]),"","",!0);else a+=e.leftlines.map((e,t,r)=>getHtmlLine(e.ctr,n,exprToHtml(e.expr,!0),"assumption",t==r.length-1)).join("");return a+=tree2html(e.$lines,n),a+=tree2html(e.rightlines,n);case"?":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[r,exprToHtml(e.num)]);case"RS":case"RCX":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[r,exprToHtml(e.expr)]);case"RC":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[r,`${exprToHtml(e.schema)} (${e.args.map(e=>exprToHtml(e)).join(", ")})`]);case"E":return getHtmlLine(e.ctr,t,exprToHtml(e.reduced,!0),["&#x25BC;",`${exprToHtml(e.subject)} [${e.leftargs.map(e=>exprToHtml(e)).join(", ")}]`]);case"NP":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(e.ctr,t,"Unknown type "+e._type,"")}}).join("")}(o[0].$lines.concat(o[0].lines),[]),l+="</table>"}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2),a=r(1),s=r(3),i=r(13),o=r(8);class Scope{constructor(e,t){if(this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.parent=e,this.root=e?e.root:this,t&&!(t instanceof i.default))throw Error("Assertion failed");this.trace=t||new i.default,this.baseType=e?e.baseType:null}extend(e,t,r){var n=new Scope(this,this.trace.extend(e,t,r));return this.hypotheses.forEach(e=>n.hypotheses.push(e)),n}error(e){return this.trace.error(e)}hasOwnType(e){if("string"==typeof e)return this.typedefMap.has(e);if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");return e.map(e=>this.hasOwnType(e)).every(e=>e)}hasType(e){if("string"==typeof e)return this.hasOwnType(e)||!!this.parent&&this.parent.hasType(e);if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");return e.map(e=>this.hasType(e)).every(e=>e)}addType(e){if(!(e instanceof n.default))throw this.error("Illegal argument type");if(!e.name)throw this.error("Something's wrong");if(this.hasOwnType(e.name))throw this.error(`Type ${e.name} has already been declared`);if(e.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(t){t.baseType=e,t.parent&&broadcast(t.parent)}(this)}return this.typedefMap.set(e.name,e),e}getType(e){if("string"==typeof e){if(!this.hasType(e))throw this.error(`Type ${e} is not defined`);return this.typedefMap.has(e)?this.typedefMap.get(e):!!this.parent&&this.parent.getType(e)}if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");var t=e.slice(0,e.length-1).map(e=>this.getType(e)),r=this.getType(e[e.length-1]);return new n.default({functional:!0,from:t,to:r})}hasOwnTypevar(e){return this.defMap.has(e)}hasTypevar(e){return this.hasOwnTypevar(e)||!!this.parent&&this.parent.hasTypevar(e)}addTypevar(e){if(!(e instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnTypevar(e.name))throw this.error(`Definition ${e.name} has already been declared`);return this.defMap.set(e.name,e),e}addFun(e){if(!(e instanceof s.default))throw this.error("Illegal argument type");if(!e.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnTypevar(e.name))throw this.error(`Definition ${e.name} has already been declared`);return this.defMap.set(e.name,e),e}getTypevar(e){if(!this.hasTypevar(e))throw this.error(`Definition ${e} is not defined`);return this.defMap.has(e)?this.defMap.get(e):!!this.parent&&this.parent.getTypevar(e)}hasOwnSchema(e){return this.schemaMap.has(e)||this.defMap.has(e)}hasSchema(e){return this.hasOwnSchema(e)||!!this.parent&&this.parent.hasSchema(e)}addSchema(e){if(!(e instanceof s.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(e.name))throw this.error(`Schema ${e.name} has already been declared`);return this.schemaMap.set(e.name,e),e}getSchema(e){if(!this.hasSchema(e))throw this.error(`Schema ${e} is not defined`);return this.schemaMap.has(e)?this.schemaMap.get(e):this.defMap.has(e)?this.defMap.get(e):!!this.parent&&this.parent.getSchema(e)}hasOwn$(e){return this.$Map.has(e)}has$(e){return this.hasOwn$(e)||!!this.parent&&this.parent.has$(e)}add$(e){if(!(e instanceof o.default))throw this.error("Illegal argument type");if(this.hasOwn$(e.name))throw this.error(`$var ${e.name} has already been declared`);return this.$Map.set(e.name,e),e}get$(e){if(!this.has$(e))throw this.error(`$var ${e} is not defined`);return this.$Map.has(e)?this.$Map.get(e):!!this.parent&&this.parent.get$(e)}}t.default=Scope},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});class StackTrace{constructor(e){this.stack=e||[]}extend(e,t,r){return new StackTrace([[e,t,r]].concat(this.stack))}error(t){var r=void 0!==e&&e.argv[2];return new Error(t+"\n\tat "+(this.stack.length?this.stack.map(([e,t,n])=>`${e} ${t||"<anonymous>"} (${r||"code.math"}:${n.start.line}:${n.start.column})`).join("\n\tat "):`<root> (${r||"code.math"}:1:1)`))}}t.default=StackTrace}).call(this,r(14))},function(e,t){var r,n,a=e.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(r===setTimeout)return setTimeout(e,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){n=defaultClearTimeout}}();var s,i=[],o=!1,l=-1;function cleanUpNextTick(){o&&s&&(o=!1,s.length?i=s.concat(i):l=-1,i.length&&drainQueue())}function drainQueue(){if(!o){var e=runTimeout(cleanUpNextTick);o=!0;for(var t=i.length;t;){for(s=i,i=[];++l<t;)s&&s[l].run();l=-1,t=i.length}s=null,o=!1,function runClearTimeout(e){if(n===clearTimeout)return clearTimeout(e);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}a.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];i.push(new Item(e,t)),1!==i.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(e){return[]},a.binding=function(e){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(e){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2),a=r(1),s=r(7),i=r(3),o=r(5),l=r(16),c=r(8);function typeObjToString(e){if("type"!=e._type)throw Error("Assertion failed");return e.ftype?"["+e.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(e.to)+"]":e.name}function typeObjToNestedArr(e){if("type"!=e._type)throw Error("Assertion failed");if(e.ftype){if(!e.from||!e.to)throw Error("Assertion failed");return e.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(e.to)])}if(!(e=e).name)throw Error("Assertion failed");return e.name}class PI{static type(e,t){if("typedef"!=e._type)throw Error("Assertion failed");var r=t.extend("type",e.name,e.location),a=e.origin?r.getType(typeObjToNestedArr(e.origin)):null,s=e.name,i=e.doc,o=e.base;if(o&&a)throw r.error("Base type should not be an alias");return a?new n.default({name:s,doc:i,base:o,origin:a}):new n.default({functional:!1,name:s,doc:i,base:o})}static typevar(e,t){if(!["defv","var"].includes(e._type))throw Error("Assertion failed");var r=t.extend("typevar",e.name,e.location);if("var"==e._type){if("normal"!=e.type)throw r.error(`Variable type ${e.type} not allowed`);if(!r.hasTypevar(e.name))throw r.error("Undefined identifier "+e.name);return r.getTypevar(e.name)}if(!r.hasType(typeObjToNestedArr(e.type)))throw r.error(`Type ${typeObjToString(e.type)} is not defined`);var n=r.getType(typeObjToNestedArr(e.type));return new a.default({type:n,isParam:!!e.isParam,guess:e.guess||null,name:e.name,doc:e.doc,tex:e.tex},r)}static fun(e,t){if("defun"!=e._type&&"funexpr"!=e._type)throw Error("Assertion failed");var r=null,a=null,s=null;"defun"==e._type&&(r=(e=e).name,a=e.doc,s=e.tex);var o=t.extend("fun",r,e.location),l=null,c=e.params.map(e=>{if(!o.hasType(typeObjToNestedArr(e.type)))throw o.error(`Type ${typeObjToString(e.type)} is not defined`);var t=PI.typevar(e,o);if(o.hasOwnTypevar(t.name))throw t.scope.error(`Parameter ${t.name} has already been declared`);return o.addTypevar(t)}),h=null;switch(e._type){case"defun":if(!o.hasType(typeObjToNestedArr(e.rettype)))throw o.error(`Type ${typeObjToString(e.rettype)} is not defined`);var u=o.getType(typeObjToNestedArr(e.rettype));if(e.expr){if(h=PI.expr0(e.expr,o),!u.equals(h.type))throw o.error(`Expression type ${h.type} failed to match the return type ${u} of fun ${r}`)}else l=new n.default({functional:!0,from:c.map(e=>e.type),to:u});break;case"funexpr":h=PI.expr0(e.expr,o),l=null;break;default:throw Error("wut")}return new i.default({shouldValidate:!1,name:r,type:l,params:c,expr:h,doc:a,tex:s},o)}static funcall(e,t){if("funcall"!=e._type)throw Error("Assertion failed");var r=t.extend("funcall","name"in e.schema?e.schema.name:null,e.location),n=PI.expr0(e.schema,r),a=e.args.map(e=>PI.expr0(e,r));return new o.default({schema:n,args:a},r)}static metaexpr(e,t){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(e._type))throw Error("Assertion failed");var r=t;switch(e._type){case"tee":return PI.tee(e,r);case"reduction":return PI.reduction(e,r);case"schemacall":return PI.schemacall(e,r);case"schemaexpr":return PI.schema(e,r);case"var":return PI.metavar(e,r);default:throw Error("wut")}}static expr0(e,t){if(!["funcall","funexpr","var"].includes(e._type))throw console.log(e),Error("Assertion failed");var r=t;switch(e._type){case"funcall":return PI.funcall(e,r);case"funexpr":return PI.fun(e,r);case"var":return PI.typevar(e,r);default:throw Error("wut")}}static metavar(e,t){if("var"!=e._type)throw Error("Assertion failed");var r=t;switch(e.type){case"@":if(e.name.match(/^h[0-9]+$/)){var n=Number(e.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query @"+e.name);case"$":if(!r.has$(e.name))throw r.error(e.name+" is not defined");return r.get$(e.name);case"normal":if(!r.hasSchema(e.name))throw r.error(`Schema ${e.name} is not defined`);return r.getSchema(e.name);default:throw r.error("Unknown type "+e.type)}}static tee(e,t){if("tee"!=e._type)throw Error("Assertion failed");var r=t.extend("tee",null,e.location),n=e.left.map(e=>PI.metaexpr(e,r)),a=r.extend("tee.right",null,e.right.location);n.forEach(e=>a.hypotheses.push(e));var i=e.def$s.map(e=>{var t=PI.def$(e,a);if(a.hasOwn$(t.name))throw a.error(e.name+" has already been declared");return a.add$(t)}),o=PI.metaexpr(e.right,a);return new s.default({left:n,def$s:i,right:o},r)}static def$(e,t){if("def$"!=e._type)throw Error("Assertion failed");var r=t.extend("def$",e.name,e.location),n=PI.metaexpr(e.expr,r);return new c.default({name:e.name,expr:n},r)}static schema(e,t){if("defschema"!=e._type&&"schemaexpr"!=e._type)throw Error("Assertion failed");var r=null,n=!1,a=null;"defschema"==e._type&&(r=e.name,n=e.axiomatic,a=e.doc);var s=t.extend("schema",r,e.location),o=e.params.map(e=>{if(!s.hasType(typeObjToNestedArr(e.type)))throw s.error(`Type ${typeObjToString(e.type)} is not defined`);var t=PI.typevar(e,s);if(s.hasOwnTypevar(t.name))throw t.scope.error(`Parameter ${t.name} has already been declared`);return s.addTypevar(t)}),l=e.def$s.map(e=>{var t=PI.def$(e,s);if(s.hasOwn$(t.name))throw s.error(e.name+" has already been declared");return s.add$(t)}),c=PI.metaexpr(e.expr,s);return new i.default({shouldValidate:!0,axiomatic:n,name:r,params:o,def$s:l,expr:c,doc:a},s)}static schemacall(e,t){if("schemacall"!=e._type)throw Error("Assertion failed");var r=t.extend("schemacall","name"in e.schema?e.schema.name:null,e.location),n=PI.metaexpr(e.schema,r),a=e.args.map(e=>PI.expr0(e,r));return new o.default({schema:n,args:a},r)}static reduction(e,t){if("reduction"!=e._type)throw Error("Assertion failed");var r=t.extend("reduction","name"in e.subject?e.subject.name:null,e.location),n=PI.metaexpr(e.subject,r),a=e.guesses?e.guesses.map(e=>e&&PI.expr0(e,r)):null,s=e.leftargs.map(e=>PI.metaexpr(e,r));return new l.default({subject:n,guesses:a,leftargs:s},r)}}t.default=PI},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(5),s=r(4);class Reduction extends n.default{constructor({subject:e,guesses:t,leftargs:r},i){if(super(i),this._type="reduction","schema"==e._type){e.params.forEach((e,r)=>{if(!(t&&t[r]||e.guess))throw this.error(`Argument #${r+1} could not be guessed`)});var o=e.params.map((n,a)=>t&&t[a]?t[a]:this.query(n.guess,s.default.expandMeta(e.expr).left,r));e=new a.default({schema:e,args:o},i)}else if(t)throw this.error("Something's wrong");if("metatype"!=e.type._type||!e.type.isSimple)throw this.error("Subject is not reducible");if(!(r instanceof Array)||r.map(e=>e instanceof n.default).some(e=>!e))throw this.error("Assertion failed");this.subject=e,this.leftargs=r;var l=e.type.left,c=r.map(e=>e.type);if(l.length!=c.length)throw this.error(`Invalid number of arguments (expected ${l.length}): ${c.length}`);for(let e=0;e<l.length;e++)if(!l[e].equals(c[e]))throw this.error(`Illegal argument type (expected ${l[e]}): ${c[e]}`);this.type=e.type.right;var h=s.default.expandMetaAndFuncalls(e);if("tee"!=h._type)throw this.error("Assertion failed");for(let e=0;e<h.left.length;e++)if(!s.default.equals(h.left[e],r[e]))throw this.error(`LHS #${e+1} failed to match:\n\n--- EXPECTED ---\n${s.default.expandMetaAndFuncalls(h.left[e])}\n----------------\n\n--- RECEIVED ---\n${s.default.expandMetaAndFuncalls(r[e])}\n----------------`);this.reduced=h.right}isProved(e){return e=e||[],super.isProved(e)||this.subject.isProved(e)&&this.leftargs.every(t=>t.isProved(e))}query(e,t,r){if(0==e.length)throw this.error("wut");if(!(1<=1*e[0]&&1*e[0]<=r.length))throw this.error(`Cannot dereference @${e}: antecedent index out of range`);var n=t[1*e[0]-1],a=r[1*e[0]-1],i=this;return function recurse(e,t,r,n){if(r=s.default.expandMetaAndFuncalls(r),e.length<=n)return r;if(/[0-9]/.test(e[n])){var a=1*e[n];if("tee"==t._type&&"tee"==r._type){if(t.left.length!=r.left.length)throw i.error(`Cannot dereference @${e}: antecedent length mismatch`);if(!(1<=a&&a<=r.left.length))throw i.error(`Cannot dereference @${e}: antecedent index out of range`);return recurse(e,t.left[a-1],r.left[a-1],n+1)}for(;;){if(!t.schema||!r.schema)throw i.error("Cannot dereference @"+e);if(s.default.equals(t.schema,r.schema))break;if(!r.schema.expr)throw i.error("Cannot dereference @"+e);r=s.default.expandCallOnce(r)}if(!r.args||!(1<=a&&a<=r.args.length))throw i.error("Cannot dereference @"+e);return recurse(e,t.args[a-1],r.args[a-1],n+1)}if("r"==e[n]){if("tee"==t._type&&"tee"==r._type)return recurse(e,t.right,r.right,n+1);throw i.error("Cannot dereference @"+e)}throw i.error("Cannot dereference @"+e)}(e,n,a,1)}toIndentedString(e,t){var r=this.leftargs.map(t=>t.toIndentedString(e+1));return r.join("").length<=50?(r=(r=this.leftargs.map(t=>t.toIndentedString(e))).join(", "),[this.subject.toIndentedString(e)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(e+1)),[this.subject.toIndentedString(e)+"[","\t"+r,"]"].join("\n"+"\t".repeat(e)))}toTeXString(e,t){return`${this.subject.toTeXString(!1)}[${this.leftargs.map(e=>e.toTeXString(n.default.PREC_COMMA)).join(", ")}]`}}t.default=Reduction}])}));
//# sourceMappingURL=math.min.js.map