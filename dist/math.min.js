!function webpackUniversalModuleDefinition(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.math=t():e.math=t()}("undefined"!=typeof self?self:this,(function(){return function(e){var t={};function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},__webpack_require__.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.t=function(e,t){if(1&t&&(e=__webpack_require__(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)__webpack_require__.d(r,n,function(t){return e[t]}.bind(null,n));return r},__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=16)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=0;class Node{constructor(e,t,r){this._id=++n,this.doc=t,this.tex=r}toString(){return this.toIndentedString(0)}static error(e,t){return t?t.error(e):new Error(e)}static escapeTeX(e){return e.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(e=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[e])))}static parseTeX(e){var t=!1,r=e.replace(/^!<prec=([0-9]+)>/,((e,r)=>(t=1*r,"")));return{precedence:t,code:r}}isProved(e){e=e||[];for(var t=0;t<e.length;t++)if(e[t]==this)return!0;return!1}static normalizePrecedence(e){if(!1===e)return[0,0];if(!0===e)return[2,0];if("number"==typeof e)return[0,e];if(!(e instanceof Array&&2==e.length))throw console.log(e),Error("wut");return e}shouldConsolidate(e){var t=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(e||!1);return(0!=t[0]||0!=t[1])&&!(t[0]<r[0]||t[0]==r[0]&&t[1]<r[1])}makeTeX(e,t,r){t=t||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,((e,r)=>t[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`)).replace(/<<(.+?)>>/,((t,r)=>`\\href{#${e}}{${r}}`))}}t.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(11),a=r(0),i=r(2),s=r(12),o=r(3);class Fun extends n.default{constructor({doc:e,tex:t,annotations:r,type:n,name:l,params:u,expr:f},c){if(!l&&!f)throw a.default.error("Anonymous fun cannot be primitive",c);if(n&&f)throw a.default.error("no",c);if(!n&&!f)throw a.default.error("Cannot guess the type of a primitive fun",c);if(null!==l&&"string"!=typeof l)throw a.default.error("Assertion failed",c);if(!(u instanceof Array)||u.map((e=>e instanceof o.default)).some((e=>!e)))throw a.default.error("Assertion failed",c);if(null!==f&&!(f instanceof a.default))throw a.default.error("Assertion failed",c);var d=!1;if(t){var p=a.default.parseTeX(t);d=p.precedence,t=p.code}else t=null;super(c,e,t,n||new(f.type instanceof i.default?i.default:s.default)({functional:!0,from:u.map((e=>e.type)),to:f.type})),this.annotations=r,this.precedence=d,this.name=l,this.params=u,this.expr=f}isProved(e){return e=e||[],super.isProved(e)||this.expr&&this.expr.isProved(e)}}t.default=Fun},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(14);class ObjectType extends a.default{constructor(e){if(e.origin){if(super(null,e.doc,null,e.origin.isFunctional),this.isBaseType=!!e.base,"string"!=typeof e.name)throw n.default.error("typeof o.name != 'string'",null);if(this.name=e.name,!(e.origin instanceof ObjectType))throw n.default.error("!(o.origin instanceof ObjectType)",null);this.origin=e.origin}else{if(super(null,e.doc,null,e.functional),this.isBaseType=!!e.base,"boolean"!=typeof e.functional)throw n.default.error("typeof o.functional != 'boolean'",null);if(e.functional){if(e.from.map((e=>e instanceof ObjectType)).some((e=>!e)))throw n.default.error("o.from.map(f => f instanceof ObjectType).some(e => !e)",null);if(!(e.to instanceof ObjectType))throw n.default.error("!(o.to instanceof ObjectType)",null);this.from=e.from,this.to=e.to}else{if("string"!=typeof e.name)throw n.default.error("typeof o.name != 'string'",null);this.name=e.name}}}toSimpleString(){if(this.name)return this.name;var e=this.resolve();return`[${e.from.map((e=>e.toSimpleString())).join(", ")} -> ${e.to.toSimpleString()}]`}toIndentedString(e){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(e){return this.isSimple||!e&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map((e=>e.toTeXString())).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(e){if(!(e instanceof ObjectType))return!1;if(this.origin)return this.origin.equals(e);if(e.origin)return this.equals(e.origin);if(this.isSimple!=e.isSimple)return!1;if(this.isSimple)return this===e;if(this.from.length!=e.from.length)return!1;for(var t=0;t<this.from.length;t++)if(!this.from[t].equals(e.from[t]))return!1;return this.to.equals(e.to)}}t.default=ObjectType},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(11),a=r(0);class Variable extends n.default{constructor({doc:e,tex:t,type:r,name:n,isParam:i,guess:s},o){if(super(o,e,t,r),this.isParam=!!i,this.guess=s||null,"string"!=typeof n)throw a.default.error("Assertion failed",o);this.name=n}isProved(e){return e=e||[],super.isProved(e)}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(e,t){return`${t?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(e,t){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?a.default.escapeTeX(this.name):`\\mathrm{${a.default.escapeTeX(this.name)}}`)}}`}toTeXStringWithId(e,t){if(!this.isParam)throw Error("wut");return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(e,t),"}"].join("")}}t.default=Variable},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),a=r(0);class $Variable extends n.default{constructor({name:e,expr:t},r){if(super(r,null,null,t.type),!e||!t)throw a.default.error("Assertion failed",r);this.name=e,this.expr=t}isProved(e){return e=e||[],super.isProved(e)||this.expr.isProved(e)}toIndentedString(e,t){return this.name}toTeXString(e,t){return`\\mathtt{${a.default.escapeTeX(this.name)}}`}}t.default=$Variable},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),a=r(13),i=r(10),s=r(9),o=r(1),l=r(8),u=r(7),f=r(3),c=r(2);function iscall(e){return e instanceof l.default}function makecall(e,t){if(e instanceof f.default||e instanceof o.default)return new l.default({fun:e,args:t});throw console.log(e),Error()}class ExpressionResolver{static substitute(e,t){if(e instanceof l.default)return new l.default({fun:ExpressionResolver.substitute(e.fun,t),args:e.args.map((e=>ExpressionResolver.substitute(e,t)))});if(e instanceof i.default){if(!e.expr)return e;if(e.name)return e;if(e.params.some((e=>t.has(e))))throw Error("Parameter collision");return new i.default({annotations:e.annotations,name:null,params:e.params,expr:ExpressionResolver.substitute(e.expr,t)})}if(e instanceof s.default){if(!e.expr)return e;if(e.name)return e;if(e.params.some((e=>t.has(e))))throw Error("Parameter collision");return new s.default({annotations:e.annotations,axiomatic:e.axiomatic,name:null,params:e.params,def$s:e.def$s,expr:ExpressionResolver.substitute(e.expr,t)})}if(e instanceof f.default)return t.get(e)||e;if(e instanceof u.default){var r=e.left.map((e=>ExpressionResolver.substitute(e,t))),o=ExpressionResolver.substitute(e.right,t);return new u.default({left:r,right:o})}if(e instanceof a.default)return ExpressionResolver.substitute(e.reduced,t);if(e instanceof n.default)return ExpressionResolver.substitute(e.expr,t);throw console.log(e),Error("Unknown metaexpr")}static call(e,t){if(!(e instanceof o.default))throw console.log(e),Error("Illegal type");if(!e.expr)throw Error("Cannot call a callable without a body");if(e.params.length!=t.length)throw Error("Illegal arguments length");for(var r=new Map,n=0;n<e.params.length;n++)r.set(e.params[n],t[n]);return ExpressionResolver.substitute(e.expr,r)}static expandCallOnce(e){if(!iscall(e))throw Error("Illegal type");if(iscall(e.fun))return makecall(ExpressionResolver.expandCallOnce(e.fun),e.args);for(var t=e.fun;t instanceof n.default;)t=t.expr;if(!(t instanceof o.default))throw Error("Something's wrong");if(!t.expr)throw Error("Could not expand");return ExpressionResolver.call(t,e.args)}static expandMeta(e){if(e instanceof u.default){var t=e.left.map(ExpressionResolver.expandMeta),r=ExpressionResolver.expandMeta(e.right);return new u.default({left:t,right:r})}if(e instanceof l.default){var d=ExpressionResolver.expandMeta(e.fun),p=e.args;return d instanceof o.default&&d.expr&&(!d.name||d instanceof s.default)?ExpressionResolver.expandMeta(ExpressionResolver.call(d,p)):new l.default({fun:d,args:p})}if(e instanceof a.default)return ExpressionResolver.expandMeta(e.reduced);if(e instanceof i.default)return e.expr?e.type instanceof c.default&&e.name?e:new i.default({annotations:e.annotations,name:null,params:e.params,expr:ExpressionResolver.expandMeta(e.expr)}):e;if(e instanceof s.default)return e.expr?e.type instanceof c.default&&e.name?e:new s.default({annotations:e.annotations,axiomatic:e.axiomatic,name:null,params:e.params,def$s:e.def$s,expr:ExpressionResolver.expandMeta(e.expr)}):e;if(e instanceof f.default)return e;if(e instanceof n.default)return ExpressionResolver.expandMeta(e.expr);throw console.log(e),Error("Unknown metaexpr")}static expandMetaAndFuncalls(e){if(e instanceof u.default){var t=e.left.map(ExpressionResolver.expandMetaAndFuncalls),r=ExpressionResolver.expandMetaAndFuncalls(e.right);return new u.default({left:t,right:r})}if(e instanceof i.default)return e.expr?e.type instanceof c.default&&e.name?e:new i.default({annotations:e.annotations,name:null,params:e.params,expr:ExpressionResolver.expandMetaAndFuncalls(e.expr)}):e;if(e instanceof s.default)return e.expr?e.type instanceof c.default&&e.name?e:new s.default({annotations:e.annotations,axiomatic:e.axiomatic,name:null,params:e.params,def$s:e.def$s,expr:ExpressionResolver.expandMetaAndFuncalls(e.expr)}):e;if(e instanceof l.default){var o=ExpressionResolver.expandMetaAndFuncalls(e.fun),d=e.args.map(ExpressionResolver.expandMetaAndFuncalls);return o.expr&&(!o.name||o instanceof s.default)?ExpressionResolver.expandMetaAndFuncalls(ExpressionResolver.call(o,d)):new l.default({fun:o,args:d})}if(e instanceof a.default)return ExpressionResolver.expandMetaAndFuncalls(e.reduced);if(e instanceof f.default)return e;if(e instanceof n.default)return ExpressionResolver.expandMetaAndFuncalls(e.expr);throw console.log(e),Error("Unknown metaexpr")}static equals(e,t){var r=function recurse(e,t,i){if(e==t)return!0;if(!e.type.equals(t.type))return!1;if(e instanceof a.default)return r(e.reduced,t,i+1);if(t instanceof a.default)return r(e,t.reduced,i+1);if(e instanceof n.default)return r(e.expr,t,i+1);if(t instanceof n.default)return r(e,t.expr,i+1);if(iscall(e)&&iscall(t)){if(iscall(e.fun))return r(ExpressionResolver.expandCallOnce(e),t,i+1);if(iscall(t.fun))return r(e,ExpressionResolver.expandCallOnce(t),i+1);var s=e.fun instanceof o.default&&e.fun.expr,l=t.fun instanceof o.default&&t.fun.expr;if(e.fun==t.fun||!s&&!l){if(e.fun!=t.fun)return!1;if(!s&&!l){for(var c=0;c<e.args.length;c++)if(!r(e.args[c],t.args[c],i+1))return!1;return!0}if(e.args.every(((n,a)=>r(e.args[a],t.args[a],i+1))))return!0}return s?r(ExpressionResolver.expandCallOnce(e),t,i+1):r(e,ExpressionResolver.expandCallOnce(t),i+1)}if(iscall(e))return(iscall(e.fun)||!!(e.fun instanceof o.default&&e.fun.expr))&&r(ExpressionResolver.expandCallOnce(e),t,i+1);if(iscall(t))return(iscall(t.fun)||!!(t.fun instanceof o.default&&t.fun.expr))&&r(e,ExpressionResolver.expandCallOnce(t),i+1);if(e instanceof u.default){if(!(t instanceof u.default))throw Error("Assertion failed");for(c=0;c<e.left.length;c++)if(!r(e.left[c],t.left[c],i+1))return!1;return r(e.right,t.right,i+1)}if(e.type.isFunctional){var d=[],p=e.type.resolve().from.length;for(c=0;c<p;c++)d.push(new f.default({isParam:!0,type:e.type.resolve().from[c],name:"$"+c}));return r(makecall(e,d),makecall(t,d),i+1)}return!1};ExpressionResolver.nequalscall++;var i=r(e,t,0);return i&&ExpressionResolver.nequalstrue++,i}}t.default=ExpressionResolver,ExpressionResolver.nequalscall=0,ExpressionResolver.nequalstrue=0,ExpressionResolver.nrecursecall=0,ExpressionResolver.nrecursetrue=0},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0);class Metaexpr extends n.default{constructor(e,t,r,a){if(super(e,t,r),!a)throw n.default.error("Assertion failed",e);this.type=a}equals(e){return this===e}}t.default=Metaexpr},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(12),i=r(5),s=r(4),o=r(2),l=r(6);class Tee extends l.default{constructor({left:e,def$s:t,right:r},i){if(!(e instanceof Array&&e.every((e=>e.type instanceof o.default||e.type instanceof a.default))))throw console.log(e),n.default.error("Assertion failed",i);if(t&&!(t instanceof Array&&t.every((e=>e instanceof s.default))))throw n.default.error("Assertion failed",i);if(!(r.type instanceof o.default||r.type instanceof a.default))throw console.log(r),n.default.error("Assertion failed",i);if(r.type.isFunctional)throw n.default.error("RHS of a rule cannot be a schema",i);super(i,null,null,new a.default({functional:!1,left:e.map((e=>e.type)),right:r.type})),this.left=e,this.def$s=t||[],this.right=r,this.precedence=n.default.PREC_COMMA}isProved(e){return e=e||[],super.isProved(e)||this.right.isProved(e.concat(this.left))}toIndentedString(e,t){return this.left.length?["\t"+this.left.map((t=>t.toIndentedString(e+1))).join(",\n"+"\t".repeat(e+1)),"|-","\t"+this.right.toIndentedString(e+1)].join("\n"+"\t".repeat(e)):"|- "+this.right.toIndentedString(e)}toTeXString(e,t){var r=i.default.expandMetaAndFuncalls(this);return[this.shouldConsolidate(e)?"\\left(":"",`{${r.left.map((e=>e.toTeXString(n.default.PREC_COMMA))).join(", ")} \\vdash ${r.right.toTeXString(n.default.PREC_COMMA)}}`,this.shouldConsolidate(e)?"\\right)":""].join("")}}t.default=Tee},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(3),i=r(1),s=r(11),o=r(15),l=r(9),u=r(10);class Funcall extends s.default{constructor({fun:e,args:t},r){if(e.type.isSimple){var a=o.isNameable(e)?e.name:"<anonymous>";throw n.default.error(a+" is not callable",r)}if(!(t instanceof Array)||t.map((e=>e instanceof n.default)).some((e=>!e)))throw n.default.error("Assertion failed",r);var i=e.type.resolve(),s=i.from,l=t.map((e=>e.type));if(s.length!=l.length)throw n.default.error(`Invalid number of arguments (expected ${s.length}): ${l.length}`,r);for(var u=0;u<s.length;u++)if(!s[u].equals(l[u]))throw n.default.error(`Argument #${u+1} has illegal argument type (expected ${s[u]}): ${l[u]}`,r);super(r,null,null,i.to),this.fun=e,this.args=t}isProved(e){return e=e||[],super.isProved(e)||this.fun.isProved(e)}toIndentedString(e,t){var r=this.args.map((t=>t instanceof a.default?`${t.name}<${t._id}>`:t.toIndentedString(e+1)));return r.join("").length<=50?(r=(r=this.args.map((t=>t instanceof a.default?`${t.name}<${t._id}>`:t.toIndentedString(e)))).join(", "),this.fun instanceof l.default?`${this.fun.name||`(${this.fun})`}(${r})`:[this.fun instanceof i.default&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(e)+")",`(${r})`].join("")):(r=r.join(",\n"+"\t".repeat(e+1)),this.fun instanceof l.default?[this.fun.name||`(${this.fun.toIndentedString(e)})`,"(","\t"+r,")"].join("\n"+"\t".repeat(e)):[(this.fun instanceof i.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(e)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(e)))}toTeXString(e,t){if(this.fun instanceof l.default)return(this.fun.name?`\\href{#schema-${this.fun.isProved()?"p":"np"}-${this.fun.name}}{\\textsf{${n.default.escapeTeX(this.fun.name)}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((e=>e.toTeXString(n.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof u.default)return this.fun.funcallToTeXString(this.args,e);var r=this.args.map((e=>e.toTeXString(n.default.PREC_COMMA)));return(!o.isNameable(this.fun)||!this.fun.name||this.fun instanceof a.default?this.fun.toTeXString(!1):1==this.fun.name.length?n.default.escapeTeX(this.fun.name):`\\mathrm{${n.default.escapeTeX(this.fun.name)}}`)+`\\mathord{\\left(${r.join(", ")}\\right)}`}}t.default=Funcall},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5),a=r(1),i=r(0);class Schema extends a.default{constructor({doc:e,tex:t,annotations:r,axiomatic:n,type:a,name:i,params:s,def$s:o,expr:l},u){super({doc:e,tex:t,annotations:r,type:a,name:i,params:s,expr:l},u),this.axiomatic=n,this.def$s=o||[]}isProved(e){if(this._isProvedCache)return!0;if(!e&&"boolean"==typeof this._isProvedCache)return this._isProvedCache;var t=!e;e=e||[];var r=this.axiomatic||super.isProved(e);return t&&(this._isProvedCache=r),r}toIndentedString(e,t){return[`∫ ${this.name||""}(${this.params.map((t=>t.toIndentedString(e))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(e+1),"}"].join("\n"+"\t".repeat(e))}toTeXString(e,t){if(!this.name)return this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(e)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((e=>e.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",n.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(e)?"\\right)":""].join("");var r=`schema-${this.isProved()?"p":"np"}-${this.name}`;return t?`\\href{#${r}}{\\mathsf{${i.default.escapeTeX(this.name)}}}\\mathord{\\left(${this.params.map((e=>e.toTeXStringWithId(i.default.PREC_COMMA)+(e.guess?`: \\texttt{@${e.guess}}`:""))).join(", ")}\\right)}:\\\\\\quad`+n.default.expandMetaAndFuncalls(this.expr).toTeXString(!0):`\\href{#${r}}\\mathsf{${i.default.escapeTeX(this.name)}}`}}t.default=Schema},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5),a=r(1),i=r(0);class ObjectFun extends a.default{constructor({doc:e,tex:t,annotations:r,type:n,name:a,params:i,expr:s},o){super({doc:e,tex:t,annotations:r,type:n,name:a,params:i,expr:s},o)}toIndentedString(e,t){return[`ƒ ${this.name||""}(${this.params.map((t=>t.toIndentedString(e))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(e+1),"}"].join("\n"+"\t".repeat(e))}toTeXString(e,t){return this.name?t?this.expr?this.funcallToTeXString(this.params,i.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(i.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,e):`\\href{#def-${this.name}}\\mathrm{${i.default.escapeTeX(this.name)}}`:(this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(e)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((e=>e.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",n.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(e)?"\\right)":""].join(""))}funcallToTeXString(e,t){return e=e.map((e=>e.toTeXString(this.tex?this.precedence:i.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,e,t):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?i.default.escapeTeX(this.name):`\\mathrm{${i.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`\\mathord{\\left(${e.join(", ")}\\right)}`}}t.default=ObjectFun},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6);class Expr0 extends n.default{}t.default=Expr0},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(2),i=r(14);class MetaType extends i.default{constructor(e){if(super(null,null,null,e.functional),"boolean"!=typeof e.functional)throw n.default.error("typeof o.functional != 'boolean'",null);if(0==e.functional){if(!(e.left instanceof Array))throw n.default.error("left should be an array",null);this.left=e.left,this.right=e.right}else{if(e.from.some((e=>!(e instanceof a.default))))throw n.default.error("o.from.some(f => !(f instanceof ObjectType))",null);if(!(e.to instanceof MetaType))throw n.default.error("!(o.to instanceof MetaType)",null);if(e.to.isFunctional)throw n.default.error("Functional metatype in functional metatype is not supported",null);this.from=e.from,this.to=e.to}}resolve(){return this}toIndentedString(e){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(e,t){throw new Error("Method not implemented.")}equals(e){if(!(e instanceof MetaType))return!1;if(this.isSimple!=e.isSimple)return!1;if(this.isSimple){if(this.left.length!=e.left.length)return!1;for(let t=0;t<this.left.length;t++)if(!this.left[t].equals(e.left[t]))return!1;return!!this.right.equals(e.right)}if(this.from.length!=e.from.length)return!1;for(let t=0;t<this.from.length;t++)if(!this.from[t].equals(e.from[t]))return!1;return this.to.equals(e.to)}}t.default=MetaType},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),a=r(8),i=r(5),s=r(7),o=r(1),l=r(12),u=r(6);class Reduction extends u.default{constructor({subject:e,guesses:t,leftargs:r,expected:u},f){if(t){let r=e.type.resolve().from,a=t.map((e=>e&&e.type));if(r.length!=a.length)throw n.default.error(`Invalid number of arguments (expected ${r.length}): ${a.length}`,f);for(var c=0;c<r.length;c++)if(a[c]&&!r[c].equals(a[c]))throw n.default.error(`Argument #${c+1} has illegal argument type (expected ${r[c]}): ${a[c]}`,f)}if(e instanceof o.default){e.params.forEach(((e,r)=>{if(!(t&&t[r]||e.guess))throw n.default.error(`Argument #${r+1} could not be guessed`,f)}));var d=e.params.map(((n,a)=>{if(t&&t[a])return t[a];var s=i.default.expandMeta(e.expr);return Reduction.query(n.guess,s.left,r,s.right,u,f)}));e=new a.default({fun:e,args:d},f)}else if(t)throw n.default.error("Something's wrong",f);if(!(e.type instanceof l.default&&e.type.isSimple))throw n.default.error("Subject is not reducible",f);if(!(r instanceof Array)||r.map((e=>e instanceof n.default)).some((e=>!e)))throw n.default.error("Assertion failed",f);var p=e.type.left,h=r.map((e=>e.type));if(p.length!=h.length)throw n.default.error(`Invalid number of arguments (expected ${p.length}): ${h.length}`,f);for(let e=0;e<p.length;e++)if(!p[e].equals(h[e]))throw n.default.error(`Illegal argument type (expected ${p[e]}): ${h[e]}`,f);super(f,null,null,e.type.right),this.subject=e,this.leftargs=r;var m=i.default.expandMetaAndFuncalls(e);if(!(m instanceof s.default))throw n.default.error("Assertion failed",f);for(let e=0;e<m.left.length;e++)if(!i.default.equals(m.left[e],r[e]))throw n.default.error(`LHS #${e+1} failed to match:\n\n--- EXPECTED ---\n${i.default.expandMetaAndFuncalls(m.left[e])}\n----------------\n\n--- RECEIVED ---\n${i.default.expandMetaAndFuncalls(r[e])}\n----------------`,f);if(u){if(!i.default.equals(m.right,u))throw n.default.error(`RHS failed to match:\n\n--- EXPECTED ---\n${i.default.expandMetaAndFuncalls(m.right)}\n----------------\n\n--- RECEIVED ---\n${i.default.expandMetaAndFuncalls(u)}\n----------------`,f);this.reduced=u}else this.reduced=m.right}isProved(e){return e=e||[],super.isProved(e)||this.subject.isProved(e)&&this.leftargs.every((t=>t.isProved(e)))}static query(e,t,r,a,o,l){if(0==e.length)throw n.default.error("wut",l);var u,f;if("r"==e[0]){if(!o)throw n.default.error("Cannot dereference @"+e,l);u=a,f=o}else{if(!(1<=1*e[0]&&1*e[0]<=r.length))throw n.default.error(`Cannot dereference @${e}: antecedent index out of range`,l);u=t[1*e[0]-1],f=r[1*e[0]-1]}return function recurse(e,t,r,a){if(r=i.default.expandMetaAndFuncalls(r),e.length<=a)return r;if(/[0-9]/.test(e[a])){var o=1*e[a];if(t instanceof s.default&&r instanceof s.default){if(t.left.length!=r.left.length)throw n.default.error(`Cannot dereference @${e}: antecedent length mismatch`,l);if(!(1<=o&&o<=r.left.length))throw n.default.error(`Cannot dereference @${e}: antecedent index out of range`,l);return recurse(e,t.left[o-1],r.left[o-1],a+1)}for(;;){if(!t.fun||!r.fun)throw n.default.error("Cannot dereference @"+e,l);if(i.default.equals(t.fun,r.fun))break;if(!r.fun.expr)throw n.default.error("Cannot dereference @"+e,l);r=i.default.expandCallOnce(r)}if(!r.args||!(1<=o&&o<=r.args.length))throw n.default.error("Cannot dereference @"+e,l);return recurse(e,t.args[o-1],r.args[o-1],a+1)}if("r"==e[a]){if(t instanceof s.default&&r instanceof s.default)return recurse(e,t.right,r.right,a+1);throw n.default.error("Cannot dereference @"+e,l)}throw n.default.error("Cannot dereference @"+e,l)}(e,u,f,1)}toIndentedString(e,t){var r=this.leftargs.map((t=>t.toIndentedString(e+1)));return r.join("").length<=50?(r=(r=this.leftargs.map((t=>t.toIndentedString(e)))).join(", "),[this.subject.toIndentedString(e)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(e+1)),[this.subject.toIndentedString(e)+"[","\t"+r,"]"].join("\n"+"\t".repeat(e)))}toTeXString(e,t){return`${this.subject.toTeXString(!1)}[${this.leftargs.map((e=>e.toTeXString(n.default.PREC_COMMA))).join(", ")}]`}}t.default=Reduction},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(e,t,r,n){super(e,t,r),this.isFunctional=n,this.isSimple=!n}}t.default=Type},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isNameable=void 0,t.isNameable=function isNameable(e){return"name"in e}},function(e,t,r){var n;n=r(17).default;var a=r(18).default;e.exports={grammar:n,Program:a}},function(e,t,r){"use strict";r.r(t),t.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\timport\r\n\t/ typedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\nimport =\r\n\t\'import\' __\r\n\tfilename:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'import\',\r\n\t\t\tfilename,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\tdoc = doc && doc[0];\r\n\t\t\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\tdoc:(documentation __)?\r\n\tannotations: (a:annotation __ {return a})*\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\tannotations,\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:(";" _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\tb:(\r\n\t\t\t_ \'[\' _\r\n\t\t\t\'as\' __\r\n\t\t\tm:metaexpr\r\n\t\t\t\']\'\r\n\t\t\t{return m}\r\n\t\t)?\r\n\t\t{return {a: a || [], b: b || null}}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0].a,\r\n\t\t\texpected: leftargs[0].b,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i].a,\r\n\t\t\t\texpected: leftargs[i].b,\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:expr0 _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => expr0\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\texpr:(\r\n\t\texpr0\r\n\t\t/ "{" _ e:expr0 _ "}" {return e}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => metaexpr_internal_1\r\n// (T t) => { $foo = ...; metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\tfoo:(\r\n\t\texpr:metaexpr_internal_1\r\n\t\t{return {defdollars: [], expr}}\r\n\t\t/ "{" _\r\n\t\tdefdollars: (d:defdollar _ {return d})* _\r\n\t\texpr:metaexpr _\r\n\t\t"}"\r\n\t\t{return {defdollars, expr}}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\tdef$s: foo.defdollars,\r\n\t\t\texpr: foo.expr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_1 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\tright:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tdef$s: defdollars,\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_1 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ndefdollar =\r\n\tname:dollar_ident _\r\n\t\'=\' _\r\n\texpr:metaexpr _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'def$\',\r\n\t\t\tname,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\t}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\tat_var\r\n\t/ dollar_var\r\n\t/ plain_var\r\n\r\nat_var =\r\n\tname:at_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'@\',\r\n\t\t\tname: name.slice(1),\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndollar_var =\r\n\tname:dollar_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'$\',\r\n\t\t\tname: name,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nplain_var =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'normal\',\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"as"\r\n\t/ "axiomatic"\r\n\t/ "base"\r\n\t/ "import"\r\n\t/ "schema"\r\n\t/ "type";\r\n\r\nannotation =\r\n\t\'@discouraged\'\r\n\t/ \'@deprecated\'\r\n\r\nident =\r\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\r\n\r\nat_ident =\r\n\t$(\'@\' [a-zA-Z0-9_]+)\r\n\r\ndollar_ident =\r\n\t$(\'$\' [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(e,t,r){"use strict";var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(a,i){function fulfilled(e){try{step(n.next(e))}catch(e){i(e)}}function rejected(e){try{step(n.throw(e))}catch(e){i(e)}}function step(e){e.done?a(e.value):function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const a=r(19),i=r(22),s=r(23);t.default=class Program{constructor(e){if(this.scope=new a.default(null),this.scopeMap=new Map,!e)throw Error("no");this.parser=e}loadModule(e,t){return n(this,void 0,void 0,(function*(){return this.scope=yield this.loadModuleInternal(e,t)}))}loadModuleInternal(e,t){return n(this,void 0,void 0,(function*(){if(this.scopeMap.has(e))return this.scopeMap.get(e);var r=new a.default(null),n=yield t(e),i=this.parser.parse(n);return yield this.feed(i,r,t),this.scopeMap.set(e,r),r}))}feed(e,t=this.scope,r){return n(this,void 0,void 0,(function*(){for(var n=0;n<e.length;n++){var a=e[n];switch(a._type){case"import":var s=yield this.loadModuleInternal(a.filename,r);t.importMap.set(a.filename,s);break;case"typedef":var o=i.default.type(a,t);if(t.hasType(o.name))throw t.error(`Type ${o.name} has already been declared`);t.addType(o);break;case"defv":var l=i.default.variable(a,t);if(t.hasVariable(l.name))throw t.error(`Definition ${l.name} has already been declared`);t.addVariable(l);break;case"defun":var u=i.default.fun(a,t);if(t.hasVariable(u.name))throw t.error(`Definition ${u.name} has already been declared`);t.addFun(u);break;case"defschema":var f=i.default.schema(a,t);if(t.hasSchema(f.name))throw t.error(`Schema ${f.name} has already been declared`);t.addSchema(f);break;default:throw Error("Unknown line type "+a._type)}}}))}evaluate(e){switch(e._type){case"typedef":return i.default.type(e,this.scope);case"defv":return i.default.variable(e,this.scope);case"defun":return i.default.fun(e,this.scope);case"defschema":case"schemaexpr":return i.default.schema(e,this.scope);case"tee":return i.default.tee(e,this.scope);case"reduction":return i.default.reduction(e,this.scope);case"schemacall":return i.default.schemacall(e,this.scope);case"var":return i.default.metavar(e,this.scope);default:throw Error("Unknown line type "+e._type)}}getProofExplorer(e,t){return s.default.get(this.scope,e,t)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2),a=r(3),i=r(1),s=r(20),o=r(4);class Scope{constructor(e,t){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.parent=e,this.root=e?e.root:this,t&&!(t instanceof s.default))throw Error("Assertion failed");this.trace=t||new s.default,this.baseType=e?e.baseType:null}extend(e,t,r){var n=new Scope(this,this.trace.extend(e,t,r));return this.hypotheses.forEach((e=>n.hypotheses.push(e))),n}error(e){return this.trace.error(e)}hasOwnType(e){if("string"==typeof e)return this.typedefMap.has(e)||[...this.importMap.values()].some((t=>t.hasOwnType(e)));if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");return e.map((e=>this.hasOwnType(e))).every((e=>e))}hasType(e){if("string"==typeof e)return this.hasOwnType(e)||!!this.parent&&this.parent.hasType(e);if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");return e.map((e=>this.hasType(e))).every((e=>e))}addType(e){if(!(e instanceof n.default))throw this.error("Illegal argument type");if(!e.name)throw this.error("Something's wrong");if(this.hasOwnType(e.name))throw this.error(`Type ${e.name} has already been declared`);if(e.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(t){t.baseType=e,t.parent&&broadcast(t.parent)}(this)}return this.typedefMap.set(e.name,e),e}getType(e){if("string"==typeof e){if(!this.hasType(e))throw this.error(`Type ${e} is not defined`);return this.typedefMap.has(e)?this.typedefMap.get(e):!!this.parent&&this.parent.getType(e)||[...this.importMap.values()].filter((t=>t.hasType(e)))[0].getType(e)}if(!(e instanceof Array))throw this.error("Argument is malformed");if(e.length<2)throw this.error("Illegal array length");var t=e.slice(0,e.length-1).map((e=>this.getType(e))),r=this.getType(e[e.length-1]);return new n.default({functional:!0,from:t,to:r})}hasOwnVariable(e){return this.defMap.has(e)||[...this.importMap.values()].some((t=>t.hasOwnVariable(e)))}hasVariable(e){return this.hasOwnVariable(e)||!!this.parent&&this.parent.hasVariable(e)}addVariable(e){if(!(e instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(e.name))throw this.error(`Definition ${e.name} has already been declared`);return this.defMap.set(e.name,e),e}addFun(e){if(!(e instanceof i.default))throw this.error("Illegal argument type");if(!e.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(e.name))throw this.error(`Definition ${e.name} has already been declared`);return this.defMap.set(e.name,e),e}getVariable(e){if(!this.hasVariable(e))throw this.error(`Definition ${e} is not defined`);return this.defMap.has(e)?this.defMap.get(e):!!this.parent&&this.parent.getVariable(e)||[...this.importMap.values()].filter((t=>t.hasVariable(e)))[0].getVariable(e)}hasOwnSchema(e){return this.schemaMap.has(e)||this.defMap.has(e)||[...this.importMap.values()].some((t=>t.hasOwnSchema(e)))}hasSchema(e){return this.hasOwnSchema(e)||!!this.parent&&this.parent.hasSchema(e)}addSchema(e){if(!(e instanceof i.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(e.name))throw this.error(`Schema ${e.name} has already been declared`);return this.schemaMap.set(e.name,e),e}getSchema(e){if(!this.hasSchema(e))throw this.error(`Schema ${e} is not defined`);return this.schemaMap.has(e)?this.schemaMap.get(e):this.defMap.has(e)?this.defMap.get(e):!!this.parent&&this.parent.getSchema(e)||[...this.importMap.values()].filter((t=>t.hasSchema(e)))[0].getSchema(e)}hasOwn$(e){return this.$Map.has(e)||[...this.importMap.values()].some((t=>t.hasOwn$(e)))}has$(e){return this.hasOwn$(e)||!!this.parent&&this.parent.has$(e)}add$(e){if(!(e instanceof o.default))throw this.error("Illegal argument type");if(this.hasOwn$(e.name))throw this.error(`$ variable ${e.name} has already been declared`);return this.$Map.set(e.name,e),e}get$(e){if(!this.has$(e))throw this.error(`$ variable ${e} is not defined`);return this.$Map.has(e)?this.$Map.get(e):!!this.parent&&this.parent.get$(e)||[...this.importMap.values()].filter((t=>t.has$(e)))[0].get$(e)}}t.default=Scope},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});class StackTrace{constructor(e){this.stack=e||[]}extend(e,t,r){return new StackTrace([[e,t,r]].concat(this.stack))}error(t){var r=void 0!==e&&e.argv[2];return new Error(t+"\n\tat "+(this.stack.length?this.stack.map((([e,t,n])=>`${e} ${t||"<anonymous>"} (${r||"<unknown>"}:${n.start.line}:${n.start.column})`)).join("\n\tat "):`<root> (${r||"<unknown>"}:1:1)`))}}t.default=StackTrace}).call(this,r(21))},function(e,t){var r,n,a=e.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(r===setTimeout)return setTimeout(e,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){n=defaultClearTimeout}}();var i,s=[],o=!1,l=-1;function cleanUpNextTick(){o&&i&&(o=!1,i.length?s=i.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!o){var e=runTimeout(cleanUpNextTick);o=!0;for(var t=s.length;t;){for(i=s,s=[];++l<t;)i&&i[l].run();l=-1,t=s.length}i=null,o=!1,function runClearTimeout(e){if(n===clearTimeout)return clearTimeout(e);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}a.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];s.push(new Item(e,t)),1!==s.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(e){return[]},a.binding=function(e){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(e){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2),a=r(3),i=r(7),s=r(8),o=r(13),l=r(4),u=r(9),f=r(10);function typeObjToString(e){if("type"!=e._type)throw Error("Assertion failed");return e.ftype?"["+e.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(e.to)+"]":e.name}function typeObjToNestedArr(e){if("type"!=e._type)throw Error("Assertion failed");if(e.ftype){if(!e.from||!e.to)throw Error("Assertion failed");return e.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(e.to)])}if(!(e=e).name)throw Error("Assertion failed");return e.name}class PI{static type(e,t){if("typedef"!=e._type)throw Error("Assertion failed");var r=t.extend("type",e.name,e.location),a=e.origin?r.getType(typeObjToNestedArr(e.origin)):null,i=e.name,s=e.doc,o=e.base;if(o&&a)throw r.error("Base type should not be an alias");return a?new n.default({name:i,doc:s,base:o,origin:a}):new n.default({functional:!1,name:i,doc:s,base:o})}static variable(e,t){if(!["defv","var"].includes(e._type))throw Error("Assertion failed");var r=t.extend("variable",e.name,e.location);if("var"==e._type){if("normal"!=e.type)throw r.error(`Variable type ${e.type} not allowed`);if(!r.hasVariable(e.name))throw r.error("Undefined identifier "+e.name);return r.getVariable(e.name)}if(!r.hasType(typeObjToNestedArr(e.type)))throw r.error(`Type ${typeObjToString(e.type)} is not defined`);var n=r.getType(typeObjToNestedArr(e.type));return new a.default({type:n,isParam:!!e.isParam,guess:e.guess||null,name:e.name,doc:e.doc,tex:e.tex},r)}static fun(e,t){if("defun"!=e._type&&"funexpr"!=e._type)throw Error("Assertion failed");var r=null,a=null,i=null;"defun"==e._type&&(r=(e=e).name,a=e.doc,i=e.tex);var s=t.extend("fun",r,e.location),o=null,l=e.params.map((e=>{if(!s.hasType(typeObjToNestedArr(e.type)))throw s.error(`Type ${typeObjToString(e.type)} is not defined`);var t=PI.variable(e,s);if(s.hasOwnVariable(t.name))throw s.error(`Parameter ${t.name} has already been declared`);return s.addVariable(t)})),u=null;switch(e._type){case"defun":if(!s.hasType(typeObjToNestedArr(e.rettype)))throw s.error(`Type ${typeObjToString(e.rettype)} is not defined`);var c=s.getType(typeObjToNestedArr(e.rettype));if(e.expr){if(u=PI.expr0(e.expr,s),!c.equals(u.type))throw s.error(`Expression type ${u.type} failed to match the return type ${c} of fun ${r}`)}else o=new n.default({functional:!0,from:l.map((e=>e.type)),to:c});break;case"funexpr":u=PI.expr0(e.expr,s),o=null;break;default:throw Error("wut")}return new f.default({annotations:[],name:r,type:o,params:l,expr:u,doc:a,tex:i},s)}static funcall(e,t){if("funcall"!=e._type)throw Error("Assertion failed");var r=t.extend("funcall","name"in e.schema?e.schema.name:null,e.location),n=PI.expr0(e.schema,r),a=e.args.map((e=>PI.expr0(e,r)));return new s.default({fun:n,args:a},r)}static metaexpr(e,t){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(e._type))throw Error("Assertion failed");var r=t;switch(e._type){case"tee":return PI.tee(e,r);case"reduction":return PI.reduction(e,r);case"schemacall":return PI.schemacall(e,r);case"schemaexpr":return PI.schema(e,r);case"var":return PI.metavar(e,r);default:throw Error("wut")}}static expr0(e,t){if(!["funcall","funexpr","var"].includes(e._type))throw console.log(e),Error("Assertion failed");var r=t;switch(e._type){case"funcall":return PI.funcall(e,r);case"funexpr":return PI.fun(e,r);case"var":return PI.variable(e,r);default:throw Error("wut")}}static metavar(e,t){if("var"!=e._type)throw Error("Assertion failed");var r=t;switch(e.type){case"@":if(e.name.match(/^h[0-9]+$/)){var n=Number(e.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query @"+e.name);case"$":if(!r.has$(e.name))throw r.error(e.name+" is not defined");return r.get$(e.name);case"normal":if(!r.hasSchema(e.name))throw r.error(`Schema ${e.name} is not defined`);return r.getSchema(e.name);default:throw r.error("Unknown type "+e.type)}}static tee(e,t){if("tee"!=e._type)throw Error("Assertion failed");var r=t.extend("tee",null,e.location),n=e.left.map((e=>PI.metaexpr(e,r))),a=r.extend("tee.right",null,e.right.location);n.forEach((e=>a.hypotheses.push(e)));var s=e.def$s.map((e=>{var t=PI.def$(e,a);if(a.hasOwn$(t.name))throw a.error(e.name+" has already been declared");return a.add$(t)})),o=PI.metaexpr(e.right,a);return new i.default({left:n,def$s:s,right:o},r)}static def$(e,t){if("def$"!=e._type)throw Error("Assertion failed");var r=t.extend("def$",e.name,e.location),n=PI.metaexpr(e.expr,r);return new l.default({name:e.name,expr:n},r)}static schema(e,t){if("defschema"!=e._type&&"schemaexpr"!=e._type)throw Error("Assertion failed");var r=null,n=!1,a=null,i=[];"defschema"==e._type&&(r=e.name,n=e.axiomatic,a=e.doc,i=e.annotations);var s=t.extend("schema",r,e.location),o=e.params.map((e=>{if(!s.hasType(typeObjToNestedArr(e.type)))throw s.error(`Type ${typeObjToString(e.type)} is not defined`);var t=PI.variable(e,s);if(s.hasOwnVariable(t.name))throw s.error(`Parameter ${t.name} has already been declared`);return s.addVariable(t)})),l=e.def$s.map((e=>{var t=PI.def$(e,s);if(s.hasOwn$(t.name))throw s.error(e.name+" has already been declared");return s.add$(t)})),f=PI.metaexpr(e.expr,s);return new u.default({doc:a,annotations:i,axiomatic:n,name:r,params:o,def$s:l,expr:f},s)}static schemacall(e,t){if("schemacall"!=e._type)throw Error("Assertion failed");var r=t.extend("schemacall","name"in e.schema?e.schema.name:null,e.location),n=PI.metaexpr(e.schema,r),a=e.args.map((e=>PI.expr0(e,r)));return new s.default({fun:n,args:a},r)}static reduction(e,t){if("reduction"!=e._type)throw Error("Assertion failed");var r=t.extend("reduction","name"in e.subject?e.subject.name:null,e.location),n=PI.metaexpr(e.subject,r),a=e.guesses?e.guesses.map((e=>e&&PI.expr0(e,r))):null,i=e.leftargs.map((e=>PI.metaexpr(e,r))),s=e.expected&&PI.metaexpr(e.expected,r);return new o.default({subject:n,guesses:a,leftargs:i,expected:s},r)}}t.default=PI},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5),a=r(4),i=r(1),s=r(8),o=r(15),l=r(10),u=r(13),f=r(9),c=r(7),d=r(3);t.default=class ProofExplorer{static get(e,t,r){var p="&#x25C7;";if(!e.hasSchema(t))throw Error("wut");var h=e.getSchema(t),m=function recurse(e){return e instanceof u.default?Math.max(...e.leftargs.map(recurse),e.subject instanceof i.default&&e.subject.name||e.subject instanceof s.default&&o.isNameable(e.subject.fun)&&e.subject.fun.name?0:recurse(e.subject),1):e instanceof f.default?Math.max(...e.def$s.map((e=>recurse(e.expr))),recurse(e.expr))+1:e instanceof l.default?recurse(e.expr)+1:e instanceof c.default?Math.max(...e.left.map(recurse),...e.def$s.map((e=>recurse(e.expr))),recurse(e.right))+1:1}(h);function getHtmlLine(e,t,n,a,i){for(var s=t.length,{bbb:o=!1,rrb:l=!1}=i||{},u=t.map(((e,t,n)=>`<td class="${l&&t==n.length-1?"rrb":"brb"}">${e.map((e=>r(e.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),f=0;f<t.length;f++)for(;t[f].length;)t[f].pop();return`<tr><th>${e}</th>${u}<td ${o?'class="bbb" ':""}colspan="${m-s}">${n}</td>${a instanceof Array?a.map((e=>`<td>${e}</td>`)).join(""):`<td colspan="2">${a}</td>`}</tr>`}function exprToHtml(e,t){return"number"==typeof e?`<b>${e}</b>`:e instanceof Array?`<b>${e[0]}&ndash;${e[1]}</b>`:r(t?n.default.expandMetaAndFuncalls(e).toTeXString(!0):e.toTeXString(!0))}var g=0,x=function getTree(e,t,r){if(t.has(e))return[{_type:"R",ctr:++g,num:t.get(e),expr:e}];if(r.has(e))return[{_type:"R",ctr:++g,num:r.get(e),expr:e}];if(e instanceof u.default){var n=[],l=e.leftargs.map((e=>{if(t.has(e))return t.get(e);if(r.has(e))return r.get(e);var a=getTree(e,t,r);return n=n.concat(a),a[a.length-1].ctr})),p=null,m=[],x=t.get(e.subject)||r.get(e.subject)||!!(e.subject instanceof s.default&&r.has(e.subject.fun))&&(p=e.subject.args,r.get(e.subject.fun))||((b=e.subject)instanceof i.default&&b.name||b instanceof s.default&&o.isNameable(b.fun)&&b.fun.name?e.subject:(m=getTree(e.subject,t,r))[m.length-1].ctr);return[...n,...m,{_type:"E",ctr:++g,subject:x,args:p,leftargs:l,reduced:e.reduced}]}if(e instanceof s.default){if(t.has(e.fun))return[{_type:"RC",ctr:++g,schema:t.get(e.fun),args:e.args,expr:e}];if(r.has(e.fun))return[{_type:"RC",ctr:++g,schema:r.get(e.fun),args:e.args,expr:e}];if(e.fun instanceof f.default&&e.fun.name)return[{_type:"RCX",ctr:++g,expr:e}];if(!(e.fun instanceof f.default))return[{_type:"NP",ctr:++g,expr:e}];var y=getTree(e.fun,t,r);return[...y,{_type:"RC",ctr:++g,schema:y[y.length-1].ctr,args:e.args,expr:e}]}if(e instanceof d.default)return[{_type:"NP",ctr:++g,expr:e}];if(e instanceof i.default){if(e instanceof f.default&&e.name&&e!=h)return[{_type:"RS",ctr:++g,expr:e}];if(!e.expr)return[{_type:"NP",ctr:++g,expr:e}];r=new Map(r);var _=g+1,v=[];return e instanceof f.default&&e.def$s.forEach((e=>{var n=getTree(e.expr,t,r);v=v.concat(n);var a=n[n.length-1].ctr;r.set(e,a)})),[{_type:"V",$lines:v,lines:getTree(e.expr,t,r),params:e.params.slice(),ctr:[_,g]}]}if(e instanceof c.default){t=new Map(t);var w=[];_=g+1;e.left.forEach((e=>{t.set(e,++g),w.push({_type:"H",ctr:g,expr:e})})),r=new Map(r);v=[];return e.def$s.forEach((e=>{var n=getTree(e.expr,t,r);v=v.concat(n);var a=n[n.length-1].ctr;r.set(e,a)})),[{_type:"T",leftlines:w,$lines:v,rightlines:getTree(e.right,t,r),ctr:[_,g]}]}if(e instanceof a.default){if(!r.has(e))throw Error(e.name+" is not defined");return[{_type:"R",ctr:++g,num:r.get(e),expr:e.expr}]}return console.log("Unknown metaexpr",e),[{_type:"?",ctr:++g,expr:e}];var b}(h,new Map,new Map),y='<table class="explorer">';return y+=`<tr><th>#</th><th colspan="${m}">expr</th><th colspan="2">rule</th></tr>`,y+=function tree2html(e,t){return e.map((e=>{switch(e._type){case"V":return tree2html(e.$lines,t.concat([e.params]))+tree2html(e.lines,t.concat([e.params]));case"T":var r=t.concat([[]]),n="";if(0==e.leftlines.length)n+=getHtmlLine("",Array(t.length+1).fill([]),"","",{bbb:!0,rrb:!0});else n+=e.leftlines.map(((e,t,n)=>getHtmlLine(e.ctr,r,exprToHtml(e.expr,!0),"assumption",{bbb:t==n.length-1,rrb:!0}))).join("");return n+=tree2html(e.$lines,r),n+=tree2html(e.rightlines,r);case"?":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[p,exprToHtml(e.num)]);case"RS":case"RCX":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[p,exprToHtml(e.expr)]);case"RC":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),[p,`${exprToHtml(e.schema)} (${e.args.map((e=>exprToHtml(e))).join(", ")})`]);case"E":return getHtmlLine(e.ctr,t,exprToHtml(e.reduced,!0),["&#x25BC;",`${exprToHtml(e.subject)}${e.args?" ("+e.args.map((e=>exprToHtml(e))).join(", ")+")":""} [${e.leftargs.map((e=>exprToHtml(e))).join(", ")}]`]);case"NP":return getHtmlLine(e.ctr,t,exprToHtml(e.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(e.ctr,t,"Unknown type "+e._type,"")}})).join("")}(x[0].$lines.concat(x[0].lines),[]),y+="</table>"}}}])}));
//# sourceMappingURL=math.min.js.map