!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=10)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=0;class Node{constructor(t){this._id=++n,this.scope=t}toString(){return this.toIndentedString(0)}error(t){return this.scope?this.scope.error(t):new Error(t)}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t])))}static parseTeX(t){var e=!1,r=t.replace(/^!<prec=([0-9]+)>/,((t,r)=>(e=1*r,"")));return{precedence:e,code:r}}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return!1}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<r[0]||e[0]==r[0]&&e[1]<r[1])}makeTeX(t,e,r){e=e||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,((t,r)=>e[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`)).replace(/<<(.+?)>>/,((e,r)=>`\\href{#${t}}{${r}}`))}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Type extends n.default{constructor(t){if(super(),this.doc=t.doc,this.isBaseType=!!t.base,t.origin){if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");if(this.name=t.name,!(t.origin instanceof Type))throw this.error("!(o.origin instanceof Type)");this.isFunctional=t.origin.isFunctional,this.isSimple=t.origin.isSimple,this.origin=t.origin}else{if("boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.map((t=>t instanceof Type)).some((t=>!t)))throw this.error("o.from.map(f => f instanceof Type).some(e => !e)");if(!(t.to instanceof Type))throw this.error("!(o.to instanceof Type)");this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw this.error("typeof o.name != 'string'");this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map((t=>t.toSimpleString())).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map((t=>t.toTeXString())).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof Type))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=Type},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class Variable extends n.default{constructor({doc:t,tex:e,type:r,name:n,isParam:a,guess:i},s){if(super(s),this.doc=t,this.tex=e,this.isParam=!!a,this.guess=i||null,"string"!=typeof n)throw this.error("Assertion failed");this.type=r,this.name=n}isProved(t){return t=t||[],super.isProved(t)}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this.isParam?"id-"+this._id:"def-"+this.name}}{${this.tex||(1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`)}}`}toTeXStringWithId(t,e){if(!this.isParam)throw Error("wut");return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(t,e),"}"].join("")}}e.default=Variable},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(1),i=r(8),s=r(5),o=r(2);class Fun extends n.default{constructor({doc:t,tex:e,isSchema:r,annotations:s,axiomatic:l,type:u,name:f,params:c,def$s:h,expr:p},d){if(super(d),this.doc=t,this.isSchema=r,this.annotations=s,e){var{precedence:m,code:g}=n.default.parseTeX(e);this.precedence=m,this.tex=g}else this.precedence=!1,this.tex=null;if(!f&&!p)throw this.error("Anonymous fun cannot be primitive");if(u&&p)throw this.error("no");if(!u&&!p)throw this.error("Cannot guess the type of a primitive fun");if(null!==f&&"string"!=typeof f)throw this.error("Assertion failed");if(p&&!(p.type instanceof a.default||p.type instanceof i.default))throw this.error("Assertion failed");if(this.axiomatic=l,this.name=f,!(c instanceof Array)||c.map((t=>t instanceof o.default)).some((t=>!t)))throw this.error("Assertion failed");if(null!==p&&!(p instanceof n.default))throw this.error("Assertion failed");this.type=u||new(p.type instanceof a.default?a.default:i.default)({functional:!0,from:c.map((t=>t.type)),to:p.type}),this.params=c,this.def$s=h||[],this.expr=p,this.proved=this.isProved()}isProved(t){return t=t||[],this.proved||super.isProved(t)||this.axiomatic||this.expr&&this.expr.isProved(t)}toIndentedString(t,e){return[`∫ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=n.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(n.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",s.default.expandMetaAndFuncalls(this.expr).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");if(this.isSchema){var r=`schema-${this.proved?"p":"np"}-${this.name}`;return e?`\\href{#${r}}{\\mathsf{${n.default.escapeTeX(this.name)}}}\\mathord{\\left(${this.params.map((t=>t.toTeXStringWithId(n.default.PREC_COMMA)+(t.guess?`: \\texttt{@${t.guess}}`:""))).join(", ")}\\right)}:\\\\\\quad`+s.default.expandMetaAndFuncalls(this.expr).toTeXString(!0):`\\href{#${r}}\\mathsf{${n.default.escapeTeX(this.name)}}`}return e?this.expr?this.funcallToTeXString(this.params,n.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(n.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}\\mathrm{${n.default.escapeTeX(this.name)}}`}funcallToTeXString(t,e){return t=t.map((t=>t.toTeXString(this.tex?this.precedence:n.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${1==this.name.length?n.default.escapeTeX(this.name):`\\mathrm{${n.default.escapeTeX(this.name)}}`}}`:this.toTeXString(!1))+`\\mathord{\\left(${t.join(", ")}\\right)}`}}e.default=Fun},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class $var extends n.default{constructor({name:t,expr:e},r){if(super(r),!t||!e)throw this.error("Assertion failed");this.type=e.type,this.name=t,this.expr=e}isProved(t){return t=t||[],super.isProved(t)||this.expr.isProved(t)}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${n.default.escapeTeX(this.name)}}`}}e.default=$var},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(4),a=r(9),i=r(3),s=r(6),o=r(7),l=r(2),u=r(1);function iscall(t){return t instanceof s.default}function makecall(t,e){if(t instanceof l.default||t instanceof i.default)return new s.default({fun:t,args:e});throw console.log(t),Error()}class ER{static substitute(t,e){if(t instanceof s.default)return new s.default({fun:ER.substitute(t.fun,e),args:t.args.map((t=>ER.substitute(t,e)))});if(t instanceof i.default){if(!t.expr)return t;if(t.name)return t;if(t.params.some((t=>e.has(t))))throw Error("Parameter collision");return new i.default({isSchema:t.isSchema,annotations:t.annotations,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.substitute(t.expr,e)})}if(t instanceof l.default)return e.get(t)||t;if(t instanceof o.default){var r=t.left.map((t=>ER.substitute(t,e))),u=ER.substitute(t.right,e);return new o.default({left:r,right:u})}if(t instanceof a.default)return ER.substitute(t.reduced,e);if(t instanceof n.default)return ER.substitute(t.expr,e);throw console.log(t),Error("Unknown metaexpr")}static call(t,e){if(!(t instanceof i.default))throw console.log(t),Error("Illegal type");if(!t.expr)throw Error("Cannot call a callable without a body");if(t.params.length!=e.length)throw Error("Illegal arguments length");for(var r=new Map,n=0;n<t.params.length;n++)r.set(t.params[n],e[n]);return ER.substitute(t.expr,r)}static expandCallOnce(t){if(!iscall(t))throw Error("Illegal type");if(iscall(t.fun))return makecall(ER.expandCallOnce(t.fun),t.args);for(var e=t.fun;e instanceof n.default;)e=e.expr;if(!(e instanceof i.default))throw Error("Something's wrong");if(!e.expr)throw Error("Could not expand");return ER.call(e,t.args)}static expandMeta(t){if(t instanceof o.default){var e=t.left.map(ER.expandMeta),r=ER.expandMeta(t.right);return new o.default({left:e,right:r})}if(t instanceof s.default){var f=ER.expandMeta(t.fun),c=t.args;return!f.expr||f.name&&!f.isSchema?new s.default({fun:f,args:c}):ER.expandMeta(ER.call(f,c))}if(t instanceof a.default)return ER.expandMeta(t.reduced);if(t instanceof i.default)return t.expr?t.type instanceof u.default&&t.name?t:new i.default({isSchema:t.isSchema,annotations:t.annotations,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMeta(t.expr)}):t;if(t instanceof l.default)return t;if(t instanceof n.default)return ER.expandMeta(t.expr);throw console.log(t),Error("Unknown metaexpr")}static expandMetaAndFuncalls(t){if(t instanceof o.default){var e=t.left.map(ER.expandMetaAndFuncalls),r=ER.expandMetaAndFuncalls(t.right);return new o.default({left:e,right:r})}if(t instanceof i.default)return t.expr?t.type instanceof u.default&&t.name?t:new i.default({isSchema:t.isSchema,annotations:t.annotations,axiomatic:t.axiomatic,name:null,params:t.params,expr:ER.expandMetaAndFuncalls(t.expr)}):t;if(t instanceof s.default){var f=ER.expandMetaAndFuncalls(t.fun),c=t.args.map(ER.expandMetaAndFuncalls);return!f.expr||f.name&&!f.isSchema?new s.default({fun:f,args:c}):ER.expandMetaAndFuncalls(ER.call(f,c))}if(t instanceof a.default)return ER.expandMetaAndFuncalls(t.reduced);if(t instanceof l.default)return t;if(t instanceof n.default)return ER.expandMetaAndFuncalls(t.expr);throw console.log(t),Error("Unknown metaexpr")}static equals(t,e){var r=function recurse(t,e,i){if(t==e)return!0;if(!t.type.equals(e.type))return!1;if(t instanceof a.default)return r(t.reduced,e,i+1);if(e instanceof a.default)return r(t,e.reduced,i+1);if(t instanceof n.default)return r(t.expr,e,i+1);if(e instanceof n.default)return r(t,e.expr,i+1);if(iscall(t)&&iscall(e)){if(iscall(t.fun))return r(ER.expandCallOnce(t),e,i+1);if(iscall(e.fun))return r(t,ER.expandCallOnce(e),i+1);var s="expr"in t.fun&&t.fun.expr,u="expr"in e.fun&&e.fun.expr;if(t.fun==e.fun||!s&&!u){if(t.fun!=e.fun)return!1;if(!s&&!u){for(var f=0;f<t.args.length;f++)if(!r(t.args[f],e.args[f],i+1))return!1;return!0}if(t.args.every(((n,a)=>r(t.args[a],e.args[a],i+1))))return!0}return s?r(ER.expandCallOnce(t),e,i+1):r(t,ER.expandCallOnce(e),i+1)}if(iscall(t))return(iscall(t.fun)||!(!("expr"in t.fun)||!t.fun.expr))&&r(ER.expandCallOnce(t),e,i+1);if(iscall(e))return(iscall(e.fun)||!(!("expr"in e.fun)||!e.fun.expr))&&r(t,ER.expandCallOnce(e),i+1);if(t instanceof o.default){e=e;for(f=0;f<t.left.length;f++)if(!r(t.left[f],e.left[f],i+1))return!1;return r(t.right,e.right,i+1)}if(t.type.isFunctional){var c=[],h=t.type.resolve().from.length;for(f=0;f<h;f++)c.push(new l.default({isParam:!0,type:t.type.resolve().from[f],name:"$"+f}));return r(makecall(t,c),makecall(e,c),i+1)}return!1};ER.nequalscall++;var i=r(t,e,0);return i&&ER.nequalstrue++,i}}e.default=ER,ER.nequalscall=0,ER.nequalstrue=0,ER.nrecursecall=0,ER.nrecursetrue=0},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(2),i=r(3);class Funcall extends n.default{constructor({fun:t,args:e},r){if(super(r),t.type.isSimple){var a="name"in t?t.name:"<anonymous>";throw this.error(a+" is not callable")}if(!(e instanceof Array)||e.map((t=>t instanceof n.default)).some((t=>!t)))throw this.error("Assertion failed");var i=t.type.resolve(),s=i.from,o=e.map((t=>t.type));if(s.length!=o.length)throw this.error(`Invalid number of arguments (expected ${s.length}): ${o.length}`);for(var l=0;l<s.length;l++)if(!s[l].equals(o[l]))throw this.error(`Argument #${l+1} has illegal argument type (expected ${s[l]}): ${o[l]}`);this.fun=t,this.type=i.to,this.args=e}isProved(t){return t=t||[],super.isProved(t)||this.fun.isProved(t)}toIndentedString(t,e){var r=this.args.map((e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.args.map((e=>e instanceof a.default?`${e.name}<${e._id}>`:e.toIndentedString(t)))).join(", "),"isSchema"in this.fun&&this.fun.isSchema?`${this.fun.name||`(${this.fun})`}(${r})`:[this.fun instanceof i.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")",`(${r})`].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),"isSchema"in this.fun&&this.fun.isSchema?[this.fun.name||`(${this.fun.toIndentedString(t)})`,"(","\t"+r,")"].join("\n"+"\t".repeat(t)):[(this.fun instanceof i.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if("isSchema"in this.fun&&this.fun.isSchema)return(this.fun.name?`\\href{#schema-${this.fun.proved?"p":"np"}-${this.fun.name}}{\\textsf{${n.default.escapeTeX(this.fun.name)}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((t=>t.toTeXString(n.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof i.default)return this.fun.funcallToTeXString(this.args,t);var r=this.args.map((t=>t.toTeXString(n.default.PREC_COMMA)));return(!("name"in this.fun)||!this.fun.name||this.fun instanceof a.default?this.fun.toTeXString(!1):1==this.fun.name.length?n.default.escapeTeX(this.fun.name):`\\mathrm{${n.default.escapeTeX(this.fun.name)}}`)+`\\mathord{\\left(${r.join(", ")}\\right)}`}}e.default=Funcall},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(8),i=r(5),s=r(4),o=r(1);class Tee extends n.default{constructor({left:t,def$s:e,right:r},i){if(super(i),this.precedence=n.default.PREC_COMMA,!(t instanceof Array&&t.every((t=>t.type instanceof o.default||t.type instanceof a.default))))throw console.log(t),this.error("Assertion failed");if(e&&!(e instanceof Array&&e.every((t=>t instanceof s.default))))throw this.error("Assertion failed");if(!(r.type instanceof o.default||r.type instanceof a.default))throw console.log(r),this.error("Assertion failed");if(r.type.isFunctional)throw this.error("RHS of a rule cannot be a schema");this.left=t,this.def$s=e||[],this.right=r,this.type=new a.default({functional:!1,left:t.map((t=>t.type)),right:r.type})}isProved(t){return t=t||[],super.isProved(t)||this.right.isProved(t.concat(this.left))}toIndentedString(t,e){return this.left.length?["\t"+this.left.map((e=>e.toIndentedString(t+1))).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var r=i.default.expandMetaAndFuncalls(this);return[this.shouldConsolidate(t)?"\\left(":"",`{${r.left.map((t=>t.toTeXString(n.default.PREC_COMMA))).join(", ")} \\vdash ${r.right.toTeXString(n.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(1);class MetaType extends n.default{constructor(t){if(super(),"boolean"!=typeof t.functional)throw this.error("typeof o.functional != 'boolean'");if(this.isFunctional=t.functional,this.isSimple=!t.functional,t.functional){if(t.from.some((t=>!(t instanceof a.default))))throw this.error("o.from.some(f => !(f instanceof Type))");if(!(t.to instanceof MetaType))throw this.error("!(o.to instanceof MetaType)");if(t.to.isFunctional)throw this.error("Functional metatype in functional metatype is not supported");this.from=t.from,this.to=t.to}else{if(!(t.left instanceof Array))throw this.error("left should be an array");this.left=t.left,this.right=t.right}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),a=r(6),i=r(5),s=r(7),o=r(3),l=r(8);class Reduction extends n.default{constructor({subject:t,guesses:e,leftargs:r,expected:u},f){if(super(f),e){var c=t.type.resolve().from,h=e.map((t=>t&&t.type));if(c.length!=h.length)throw this.error(`Invalid number of arguments (expected ${c.length}): ${h.length}`);for(var p=0;p<c.length;p++)if(h[p]&&!c[p].equals(h[p]))throw this.error(`Argument #${p+1} has illegal argument type (expected ${c[p]}): ${h[p]}`)}if(t instanceof o.default){t.params.forEach(((t,r)=>{if(!(e&&e[r]||t.guess))throw this.error(`Argument #${r+1} could not be guessed`)}));var d=t.params.map(((n,a)=>{if(e&&e[a])return e[a];var s=i.default.expandMeta(t.expr);return this.query(n.guess,s.left,r,s.right,u)}));t=new a.default({fun:t,args:d},f)}else if(e)throw this.error("Something's wrong");if(!(t.type instanceof l.default&&t.type.isSimple))throw this.error("Subject is not reducible");if(!(r instanceof Array)||r.map((t=>t instanceof n.default)).some((t=>!t)))throw this.error("Assertion failed");this.subject=t,this.leftargs=r;c=t.type.left;var m=r.map((t=>t.type));if(c.length!=m.length)throw this.error(`Invalid number of arguments (expected ${c.length}): ${m.length}`);for(let t=0;t<c.length;t++)if(!c[t].equals(m[t]))throw this.error(`Illegal argument type (expected ${c[t]}): ${m[t]}`);this.type=t.type.right;var g=i.default.expandMetaAndFuncalls(t);if(!(g instanceof s.default))throw this.error("Assertion failed");for(let t=0;t<g.left.length;t++)if(!i.default.equals(g.left[t],r[t]))throw this.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${i.default.expandMetaAndFuncalls(g.left[t])}\n----------------\n\n--- RECEIVED ---\n${i.default.expandMetaAndFuncalls(r[t])}\n----------------`);if(u){if(!i.default.equals(g.right,u))throw this.error(`RHS failed to match:\n\n--- EXPECTED ---\n${i.default.expandMetaAndFuncalls(g.right)}\n----------------\n\n--- RECEIVED ---\n${i.default.expandMetaAndFuncalls(u)}\n----------------`);this.reduced=u}else this.reduced=g.right}isProved(t){return t=t||[],super.isProved(t)||this.subject.isProved(t)&&this.leftargs.every((e=>e.isProved(t)))}query(t,e,r,n,a){if(0==t.length)throw this.error("wut");var o,l;if("r"==t[0]){if(!a)throw this.error("Cannot dereference @"+t);o=n,l=a}else{if(!(1<=1*t[0]&&1*t[0]<=r.length))throw this.error(`Cannot dereference @${t}: antecedent index out of range`);o=e[1*t[0]-1],l=r[1*t[0]-1]}var u=this;return function recurse(t,e,r,n){if(r=i.default.expandMetaAndFuncalls(r),t.length<=n)return r;if(/[0-9]/.test(t[n])){var a=1*t[n];if(e instanceof s.default&&r instanceof s.default){if(e.left.length!=r.left.length)throw u.error(`Cannot dereference @${t}: antecedent length mismatch`);if(!(1<=a&&a<=r.left.length))throw u.error(`Cannot dereference @${t}: antecedent index out of range`);return recurse(t,e.left[a-1],r.left[a-1],n+1)}for(;;){if(!e.fun||!r.fun)throw u.error("Cannot dereference @"+t);if(i.default.equals(e.fun,r.fun))break;if(!r.fun.expr)throw u.error("Cannot dereference @"+t);r=i.default.expandCallOnce(r)}if(!r.args||!(1<=a&&a<=r.args.length))throw u.error("Cannot dereference @"+t);return recurse(t,e.args[a-1],r.args[a-1],n+1)}if("r"==t[n]){if(e instanceof s.default&&r instanceof s.default)return recurse(t,e.right,r.right,n+1);throw u.error("Cannot dereference @"+t)}throw u.error("Cannot dereference @"+t)}(t,o,l,1)}toIndentedString(t,e){var r=this.leftargs.map((e=>e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.leftargs.map((e=>e.toIndentedString(t)))).join(", "),[this.subject.toIndentedString(t)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+r,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map((t=>t.toTeXString(n.default.PREC_COMMA))).join(", ")}]`}}e.default=Reduction},function(t,e,r){var n;n=r(11).default;var a=r(12).default;t.exports={grammar:n,Program:a}},function(t,e,r){"use strict";r.r(e),e.default='start =\r\n\t_ lines:(a:line _ {return a})* {return lines}\r\n\r\nline =\r\n\timport\r\n\t/ typedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\r\nevaluable =\r\n\t_ e:evaluable_internal _ {return e}\r\n\r\nevaluable_internal =\r\n\ttypedef\r\n\t/ defv\r\n\t/ defun\r\n\t/ defschema\r\n\t/ metaexpr\r\n\r\nimport =\r\n\t\'import\' __\r\n\tfilename:ident _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'import\',\r\n\t\t\tfilename,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ntypedef =\r\n\tdoc:(documentation __)?\r\n\tbase:("base" __)?\r\n\t"type" __\r\n\torigin:(o:ftype __ {return o})?\r\n\tname:ident _ sem\r\n\t{\r\n\t\tdoc = doc && doc[0];\r\n\t\t\r\n\t\treturn {\r\n\t\t\t_type: \'typedef\',\r\n\t\t\tdoc,\r\n\t\t\tbase: !!base,\r\n\t\t\torigin,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefv =\r\n\tdoc:(documentation __)? tex:(tex __)? type:type __ name:ident _ sem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\ttype,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschemaparam =\r\n\ttex:(tex __)? type:type __ name:ident\r\n\tguess:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defv\',\r\n\t\t\tisParam: true,\r\n\t\t\tguess,\r\n\t\t\ttype,\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n \r\ndefun =\r\n\tdoc:(documentation __)?\r\n\ttex:(tex __)?\r\n\trettype:type __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\texpr:(\r\n\t\t"{" _\r\n\t\texpr:expr0 _\r\n\t\t"}"\r\n\t\t{return expr}\r\n\t\t/ sem {return null}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defun\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\ttex: tex && tex[0],\r\n\t\t\trettype,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndefschema =\r\n\tdoc:(documentation __)?\r\n\tannotations: (a:annotation __ {return a})*\r\n\taxiomatic:("axiomatic" __)?\r\n\t"schema" __\r\n\tname:ident _\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defschemaparam _\r\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"{" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\texpr:metaexpr _\r\n\t"}"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'defschema\',\r\n\t\t\tdoc: doc && doc[0],\r\n\t\t\tannotations,\r\n\t\t\taxiomatic: !!axiomatic,\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\tdef$s: defdollars,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// var[...]\r\n// foo(...)[...]\r\n// foo[...][...]\r\n// (metaexpr)[...]\r\n// schema(?, ...)[...]\r\nreduction =\r\n\tsubject:(\r\n\t\tschemacall\r\n\t\t/ var\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\tguesses:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:(\'?\' {return null} / expr0) _\r\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)?\r\n\tleftargs:(\r\n\t\t"[" _\r\n\t\ta:(\r\n\t\t\thead:metaexpr _\r\n\t\t\ttail:(";" _ e:metaexpr _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t"]"\r\n\t\tb:(\r\n\t\t\t_ \'[\' _\r\n\t\t\t\'as\' __\r\n\t\t\tm:metaexpr\r\n\t\t\t\']\'\r\n\t\t\t{return m}\r\n\t\t)?\r\n\t\t{return {a: a || [], b: b || null}}\r\n\t)+\r\n\t{\r\n\t\tvar ret = {\r\n\t\t\t_type: \'reduction\',\r\n\t\t\tsubject,\r\n\t\t\tguesses,\r\n\t\t\tleftargs: leftargs[0].a,\r\n\t\t\texpected: leftargs[0].b,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\r\n\t\tfor (var i = 1; i < leftargs.length; i++) {\r\n\t\t\tret = {\r\n\t\t\t\t_type: \'reduction\',\r\n\t\t\t\tsubject: ret,\r\n\t\t\t\tguesses: null,\r\n\t\t\t\tleftargs: leftargs[i].a,\r\n\t\t\t\texpected: leftargs[i].b,\r\n\t\t\t\tlocation: location()\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n// var(...)\r\n// (metaexpr)(...)\r\nschemacall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:metaexpr _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemacall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// forall(f, g)\r\n// (expr0)(f, g)\r\nfuncall =\r\n\tschema:(\r\n\t\tvar\r\n\t\t/ "(" _\r\n\t\te:expr0 _\r\n\t\t")"\r\n\t\t{return e}\r\n\t) _\r\n\targs:(\r\n\t\t"(" _\r\n\t\ta:(\r\n\t\t\thead:expr0 _\r\n\t\t\ttail:("," _ e:expr0 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")"\r\n\t\t{return a || []}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funcall\',\r\n\t\t\tschema,\r\n\t\t\targs,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => expr0\r\n// (T t) => { expr0 }\r\nfunexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\texpr:(\r\n\t\texpr0\r\n\t\t/ "{" _ e:expr0 _ "}" {return e}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'funexpr\',\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\n// (T t) => metaexpr_internal_1\r\n// (T t) => { $foo = ...; metaexpr }\r\nschemaexpr =\r\n\tparams:(\r\n\t\t"(" _\r\n\t\tp:(\r\n\t\t\thead:defparam _\r\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)?\r\n\t\t")" _\r\n\t\t{return p || []}\r\n\t)\r\n\t"=>" _\r\n\tfoo:(\r\n\t\texpr:metaexpr_internal_1\r\n\t\t{return {defdollars: [], expr}}\r\n\t\t/ "{" _\r\n\t\tdefdollars: (d:defdollar _ {return d})* _\r\n\t\texpr:metaexpr _\r\n\t\t"}"\r\n\t\t{return {defdollars, expr}}\r\n\t)\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'schemaexpr\',\r\n\t\t\tparams,\r\n\t\t\tdef$s: foo.defdollars,\r\n\t\t\texpr: foo.expr,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nmetaexpr =\r\n\tleft:(\r\n\t\tl:(\r\n\t\t\thead:metaexpr_internal_1 _\r\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\r\n\t\t\t{return [head].concat(tail)}\r\n\t\t)? {return l || []}\r\n\t)\r\n\t"|-" _\r\n\tdefdollars: (d:defdollar _ {return d})* _\r\n\tright:metaexpr\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'tee\',\r\n\t\t\tdef$s: defdollars,\r\n\t\t\tleft,\r\n\t\t\tright,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\t/ metaexpr_internal_1\r\n\r\n/*\r\n * 다음이 성립하여야 한다.\r\n *\r\n * - reduction이 schemacall보다 앞이다.\r\n * - schemacall이 var보다 앞이다.\r\n *\r\n */\r\nmetaexpr_internal_1 =\r\n\treduction\r\n\t/ schemacall\r\n\t/ var\r\n\t/ schemaexpr\r\n\t/ "(" _ e:metaexpr _ ")" {return e}\r\n\r\nexpr0 =\r\n\tfuncall\r\n\t/ funexpr\r\n\t/ var\r\n\t/ "(" _ e:expr0 _ ")" {return e}\r\n\r\ndefdollar =\r\n\tname:dollar_ident _\r\n\t\'=\' _\r\n\texpr:metaexpr _\r\n\tsem\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'def$\',\r\n\t\t\tname,\r\n\t\t\texpr,\r\n\t\t\tlocation: location()\r\n\t\t};\r\n\t}\r\n\r\ntype =\r\n\tstype\r\n\t/ ftype\r\n\r\nstype =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: false,\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nftype =\r\n\t"[" _\r\n\tfrom:(\r\n\t\ttype:type {return [type]}\r\n\t\t/ (\r\n\t\t\ttt:(\r\n\t\t\t\t"(" _\r\n\t\t\t\thead: type\r\n\t\t\t\ttail:(_ "," _ t:type {return t})*\r\n\t\t\t\t_ ")"\r\n\t\t\t\t{return [head].concat(tail)}\r\n\t\t\t)\r\n\t\t\t{return tt}\r\n\t\t)\r\n\t) _\r\n\t"->" _\r\n\tto:type _\r\n\t"]"\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'type\',\r\n\t\t\tftype: true,\r\n\t\t\tfrom,\r\n\t\t\tto,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nvar =\r\n\tat_var\r\n\t/ dollar_var\r\n\t/ plain_var\r\n\r\nat_var =\r\n\tname:at_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'@\',\r\n\t\t\tname: name.slice(1),\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\ndollar_var =\r\n\tname:dollar_ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'$\',\r\n\t\t\tname: name,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nplain_var =\r\n\tname:ident\r\n\t{\r\n\t\treturn {\r\n\t\t\t_type: \'var\',\r\n\t\t\ttype: \'normal\',\r\n\t\t\tname,\r\n\t\t\tlocation: location()\r\n\t\t}\r\n\t}\r\n\r\nkeyword =\r\n\t"as"\r\n\t/ "axiomatic"\r\n\t/ "base"\r\n\t/ "import"\r\n\t/ "schema"\r\n\t/ "type";\r\n\r\nannotation =\r\n\t\'@discouraged\'\r\n\t/ \'@deprecated\'\r\n\r\nident =\r\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\r\n\r\nat_ident =\r\n\t$(\'@\' [a-zA-Z0-9_]+)\r\n\r\ndollar_ident =\r\n\t$(\'$\' [a-zA-Z0-9_]+)\r\n\r\ndocumentation =\r\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\r\n\t\treturn b\r\n\t}\r\n\r\ntex =\r\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\r\n\t\treturn b\r\n\t}\r\n\r\ncomment =\r\n\t"#" (!newline .)*\r\n\t/ "//" (!newline .)*\r\n\t/ "/*" (!"*/" .)* "*/"\r\n\r\nnewline =\r\n\t"\\r\\n" / "\\r" / "\\n"\r\n\r\n// optional whitespace\r\n_ =\r\n\t([ \\t\\n\\r] / comment)*\r\n\r\n// mandatory whitespace\r\n__ =\r\n\t([ \\t\\n\\r] / comment)+\r\n\r\nsem =\r\n\t";"'},function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(a,i){function fulfilled(t){try{step(n.next(t))}catch(t){i(t)}}function rejected(t){try{step(n.throw(t))}catch(t){i(t)}}function step(t){t.done?a(t.value):function adopt(t){return t instanceof r?t:new r((function(e){e(t)}))}(t.value).then(fulfilled,rejected)}step((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0});const a=r(13),i=r(16),s=r(5),o=r(9),l=r(3),u=r(7),f=r(6),c=r(2),h=r(4);e.default=class Program{constructor(t){if(this.scope=new a.default(null),this.scopeMap=new Map,!t)throw Error("no");this.parser=t}loadModule(t,e){return n(this,void 0,void 0,(function*(){return this.scope=yield this.loadModuleInternal(t,e)}))}loadModuleInternal(t,e){return n(this,void 0,void 0,(function*(){if(this.scopeMap.has(t))return this.scopeMap.get(t);var r=new a.default(null),n=yield e(t),i=this.parser.parse(n);return yield this.feed(i,r,e),this.scopeMap.set(t,r),r}))}feed(t,e=this.scope,r){return n(this,void 0,void 0,(function*(){for(var n=0;n<t.length;n++){var a=t[n];switch(a._type){case"import":var s=yield this.loadModuleInternal(a.filename,r);e.importMap.set(a.filename,s);break;case"typedef":var o=i.default.type(a,e);if(e.hasType(o.name))throw e.error(`Type ${o.name} has already been declared`);e.addType(o);break;case"defv":var l=i.default.variable(a,e);if(e.hasVariable(l.name))throw l.scope.error(`Definition ${l.name} has already been declared`);e.addVariable(l);break;case"defun":var u=i.default.fun(a,e);if(e.hasVariable(u.name))throw u.scope.error(`Definition ${u.name} has already been declared`);e.addFun(u);break;case"defschema":var f=i.default.schema(a,e);if(e.hasSchema(f.name))throw f.scope.error(`Schema ${f.name} has already been declared`);e.addSchema(f);break;default:throw Error("Unknown line type "+a._type)}}}))}evaluate(t){switch(t._type){case"typedef":return i.default.type(t,this.scope);case"defv":return i.default.variable(t,this.scope);case"defun":case"funexpr":return i.default.fun(t,this.scope);case"defschema":case"schemaexpr":return i.default.schema(t,this.scope);case"tee":return i.default.tee(t,this.scope);case"reduction":return i.default.reduction(t,this.scope);case"schemacall":return i.default.schemacall(t,this.scope);case"var":return i.default.metavar(t,this.scope);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){var r="&#x25C7;";if(!this.scope.hasSchema(t))throw Error("wut");var n=this.scope.getSchema(t),a=function recurse(t){return t instanceof o.default?Math.max(...t.leftargs.map(recurse),t.subject instanceof l.default&&t.subject.name||t.subject instanceof f.default&&"name"in t.subject.fun&&t.subject.fun.name?0:recurse(t.subject),1):t instanceof l.default?Math.max(...t.def$s.map((t=>recurse(t.expr))),recurse(t.expr))+1:t instanceof u.default?Math.max(...t.left.map(recurse),...t.def$s.map((t=>recurse(t.expr))),recurse(t.right))+1:1}(n);function getHtmlLine(t,r,n,i,s){for(var o=r.length,{bbb:l=!1,rrb:u=!1}=s||{},f=r.map(((t,r,n)=>`<td class="${u&&r==n.length-1?"rrb":"brb"}">${t.map((t=>e(t.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),c=0;c<r.length;c++)for(;r[c].length;)r[c].pop();return`<tr><th>${t}</th>${f}<td ${l?'class="bbb" ':""}colspan="${a-o}">${n}</td>${i instanceof Array?i.map((t=>`<td>${t}</td>`)).join(""):`<td colspan="2">${i}</td>`}</tr>`}function exprToHtml(t,r){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:e(r?s.default.expandMetaAndFuncalls(t).toTeXString(!0):t.toTeXString(!0))}var i=0,p=function getTree(t,e,r){if(e.has(t))return[{_type:"R",ctr:++i,num:e.get(t),expr:t}];if(r.has(t))return[{_type:"R",ctr:++i,num:r.get(t),expr:t}];if(t instanceof o.default){var a=[],s=t.leftargs.map((t=>{if(e.has(t))return e.get(t);if(r.has(t))return r.get(t);var n=getTree(t,e,r);return a=a.concat(n),n[n.length-1].ctr})),p=null,d=[],m=e.get(t.subject)||r.get(t.subject)||!!(t.subject instanceof f.default&&r.has(t.subject.fun))&&(p=t.subject.args,r.get(t.subject.fun))||((w=t.subject)instanceof l.default&&w.name||w instanceof f.default&&"name"in w.fun&&w.fun.name?t.subject:(d=getTree(t.subject,e,r))[d.length-1].ctr);return[...a,...d,{_type:"E",ctr:++i,subject:m,args:p,leftargs:s,reduced:t.reduced}]}if(t instanceof f.default){if(e.has(t.fun))return[{_type:"RC",ctr:++i,schema:e.get(t.fun),args:t.args,expr:t}];if(r.has(t.fun))return[{_type:"RC",ctr:++i,schema:r.get(t.fun),args:t.args,expr:t}];if(t.fun.isSchema&&t.fun.name)return[{_type:"RCX",ctr:++i,expr:t}];if(!t.fun.isSchema)return[{_type:"NP",ctr:++i,expr:t}];var g=getTree(t.fun,e,r);return[...g,{_type:"RC",ctr:++i,schema:g[g.length-1].ctr,args:t.args,expr:t}]}if(t instanceof c.default)return[{_type:"NP",ctr:++i,expr:t}];if(t instanceof l.default){if(t.isSchema&&t.name&&t!=n)return[{_type:"RS",ctr:++i,expr:t}];if(!t.expr)return[{_type:"NP",ctr:++i,expr:t}];r=new Map(r);var y=i+1,_=[];return t.def$s.forEach((t=>{var n=getTree(t.expr,e,r);_=_.concat(n);var a=n[n.length-1].ctr;r.set(t,a)})),[{_type:"V",$lines:_,lines:getTree(t.expr,e,r),params:t.params.slice(),ctr:[y,i]}]}if(t instanceof u.default){e=new Map(e);var x=[];y=i+1;t.left.forEach((t=>{e.set(t,++i),x.push({_type:"H",ctr:i,expr:t})})),r=new Map(r);_=[];return t.def$s.forEach((t=>{var n=getTree(t.expr,e,r);_=_.concat(n);var a=n[n.length-1].ctr;r.set(t,a)})),[{_type:"T",leftlines:x,$lines:_,rightlines:getTree(t.right,e,r),ctr:[y,i]}]}if(t instanceof h.default){if(!r.has(t))throw Error(t.name+" is not defined");return[{_type:"R",ctr:++i,num:r.get(t),expr:t.expr}]}return console.log("Unknown metaexpr",t),[{_type:"?",ctr:++i,expr:t}];var w}(n,new Map,new Map),d='<table class="explorer">';return d+=`<tr><th>#</th><th colspan="${a}">expr</th><th colspan="2">rule</th></tr>`,d+=function tree2html(t,e){return t.map((t=>{switch(t._type){case"V":return tree2html(t.$lines,e.concat([t.params]))+tree2html(t.lines,e.concat([t.params]));case"T":var n=e.concat([[]]),a="";if(0==t.leftlines.length)a+=getHtmlLine("",Array(e.length+1).fill([]),"","",{bbb:!0,rrb:!0});else a+=t.leftlines.map(((t,e,r)=>getHtmlLine(t.ctr,n,exprToHtml(t.expr,!0),"assumption",{bbb:e==r.length-1,rrb:!0}))).join("");return a+=tree2html(t.$lines,n),a+=tree2html(t.rightlines,n);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,`${exprToHtml(t.schema)} (${t.args.map((t=>exprToHtml(t))).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)}${t.args?" ("+t.args.map((t=>exprToHtml(t))).join(", ")+")":""} [${t.leftargs.map((t=>exprToHtml(t))).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');default:return getHtmlLine(t.ctr,e,"Unknown type "+t._type,"")}})).join("")}(p[0].$lines.concat(p[0].lines),[]),d+="</table>"}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(1),a=r(2),i=r(3),s=r(14),o=r(4);class Scope{constructor(t,e){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.parent=t,this.root=t?t.root:this,e&&!(e instanceof s.default))throw Error("Assertion failed");this.trace=e||new s.default,this.baseType=t?t.baseType:null}extend(t,e,r){var n=new Scope(this,this.trace.extend(t,e,r));return this.hypotheses.forEach((t=>n.hypotheses.push(t))),n}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnType(t)));if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasOwnType(t))).every((t=>t))}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasType(t))).every((t=>t))}addType(t){if(!(t instanceof n.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)||[...this.importMap.values()].filter((e=>e.hasType(t)))[0].getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map((t=>this.getType(t))),r=this.getType(t[t.length-1]);return new n.default({functional:!0,from:e,to:r})}hasOwnVariable(t){return this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnVariable(t)))}hasVariable(t){return this.hasOwnVariable(t)||!!this.parent&&this.parent.hasVariable(t)}addVariable(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getVariable(t){if(!this.hasVariable(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getVariable(t)||[...this.importMap.values()].filter((e=>e.hasVariable(t)))[0].getVariable(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnSchema(t)))}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)||[...this.importMap.values()].filter((e=>e.hasSchema(t)))[0].getSchema(t)}hasOwn$(t){return this.$Map.has(t)||[...this.importMap.values()].some((e=>e.hasOwn$(t)))}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$var ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$var ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)||[...this.importMap.values()].filter((e=>e.has$(t)))[0].get$(t)}}e.default=Scope},function(t,e,r){"use strict";(function(t){Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t){this.stack=t||[]}extend(t,e,r){return new StackTrace([[t,e,r]].concat(this.stack))}error(e){var r=void 0!==t&&t.argv[2];return new Error(e+"\n\tat "+(this.stack.length?this.stack.map((([t,e,n])=>`${t} ${e||"<anonymous>"} (${r||"<unknown>"}:${n.start.line}:${n.start.column})`)).join("\n\tat "):`<root> (${r||"<unknown>"}:1:1)`))}}e.default=StackTrace}).call(this,r(15))},function(t,e){var r,n,a=t.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(t){if(r===setTimeout)return setTimeout(t,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){n=defaultClearTimeout}}();var i,s=[],o=!1,l=-1;function cleanUpNextTick(){o&&i&&(o=!1,i.length?s=i.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!o){var t=runTimeout(cleanUpNextTick);o=!0;for(var e=s.length;e;){for(i=s,s=[];++l<e;)i&&i[l].run();l=-1,e=s.length}i=null,o=!1,function runClearTimeout(t){if(n===clearTimeout)return clearTimeout(t);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{return n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];s.push(new Item(t,e)),1!==s.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(t){return[]},a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(1),a=r(2),i=r(7),s=r(3),o=r(6),l=r(9),u=r(4);function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var r=e.extend("type",t.name,t.location),a=t.origin?r.getType(typeObjToNestedArr(t.origin)):null,i=t.name,s=t.doc,o=t.base;if(o&&a)throw r.error("Base type should not be an alias");return a?new n.default({name:i,doc:s,base:o,origin:a}):new n.default({functional:!1,name:i,doc:s,base:o})}static variable(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var r=e.extend("variable",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw r.error(`Variable type ${t.type} not allowed`);if(!r.hasVariable(t.name))throw r.error("Undefined identifier "+t.name);return r.getVariable(t.name)}if(!r.hasType(typeObjToNestedArr(t.type)))throw r.error(`Type ${typeObjToString(t.type)} is not defined`);var n=r.getType(typeObjToNestedArr(t.type));return new a.default({type:n,isParam:!!t.isParam,guess:t.guess||null,name:t.name,doc:t.doc,tex:t.tex},r)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var r=null,a=null,i=null;"defun"==t._type&&(r=(t=t).name,a=t.doc,i=t.tex);var o=e.extend("fun",r,t.location),l=null,u=t.params.map((t=>{if(!o.hasType(typeObjToNestedArr(t.type)))throw o.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,o);if(o.hasOwnVariable(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return o.addVariable(e)})),f=null;switch(t._type){case"defun":if(!o.hasType(typeObjToNestedArr(t.rettype)))throw o.error(`Type ${typeObjToString(t.rettype)} is not defined`);var c=o.getType(typeObjToNestedArr(t.rettype));if(t.expr){if(f=PI.expr0(t.expr,o),!c.equals(f.type))throw o.error(`Expression type ${f.type} failed to match the return type ${c} of fun ${r}`)}else l=new n.default({functional:!0,from:u.map((t=>t.type)),to:c});break;case"funexpr":f=PI.expr0(t.expr,o),l=null;break;default:throw Error("wut")}return new s.default({isSchema:!1,annotations:[],name:r,type:l,params:u,expr:f,doc:a,tex:i},o)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var r=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),n=PI.expr0(t.schema,r),a=t.args.map((t=>PI.expr0(t,r)));return new o.default({fun:n,args:a},r)}static metaexpr(t,e){if(!["tee","reduction","schemacall","schemaexpr","var"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r);case"reduction":return PI.reduction(t,r);case"schemacall":return PI.schemacall(t,r);case"schemaexpr":return PI.schema(t,r);case"var":return PI.metavar(t,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var r=e;switch(t._type){case"funcall":return PI.funcall(t,r);case"funexpr":return PI.fun(t,r);case"var":return PI.variable(t,r);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var r=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var n=Number(t.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query @"+t.name);case"$":if(!r.has$(t.name))throw r.error(t.name+" is not defined");return r.get$(t.name);case"normal":if(!r.hasSchema(t.name))throw r.error(`Schema ${t.name} is not defined`);return r.getSchema(t.name);default:throw r.error("Unknown type "+t.type)}}static tee(t,e){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),n=t.left.map((t=>PI.metaexpr(t,r))),a=r.extend("tee.right",null,t.right.location);n.forEach((t=>a.hypotheses.push(t)));var s=t.def$s.map((t=>{var e=PI.def$(t,a);if(a.hasOwn$(e.name))throw a.error(t.name+" has already been declared");return a.add$(e)})),o=PI.metaexpr(t.right,a);return new i.default({left:n,def$s:s,right:o},r)}static def$(t,e){if("def$"!=t._type)throw Error("Assertion failed");var r=e.extend("def$",t.name,t.location),n=PI.metaexpr(t.expr,r);return new u.default({name:t.name,expr:n},r)}static schema(t,e){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");var r=null,n=!1,a=null,i=[];"defschema"==t._type&&(r=t.name,n=t.axiomatic,a=t.doc,i=t.annotations);var o=e.extend("schema",r,t.location),l=t.params.map((t=>{if(!o.hasType(typeObjToNestedArr(t.type)))throw o.error(`Type ${typeObjToString(t.type)} is not defined`);var e=PI.variable(t,o);if(o.hasOwnVariable(e.name))throw e.scope.error(`Parameter ${e.name} has already been declared`);return o.addVariable(e)})),u=t.def$s.map((t=>{var e=PI.def$(t,o);if(o.hasOwn$(e.name))throw o.error(t.name+" has already been declared");return o.add$(e)})),f=PI.metaexpr(t.expr,o);return new s.default({isSchema:!0,doc:a,annotations:i,axiomatic:n,name:r,params:l,def$s:u,expr:f},o)}static schemacall(t,e){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),n=PI.metaexpr(t.schema,r),a=t.args.map((t=>PI.expr0(t,r)));return new o.default({fun:n,args:a},r)}static reduction(t,e){if("reduction"!=t._type)throw Error("Assertion failed");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),n=PI.metaexpr(t.subject,r),a=t.guesses?t.guesses.map((t=>t&&PI.expr0(t,r))):null,i=t.leftargs.map((t=>PI.metaexpr(t,r))),s=t.expected&&PI.metaexpr(t.expected,r);return new l.default({subject:n,guesses:a,leftargs:i,expected:s},r)}}e.default=PI}])}));
//# sourceMappingURL=math.min.js.map