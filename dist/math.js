var math =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/parser.js":
/*!************************!*\
  !*** ./dist/parser.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = function(a) {return a},\n      peg$c1 = function(lines) {return lines},\n      peg$c2 = \"base\",\n      peg$c3 = peg$literalExpectation(\"base\", false),\n      peg$c4 = \"type\",\n      peg$c5 = peg$literalExpectation(\"type\", false),\n      peg$c6 = function(doc, base, o) {return o},\n      peg$c7 = function(doc, base, origin, name) {\r\n      \t\tdoc = doc && doc[0];\r\n      \t\t\r\n      \t\treturn {\r\n      \t\t\t_type: 'typedef',\r\n      \t\t\tdoc,\r\n      \t\t\tbase: !!base,\r\n      \t\t\torigin,\r\n      \t\t\tname,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c8 = function(doc, tex, type, name) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defv',\r\n      \t\t\tdoc: doc && doc[0],\r\n      \t\t\ttex: tex && tex[0],\r\n      \t\t\ttype,\r\n      \t\t\tname,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c9 = function(tex, type, name) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defv',\r\n      \t\t\tisParam: true,\r\n      \t\t\ttype,\r\n      \t\t\ttex: tex && tex[0],\r\n      \t\t\tname,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c10 = \":\",\n      peg$c11 = peg$literalExpectation(\":\", false),\n      peg$c12 = \"@\",\n      peg$c13 = peg$literalExpectation(\"@\", false),\n      peg$c14 = /^[a-z0-9_]/,\n      peg$c15 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\"], false, false),\n      peg$c16 = function(tex, type, name, g) {return g},\n      peg$c17 = function(tex, type, name, guess) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defv',\r\n      \t\t\tisParam: true,\r\n      \t\t\tguess,\r\n      \t\t\ttype,\r\n      \t\t\ttex: tex && tex[0],\r\n      \t\t\tname,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c18 = \"(\",\n      peg$c19 = peg$literalExpectation(\"(\", false),\n      peg$c20 = \",\",\n      peg$c21 = peg$literalExpectation(\",\", false),\n      peg$c22 = function(doc, tex, rettype, name, head, tv) {return tv},\n      peg$c23 = function(doc, tex, rettype, name, head, tail) {return [head].concat(tail)},\n      peg$c24 = \")\",\n      peg$c25 = peg$literalExpectation(\")\", false),\n      peg$c26 = function(doc, tex, rettype, name, p) {return p || []},\n      peg$c27 = \"{\",\n      peg$c28 = peg$literalExpectation(\"{\", false),\n      peg$c29 = \"}\",\n      peg$c30 = peg$literalExpectation(\"}\", false),\n      peg$c31 = function(doc, tex, rettype, name, params, expr) {return expr},\n      peg$c32 = function(doc, tex, rettype, name, params) {return null},\n      peg$c33 = function(doc, tex, rettype, name, params, expr) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defun',\r\n      \t\t\tdoc: doc && doc[0],\r\n      \t\t\ttex: tex && tex[0],\r\n      \t\t\trettype,\r\n      \t\t\tname,\r\n      \t\t\tparams,\r\n      \t\t\texpr,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c34 = \"axiomatic\",\n      peg$c35 = peg$literalExpectation(\"axiomatic\", false),\n      peg$c36 = \"native\",\n      peg$c37 = peg$literalExpectation(\"native\", false),\n      peg$c38 = \"schema\",\n      peg$c39 = peg$literalExpectation(\"schema\", false),\n      peg$c40 = function(doc, axiomatic, name) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defschema',\r\n      \t\t\tdoc: doc && doc[0],\r\n      \t\t\taxiomatic: !!axiomatic,\r\n      \t\t\tname,\r\n      \t\t\tnative: true,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c41 = function(doc, axiomatic, name, head, tv) {return tv},\n      peg$c42 = function(doc, axiomatic, name, head, tail) {return [head].concat(tail)},\n      peg$c43 = function(doc, axiomatic, name, p) {return p || []},\n      peg$c44 = function(doc, axiomatic, name, params, expr) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defschema',\r\n      \t\t\tdoc: doc && doc[0],\r\n      \t\t\taxiomatic: !!axiomatic,\r\n      \t\t\tname,\r\n      \t\t\tnative: false,\r\n      \t\t\tparams,\r\n      \t\t\texpr,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c45 = \"ruleset\",\n      peg$c46 = peg$literalExpectation(\"ruleset\", false),\n      peg$c47 = function(doc, axiomatic, name) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'defruleset',\r\n      \t\t\tdoc: doc && doc[0],\r\n      \t\t\taxiomatic: !!axiomatic,\r\n      \t\t\tname,\r\n      \t\t\tnative: true,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c48 = function(e) {return e},\n      peg$c49 = \"?\",\n      peg$c50 = peg$literalExpectation(\"?\", false),\n      peg$c51 = function(subject) {return null},\n      peg$c52 = function(subject, head) {return null},\n      peg$c53 = function(subject, head, e) {return e},\n      peg$c54 = function(subject, head, tail) {return [head].concat(tail)},\n      peg$c55 = function(subject, a) {return a || []},\n      peg$c56 = \"[\",\n      peg$c57 = peg$literalExpectation(\"[\", false),\n      peg$c58 = function(subject, guesses, head, e) {return e},\n      peg$c59 = function(subject, guesses, head, tail) {return [head].concat(tail)},\n      peg$c60 = \"]\",\n      peg$c61 = peg$literalExpectation(\"]\", false),\n      peg$c62 = function(subject, guesses, a) {return a || []},\n      peg$c63 = function(subject, guesses, leftargs) {\r\n      \t\tvar ret = {\r\n      \t\t\t_type: 'reduction',\r\n      \t\t\tsubject,\r\n      \t\t\tguesses,\r\n      \t\t\tleftargs: leftargs[0],\r\n      \t\t\tlocation: location()\r\n      \t\t};\r\n\r\n      \t\tfor (var i = 1; i < leftargs.length; i++) {\r\n      \t\t\tret = {\r\n      \t\t\t\t_type: 'reduction',\r\n      \t\t\t\tsubject: ret,\r\n      \t\t\t\tguesses: null,\r\n      \t\t\t\tleftargs: leftargs[i],\r\n      \t\t\t\tlocation: location()\r\n      \t\t\t};\r\n      \t\t}\r\n\r\n      \t\treturn ret;\r\n      \t},\n      peg$c64 = function(schema, head, e) {return e},\n      peg$c65 = function(schema, head, tail) {return [head].concat(tail)},\n      peg$c66 = function(schema, a) {return a || []},\n      peg$c67 = function(schema, args) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'schemacall',\r\n      \t\t\tschema,\r\n      \t\t\targs,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c68 = function(fun, head, e) {return e},\n      peg$c69 = function(fun, head, tail) {return [head].concat(tail)},\n      peg$c70 = function(fun, a) {return a || []},\n      peg$c71 = function(fun, args) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'funcall',\r\n      \t\t\tfun,\r\n      \t\t\targs,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c72 = function(head, tv) {return tv},\n      peg$c73 = function(head, tail) {return [head].concat(tail)},\n      peg$c74 = function(p) {return p || []},\n      peg$c75 = \"=>\",\n      peg$c76 = peg$literalExpectation(\"=>\", false),\n      peg$c77 = function(params, expr) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'funexpr',\r\n      \t\t\tparams,\r\n      \t\t\texpr,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c78 = function(params, expr) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'schemaexpr',\r\n      \t\t\tdoc: false,\r\n      \t\t\taxiomatic: true,\r\n      \t\t\tname: null,\r\n      \t\t\tparams,\r\n      \t\t\texpr,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c79 = \"~\",\n      peg$c80 = peg$literalExpectation(\"~\", false),\n      peg$c81 = function(a, b) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'reduction',\r\n      \t\t\tsubject: {\r\n      \t\t\t\t_type: 'var',\r\n      \t\t\t\ttype: 'normal',\r\n      \t\t\t\tname: 'cut'\r\n      \t\t\t},\r\n      \t\t\tleftargs: [a, b],\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c82 = function(head, e) {return e},\n      peg$c83 = function(l) {return l || []},\n      peg$c84 = \"|-\",\n      peg$c85 = peg$literalExpectation(\"|-\", false),\n      peg$c86 = function(left, right) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'tee',\r\n      \t\t\tleft,\r\n      \t\t\tright,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c87 = function(name) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'type',\r\n      \t\t\tftype: false,\r\n      \t\t\tname,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c88 = function(type) {return [type]},\n      peg$c89 = function(head, t) {return t},\n      peg$c90 = function(tt) {return tt},\n      peg$c91 = \"->\",\n      peg$c92 = peg$literalExpectation(\"->\", false),\n      peg$c93 = function(from, to) {\r\n      \t\treturn {\r\n      \t\t\t_type: 'type',\r\n      \t\t\tftype: true,\r\n      \t\t\tfrom,\r\n      \t\t\tto,\r\n      \t\t\tlocation: location()\r\n      \t\t}\r\n      \t},\n      peg$c94 = \".\",\n      peg$c95 = peg$literalExpectation(\".\", false),\n      peg$c96 = function(id) {return id},\n      peg$c97 = function(rulesetName, name) {\r\n      \t\treturn rulesetName\r\n      \t\t\t? {\r\n      \t\t\t\t_type: 'var',\r\n      \t\t\t\ttype: 'ruleset',\r\n      \t\t\t\trulesetName,\r\n      \t\t\t\tname\r\n      \t\t\t}\r\n      \t\t\t: {\r\n      \t\t\t\t_type: 'var',\r\n      \t\t\t\ttype: 'normal',\r\n      \t\t\t\tname\r\n      \t\t\t}\r\n      \t},\n      peg$c98 = /^[a-zA-Z0-9_]/,\n      peg$c99 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false),\n      peg$c100 = \"\\\"\",\n      peg$c101 = peg$literalExpectation(\"\\\"\", false),\n      peg$c102 = peg$anyExpectation(),\n      peg$c103 = function(b) {\r\n      \t\treturn b.join('')\r\n      \t},\n      peg$c104 = \"$\",\n      peg$c105 = peg$literalExpectation(\"$\", false),\n      peg$c106 = function(b) {\r\n      \t\treturn b\r\n      \t},\n      peg$c107 = \"#\",\n      peg$c108 = peg$literalExpectation(\"#\", false),\n      peg$c109 = \"//\",\n      peg$c110 = peg$literalExpectation(\"//\", false),\n      peg$c111 = \"/*\",\n      peg$c112 = peg$literalExpectation(\"/*\", false),\n      peg$c113 = \"*/\",\n      peg$c114 = peg$literalExpectation(\"*/\", false),\n      peg$c115 = \"\\r\\n\",\n      peg$c116 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c117 = \"\\r\",\n      peg$c118 = peg$literalExpectation(\"\\r\", false),\n      peg$c119 = \"\\n\",\n      peg$c120 = peg$literalExpectation(\"\\n\", false),\n      peg$c121 = /^[ \\t\\n\\r]/,\n      peg$c122 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n      peg$c123 = \";\",\n      peg$c124 = peg$literalExpectation(\";\", false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$resultsCache = {},\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 0,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parseline();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse_();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c0(s4);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parseline();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c0(s4);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseline() {\n    var s0;\n\n    var key    = peg$currPos * 31 + 1,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsetypedef();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsedefv();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsedefun();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsedefruleset();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsedefschema();\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetypedef() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var key    = peg$currPos * 31 + 2,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedocumentation();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c2) {\n        s3 = peg$c2;\n        peg$currPos += 4;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c4) {\n          s3 = peg$c4;\n          peg$currPos += 4;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = peg$parseftype();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parse__();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s6 = peg$c6(s1, s2, s6);\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseident();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesem();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c7(s1, s2, s5, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefv() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key    = peg$currPos * 31 + 3,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedocumentation();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parsetex();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetype();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseident();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsesem();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c8(s1, s2, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefparam() {\n    var s0, s1, s2, s3, s4;\n\n    var key    = peg$currPos * 31 + 4,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsetex();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetype();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseident();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9(s1, s2, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefschemaparam() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    var key    = peg$currPos * 31 + 5,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsetex();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetype();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseident();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s7 = peg$c10;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c11); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_();\n                if (s8 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 64) {\n                    s9 = peg$c12;\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$currPos;\n                    s11 = [];\n                    if (peg$c14.test(input.charAt(peg$currPos))) {\n                      s12 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s12 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n                    }\n                    if (s12 !== peg$FAILED) {\n                      while (s12 !== peg$FAILED) {\n                        s11.push(s12);\n                        if (peg$c14.test(input.charAt(peg$currPos))) {\n                          s12 = input.charAt(peg$currPos);\n                          peg$currPos++;\n                        } else {\n                          s12 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n                        }\n                      }\n                    } else {\n                      s11 = peg$FAILED;\n                    }\n                    if (s11 !== peg$FAILED) {\n                      s10 = input.substring(s10, peg$currPos);\n                    } else {\n                      s10 = s11;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s5;\n                      s6 = peg$c16(s1, s2, s4, s10);\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c17(s1, s2, s4, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefun() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18;\n\n    var key    = peg$currPos * 31 + 6,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedocumentation();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parsetex();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetype();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseident();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 40) {\n                  s8 = peg$c18;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$currPos;\n                    s11 = peg$parsedefparam();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parse_();\n                      if (s12 !== peg$FAILED) {\n                        s13 = [];\n                        s14 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 44) {\n                          s15 = peg$c20;\n                          peg$currPos++;\n                        } else {\n                          s15 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                        }\n                        if (s15 !== peg$FAILED) {\n                          s16 = peg$parse_();\n                          if (s16 !== peg$FAILED) {\n                            s17 = peg$parsedefparam();\n                            if (s17 !== peg$FAILED) {\n                              s18 = peg$parse_();\n                              if (s18 !== peg$FAILED) {\n                                peg$savedPos = s14;\n                                s15 = peg$c22(s1, s2, s3, s5, s11, s17);\n                                s14 = s15;\n                              } else {\n                                peg$currPos = s14;\n                                s14 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s14;\n                              s14 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s14;\n                            s14 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s14;\n                          s14 = peg$FAILED;\n                        }\n                        while (s14 !== peg$FAILED) {\n                          s13.push(s14);\n                          s14 = peg$currPos;\n                          if (input.charCodeAt(peg$currPos) === 44) {\n                            s15 = peg$c20;\n                            peg$currPos++;\n                          } else {\n                            s15 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                          }\n                          if (s15 !== peg$FAILED) {\n                            s16 = peg$parse_();\n                            if (s16 !== peg$FAILED) {\n                              s17 = peg$parsedefparam();\n                              if (s17 !== peg$FAILED) {\n                                s18 = peg$parse_();\n                                if (s18 !== peg$FAILED) {\n                                  peg$savedPos = s14;\n                                  s15 = peg$c22(s1, s2, s3, s5, s11, s17);\n                                  s14 = s15;\n                                } else {\n                                  peg$currPos = s14;\n                                  s14 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s14;\n                                s14 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s14;\n                              s14 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s14;\n                            s14 = peg$FAILED;\n                          }\n                        }\n                        if (s13 !== peg$FAILED) {\n                          peg$savedPos = s10;\n                          s11 = peg$c23(s1, s2, s3, s5, s11, s13);\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                    if (s10 === peg$FAILED) {\n                      s10 = null;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 41) {\n                        s11 = peg$c24;\n                        peg$currPos++;\n                      } else {\n                        s11 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                      }\n                      if (s11 !== peg$FAILED) {\n                        s12 = peg$parse_();\n                        if (s12 !== peg$FAILED) {\n                          peg$savedPos = s7;\n                          s8 = peg$c26(s1, s2, s3, s5, s10);\n                          s7 = s8;\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 123) {\n                    s9 = peg$c27;\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c28); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse_();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseexpr0();\n                      if (s11 !== peg$FAILED) {\n                        s12 = peg$parse_();\n                        if (s12 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 125) {\n                            s13 = peg$c29;\n                            peg$currPos++;\n                          } else {\n                            s13 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                          }\n                          if (s13 !== peg$FAILED) {\n                            peg$savedPos = s8;\n                            s9 = peg$c31(s1, s2, s3, s5, s7, s11);\n                            s8 = s9;\n                          } else {\n                            peg$currPos = s8;\n                            s8 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s8;\n                          s8 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                  if (s8 === peg$FAILED) {\n                    s8 = peg$currPos;\n                    s9 = peg$parsesem();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s8;\n                      s9 = peg$c32(s1, s2, s3, s5, s7);\n                    }\n                    s8 = s9;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c33(s1, s2, s3, s5, s7, s8);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefschema() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18;\n\n    var key    = peg$currPos * 31 + 7,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedocumentation();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c34) {\n        s3 = peg$c34;\n        peg$currPos += 9;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c36) {\n          s3 = peg$c36;\n          peg$currPos += 6;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c38) {\n              s5 = peg$c38;\n              peg$currPos += 6;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseident();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsesem();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c40(s1, s2, s7);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsedocumentation();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.substr(peg$currPos, 9) === peg$c34) {\n          s3 = peg$c34;\n          peg$currPos += 9;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c35); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 6) === peg$c38) {\n            s3 = peg$c38;\n            peg$currPos += 6;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseident();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 40) {\n                    s8 = peg$c18;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$currPos;\n                      s11 = peg$parsedefschemaparam();\n                      if (s11 !== peg$FAILED) {\n                        s12 = peg$parse_();\n                        if (s12 !== peg$FAILED) {\n                          s13 = [];\n                          s14 = peg$currPos;\n                          if (input.charCodeAt(peg$currPos) === 44) {\n                            s15 = peg$c20;\n                            peg$currPos++;\n                          } else {\n                            s15 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                          }\n                          if (s15 !== peg$FAILED) {\n                            s16 = peg$parse_();\n                            if (s16 !== peg$FAILED) {\n                              s17 = peg$parsedefschemaparam();\n                              if (s17 !== peg$FAILED) {\n                                s18 = peg$parse_();\n                                if (s18 !== peg$FAILED) {\n                                  peg$savedPos = s14;\n                                  s15 = peg$c41(s1, s2, s5, s11, s17);\n                                  s14 = s15;\n                                } else {\n                                  peg$currPos = s14;\n                                  s14 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s14;\n                                s14 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s14;\n                              s14 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s14;\n                            s14 = peg$FAILED;\n                          }\n                          while (s14 !== peg$FAILED) {\n                            s13.push(s14);\n                            s14 = peg$currPos;\n                            if (input.charCodeAt(peg$currPos) === 44) {\n                              s15 = peg$c20;\n                              peg$currPos++;\n                            } else {\n                              s15 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                            }\n                            if (s15 !== peg$FAILED) {\n                              s16 = peg$parse_();\n                              if (s16 !== peg$FAILED) {\n                                s17 = peg$parsedefschemaparam();\n                                if (s17 !== peg$FAILED) {\n                                  s18 = peg$parse_();\n                                  if (s18 !== peg$FAILED) {\n                                    peg$savedPos = s14;\n                                    s15 = peg$c41(s1, s2, s5, s11, s17);\n                                    s14 = s15;\n                                  } else {\n                                    peg$currPos = s14;\n                                    s14 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s14;\n                                  s14 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s14;\n                                s14 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s14;\n                              s14 = peg$FAILED;\n                            }\n                          }\n                          if (s13 !== peg$FAILED) {\n                            peg$savedPos = s10;\n                            s11 = peg$c42(s1, s2, s5, s11, s13);\n                            s10 = s11;\n                          } else {\n                            peg$currPos = s10;\n                            s10 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s11 = peg$c24;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parse_();\n                          if (s12 !== peg$FAILED) {\n                            peg$savedPos = s7;\n                            s8 = peg$c43(s1, s2, s5, s10);\n                            s7 = s8;\n                          } else {\n                            peg$currPos = s7;\n                            s7 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 123) {\n                      s8 = peg$c27;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c28); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parse_();\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parsemetaexpr();\n                        if (s10 !== peg$FAILED) {\n                          s11 = peg$parse_();\n                          if (s11 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 125) {\n                              s12 = peg$c29;\n                              peg$currPos++;\n                            } else {\n                              s12 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                            }\n                            if (s12 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$c44(s1, s2, s5, s7, s10);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedefruleset() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    var key    = peg$currPos * 31 + 8,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedocumentation();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c34) {\n        s3 = peg$c34;\n        peg$currPos += 9;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c36) {\n          s3 = peg$c36;\n          peg$currPos += 6;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 7) === peg$c45) {\n              s5 = peg$c45;\n              peg$currPos += 7;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c46); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseident();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsesem();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c47(s1, s2, s7);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsereduction() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;\n\n    var key    = peg$currPos * 31 + 9,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseschemacall();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsevar();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c18;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsemetaexpr();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c24;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c48(s4);\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s4 = peg$c18;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 63) {\n              s8 = peg$c49;\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c50); }\n            }\n            if (s8 !== peg$FAILED) {\n              peg$savedPos = s7;\n              s8 = peg$c51(s1);\n            }\n            s7 = s8;\n            if (s7 === peg$FAILED) {\n              s7 = peg$parseexpr0();\n            }\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parse_();\n              if (s8 !== peg$FAILED) {\n                s9 = [];\n                s10 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s11 = peg$c20;\n                  peg$currPos++;\n                } else {\n                  s11 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                }\n                if (s11 !== peg$FAILED) {\n                  s12 = peg$parse_();\n                  if (s12 !== peg$FAILED) {\n                    s13 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 63) {\n                      s14 = peg$c49;\n                      peg$currPos++;\n                    } else {\n                      s14 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s14 !== peg$FAILED) {\n                      peg$savedPos = s13;\n                      s14 = peg$c52(s1, s7);\n                    }\n                    s13 = s14;\n                    if (s13 === peg$FAILED) {\n                      s13 = peg$parseexpr0();\n                    }\n                    if (s13 !== peg$FAILED) {\n                      s14 = peg$parse_();\n                      if (s14 !== peg$FAILED) {\n                        peg$savedPos = s10;\n                        s11 = peg$c53(s1, s7, s13);\n                        s10 = s11;\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s10;\n                  s10 = peg$FAILED;\n                }\n                while (s10 !== peg$FAILED) {\n                  s9.push(s10);\n                  s10 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s11 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s11 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$currPos;\n                      if (input.charCodeAt(peg$currPos) === 63) {\n                        s14 = peg$c49;\n                        peg$currPos++;\n                      } else {\n                        s14 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                      }\n                      if (s14 !== peg$FAILED) {\n                        peg$savedPos = s13;\n                        s14 = peg$c52(s1, s7);\n                      }\n                      s13 = s14;\n                      if (s13 === peg$FAILED) {\n                        s13 = peg$parseexpr0();\n                      }\n                      if (s13 !== peg$FAILED) {\n                        s14 = peg$parse_();\n                        if (s14 !== peg$FAILED) {\n                          peg$savedPos = s10;\n                          s11 = peg$c53(s1, s7, s13);\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                }\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s7 = peg$c54(s1, s7, s9);\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 === peg$FAILED) {\n              s6 = null;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s7 = peg$c24;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c55(s1, s6);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s6 = peg$c56;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c57); }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parse_();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$currPos;\n              s9 = peg$parsemetaexpr();\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parse_();\n                if (s10 !== peg$FAILED) {\n                  s11 = [];\n                  s12 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s13 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s13 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                  }\n                  if (s13 !== peg$FAILED) {\n                    s14 = peg$parse_();\n                    if (s14 !== peg$FAILED) {\n                      s15 = peg$parsemetaexpr();\n                      if (s15 !== peg$FAILED) {\n                        s16 = peg$parse_();\n                        if (s16 !== peg$FAILED) {\n                          peg$savedPos = s12;\n                          s13 = peg$c58(s1, s3, s9, s15);\n                          s12 = s13;\n                        } else {\n                          peg$currPos = s12;\n                          s12 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s12;\n                        s12 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s12;\n                      s12 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s12;\n                    s12 = peg$FAILED;\n                  }\n                  while (s12 !== peg$FAILED) {\n                    s11.push(s12);\n                    s12 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s13 = peg$c20;\n                      peg$currPos++;\n                    } else {\n                      s13 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                    }\n                    if (s13 !== peg$FAILED) {\n                      s14 = peg$parse_();\n                      if (s14 !== peg$FAILED) {\n                        s15 = peg$parsemetaexpr();\n                        if (s15 !== peg$FAILED) {\n                          s16 = peg$parse_();\n                          if (s16 !== peg$FAILED) {\n                            peg$savedPos = s12;\n                            s13 = peg$c58(s1, s3, s9, s15);\n                            s12 = s13;\n                          } else {\n                            peg$currPos = s12;\n                            s12 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s12;\n                          s12 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s12;\n                        s12 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s12;\n                      s12 = peg$FAILED;\n                    }\n                  }\n                  if (s11 !== peg$FAILED) {\n                    peg$savedPos = s8;\n                    s9 = peg$c59(s1, s3, s9, s11);\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 === peg$FAILED) {\n                s8 = null;\n              }\n              if (s8 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 93) {\n                  s9 = peg$c60;\n                  peg$currPos++;\n                } else {\n                  s9 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c61); }\n                }\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s6 = peg$c62(s1, s3, s8);\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 91) {\n                s6 = peg$c56;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c57); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$currPos;\n                  s9 = peg$parsemetaexpr();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse_();\n                    if (s10 !== peg$FAILED) {\n                      s11 = [];\n                      s12 = peg$currPos;\n                      if (input.charCodeAt(peg$currPos) === 44) {\n                        s13 = peg$c20;\n                        peg$currPos++;\n                      } else {\n                        s13 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                      }\n                      if (s13 !== peg$FAILED) {\n                        s14 = peg$parse_();\n                        if (s14 !== peg$FAILED) {\n                          s15 = peg$parsemetaexpr();\n                          if (s15 !== peg$FAILED) {\n                            s16 = peg$parse_();\n                            if (s16 !== peg$FAILED) {\n                              peg$savedPos = s12;\n                              s13 = peg$c58(s1, s3, s9, s15);\n                              s12 = s13;\n                            } else {\n                              peg$currPos = s12;\n                              s12 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s12;\n                            s12 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s12;\n                          s12 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s12;\n                        s12 = peg$FAILED;\n                      }\n                      while (s12 !== peg$FAILED) {\n                        s11.push(s12);\n                        s12 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 44) {\n                          s13 = peg$c20;\n                          peg$currPos++;\n                        } else {\n                          s13 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                        }\n                        if (s13 !== peg$FAILED) {\n                          s14 = peg$parse_();\n                          if (s14 !== peg$FAILED) {\n                            s15 = peg$parsemetaexpr();\n                            if (s15 !== peg$FAILED) {\n                              s16 = peg$parse_();\n                              if (s16 !== peg$FAILED) {\n                                peg$savedPos = s12;\n                                s13 = peg$c58(s1, s3, s9, s15);\n                                s12 = s13;\n                              } else {\n                                peg$currPos = s12;\n                                s12 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s12;\n                              s12 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s12;\n                            s12 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s12;\n                          s12 = peg$FAILED;\n                        }\n                      }\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s8;\n                        s9 = peg$c59(s1, s3, s9, s11);\n                        s8 = s9;\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c60;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s5;\n                      s6 = peg$c62(s1, s3, s8);\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c63(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseschemacall() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n\n    var key    = peg$currPos * 31 + 10,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsevar();\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c18;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsemetaexpr();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s6 = peg$c24;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c48(s4);\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s4 = peg$c18;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            s7 = peg$parseexpr0();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parse_();\n              if (s8 !== peg$FAILED) {\n                s9 = [];\n                s10 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s11 = peg$c20;\n                  peg$currPos++;\n                } else {\n                  s11 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                }\n                if (s11 !== peg$FAILED) {\n                  s12 = peg$parse_();\n                  if (s12 !== peg$FAILED) {\n                    s13 = peg$parseexpr0();\n                    if (s13 !== peg$FAILED) {\n                      s14 = peg$parse_();\n                      if (s14 !== peg$FAILED) {\n                        peg$savedPos = s10;\n                        s11 = peg$c64(s1, s7, s13);\n                        s10 = s11;\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s10;\n                  s10 = peg$FAILED;\n                }\n                while (s10 !== peg$FAILED) {\n                  s9.push(s10);\n                  s10 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s11 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s11 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$parseexpr0();\n                      if (s13 !== peg$FAILED) {\n                        s14 = peg$parse_();\n                        if (s14 !== peg$FAILED) {\n                          peg$savedPos = s10;\n                          s11 = peg$c64(s1, s7, s13);\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                }\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s7 = peg$c65(s1, s7, s9);\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 === peg$FAILED) {\n              s6 = null;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s7 = peg$c24;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c66(s1, s6);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c67(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefuncall() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n\n    var key    = peg$currPos * 31 + 11,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsevar();\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c18;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseexpr0();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s6 = peg$c24;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c48(s4);\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s4 = peg$c18;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            s7 = peg$parseexpr0();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parse_();\n              if (s8 !== peg$FAILED) {\n                s9 = [];\n                s10 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s11 = peg$c20;\n                  peg$currPos++;\n                } else {\n                  s11 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                }\n                if (s11 !== peg$FAILED) {\n                  s12 = peg$parse_();\n                  if (s12 !== peg$FAILED) {\n                    s13 = peg$parseexpr0();\n                    if (s13 !== peg$FAILED) {\n                      s14 = peg$parse_();\n                      if (s14 !== peg$FAILED) {\n                        peg$savedPos = s10;\n                        s11 = peg$c68(s1, s7, s13);\n                        s10 = s11;\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s10;\n                  s10 = peg$FAILED;\n                }\n                while (s10 !== peg$FAILED) {\n                  s9.push(s10);\n                  s10 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s11 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s11 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$parseexpr0();\n                      if (s13 !== peg$FAILED) {\n                        s14 = peg$parse_();\n                        if (s14 !== peg$FAILED) {\n                          peg$savedPos = s10;\n                          s11 = peg$c68(s1, s7, s13);\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                }\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s7 = peg$c69(s1, s7, s9);\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 === peg$FAILED) {\n              s6 = null;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s7 = peg$c24;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c70(s1, s6);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c71(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefunexpr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    var key    = peg$currPos * 31 + 12,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c18;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = peg$parsedefparam();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = [];\n            s8 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s9 = peg$c20;\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s9 !== peg$FAILED) {\n              s10 = peg$parse_();\n              if (s10 !== peg$FAILED) {\n                s11 = peg$parsedefparam();\n                if (s11 !== peg$FAILED) {\n                  s12 = peg$parse_();\n                  if (s12 !== peg$FAILED) {\n                    peg$savedPos = s8;\n                    s9 = peg$c72(s5, s11);\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            while (s8 !== peg$FAILED) {\n              s7.push(s8);\n              s8 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s9 = peg$c20;\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c21); }\n              }\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parse_();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsedefparam();\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      peg$savedPos = s8;\n                      s9 = peg$c72(s5, s11);\n                      s8 = s9;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            }\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c73(s5, s7);\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s5 = peg$c24;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c25); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c74(s4);\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c75) {\n        s2 = peg$c75;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c76); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s4 = peg$c27;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseexpr0();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s8 = peg$c29;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c77(s1, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseschemaexpr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    var key    = peg$currPos * 31 + 13,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c18;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = peg$parsedefparam();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = [];\n            s8 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s9 = peg$c20;\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s9 !== peg$FAILED) {\n              s10 = peg$parse_();\n              if (s10 !== peg$FAILED) {\n                s11 = peg$parsedefparam();\n                if (s11 !== peg$FAILED) {\n                  s12 = peg$parse_();\n                  if (s12 !== peg$FAILED) {\n                    peg$savedPos = s8;\n                    s9 = peg$c72(s5, s11);\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            while (s8 !== peg$FAILED) {\n              s7.push(s8);\n              s8 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s9 = peg$c20;\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c21); }\n              }\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parse_();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsedefparam();\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      peg$savedPos = s8;\n                      s9 = peg$c72(s5, s11);\n                      s8 = s9;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            }\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c73(s5, s7);\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s5 = peg$c24;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c25); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c74(s4);\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c75) {\n        s2 = peg$c75;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c76); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s4 = peg$c27;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsemetaexpr();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s8 = peg$c29;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c78(s1, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsemetaexpr() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 14,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsemetaexpr_internal_1();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 126) {\n          s3 = peg$c79;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c80); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemetaexpr();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c81(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemetaexpr_internal_1();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsemetaexpr_internal_1() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    var key    = peg$currPos * 31 + 15,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parsemetaexpr_internal_2();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        s6 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s7 = peg$c20;\n          peg$currPos++;\n        } else {\n          s7 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s7 !== peg$FAILED) {\n          s8 = peg$parse_();\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parsemetaexpr_internal_2();\n            if (s9 !== peg$FAILED) {\n              s10 = peg$parse_();\n              if (s10 !== peg$FAILED) {\n                peg$savedPos = s6;\n                s7 = peg$c82(s3, s9);\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s7 = peg$c20;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s7 !== peg$FAILED) {\n            s8 = peg$parse_();\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parsemetaexpr_internal_2();\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parse_();\n                if (s10 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s7 = peg$c82(s3, s9);\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c73(s3, s5);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s1;\n      s2 = peg$c83(s2);\n    }\n    s1 = s2;\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c84) {\n        s2 = peg$c84;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c85); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsemetaexpr_internal_1();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c86(s1, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemetaexpr_internal_2();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsemetaexpr_internal_2() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 16,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsereduction();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseschemacall();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevar();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseschemaexpr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s1 = peg$c18;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsemetaexpr();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n                  if (s4 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s5 = peg$c24;\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                    }\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c48(s3);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseexpr0() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 17,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsefuncall();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefunexpr();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevar();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s1 = peg$c18;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c19); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseexpr0();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c24;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c48(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetype() {\n    var s0;\n\n    var key    = peg$currPos * 31 + 18,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsestype();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseftype();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestype() {\n    var s0, s1;\n\n    var key    = peg$currPos * 31 + 19,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseident();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c87(s1);\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseftype() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    var key    = peg$currPos * 31 + 20,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c56;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c57); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsetype();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c88(s4);\n        }\n        s3 = s4;\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s5 = peg$c18;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c19); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsetype();\n              if (s7 !== peg$FAILED) {\n                s8 = [];\n                s9 = peg$currPos;\n                s10 = peg$parse_();\n                if (s10 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s11 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s11 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s12 = peg$parse_();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$parsetype();\n                      if (s13 !== peg$FAILED) {\n                        peg$savedPos = s9;\n                        s10 = peg$c89(s7, s13);\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n                while (s9 !== peg$FAILED) {\n                  s8.push(s9);\n                  s9 = peg$currPos;\n                  s10 = peg$parse_();\n                  if (s10 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s11 = peg$c20;\n                      peg$currPos++;\n                    } else {\n                      s11 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                    }\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parse_();\n                      if (s12 !== peg$FAILED) {\n                        s13 = peg$parsetype();\n                        if (s13 !== peg$FAILED) {\n                          peg$savedPos = s9;\n                          s10 = peg$c89(s7, s13);\n                          s9 = s10;\n                        } else {\n                          peg$currPos = s9;\n                          s9 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s10 = peg$c24;\n                      peg$currPos++;\n                    } else {\n                      s10 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n                    }\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s4;\n                      s5 = peg$c73(s7, s8);\n                      s4 = s5;\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c90(s4);\n          }\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c91) {\n              s5 = peg$c91;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c92); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsetype();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c60;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c93(s3, s7);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsevar() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 21,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseident();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c94;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c95); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c96(s2);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseident();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c97(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsekeyword() {\n    var s0;\n\n    var key    = peg$currPos * 31 + 22,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 9) === peg$c34) {\n      s0 = peg$c34;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 4) === peg$c2) {\n        s0 = peg$c2;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c36) {\n          s0 = peg$c36;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 7) === peg$c45) {\n            s0 = peg$c45;\n            peg$currPos += 7;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c38) {\n              s0 = peg$c38;\n              peg$currPos += 6;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c4) {\n                s0 = peg$c4;\n                peg$currPos += 4;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c5); }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseident() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 23,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = peg$parsekeyword();\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = void 0;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      if (peg$c98.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c99); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$c98.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedocumentation() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 24,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c100;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c101); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s5 = peg$c100;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c101); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c102); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c0(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s5 = peg$c100;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c101); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c102); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c0(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s3 = peg$c100;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c101); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c103(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetex() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key    = peg$currPos * 31 + 25,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s1 = peg$c104;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c105); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$currPos;\n      s5 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s6 = peg$c104;\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c105); }\n      }\n      peg$silentFails--;\n      if (s6 === peg$FAILED) {\n        s5 = void 0;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c102); }\n        }\n        if (s6 !== peg$FAILED) {\n          peg$savedPos = s4;\n          s5 = peg$c0(s6);\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 36) {\n          s6 = peg$c104;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c105); }\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = void 0;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c102); }\n          }\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = s4;\n            s5 = peg$c0(s6);\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 36) {\n          s3 = peg$c104;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c105); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c106(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key    = peg$currPos * 31 + 26,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c107;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c108); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parsenewline();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c102); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenewline();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c102); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c109) {\n        s1 = peg$c109;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c110); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenewline();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c102); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsenewline();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c102); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c111) {\n          s1 = peg$c111;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c112); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c113) {\n            s5 = peg$c113;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c114); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c102); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            if (input.substr(peg$currPos, 2) === peg$c113) {\n              s5 = peg$c113;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c114); }\n            }\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c102); }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c113) {\n              s3 = peg$c113;\n              peg$currPos += 2;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c114); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s1 = [s1, s2, s3, s4];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsenewline() {\n    var s0;\n\n    var key    = peg$currPos * 31 + 27,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c115) {\n      s0 = peg$c115;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c116); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 13) {\n        s0 = peg$c117;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c118); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s0 = peg$c119;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c120); }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    var key    = peg$currPos * 31 + 28,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = [];\n    if (peg$c121.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c122); }\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsecomment();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c121.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c122); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsecomment();\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    var key    = peg$currPos * 31 + 29,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = [];\n    if (peg$c121.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c122); }\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsecomment();\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c121.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c122); }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsecomment();\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesem() {\n    var s0;\n\n    var key    = peg$currPos * 31 + 30,\n        cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s0 = peg$c123;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c124); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://math/./dist/parser.js?");

/***/ }),

/***/ "./src/ExpressionResolver.js":
/*!***********************************!*\
  !*** ./src/ExpressionResolver.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ER = {};\r\n\r\nvar Type, Typevar, Fun, Funcall, Tee, Ruleset, Schema, Schemacall;\r\n/*\r\n * 몇몇 노드가 이 모듈을 require 하므로 이 모듈이 노드들을 require 할 수 없다.\r\n * 그러므로 공통 조상이 이 모듈에 노드들을 넣어 주는 것으로 한다.\r\n * require 동작 방식의 한계라고 할 수 있다.\r\n */\r\nER.init = function (o) {\r\n\tType = o.Type;\r\n\tTypevar = o.Typevar;\r\n\tFun = o.Fun;\r\n\tFuncall = o.Funcall;\r\n\tTee = o.Tee;\r\n\tRuleset = o.Ruleset;\r\n\tSchema = o.Schema;\r\n\tSchemacall = o.Schemacall;\r\n};\r\n\r\nER.substitute = function (expr, map) {\r\n\tswitch (expr._type) {\r\n\t\tcase 'funcall':\r\n\t\t\treturn new Funcall({\r\n\t\t\t\tfun: ER.substitute(expr.fun, map),\r\n\t\t\t\targs: expr.args.map(arg => ER.substitute(arg, map))\r\n\t\t\t});\r\n\t\tcase 'fun':\r\n\t\t\tif (!expr.expr) return map.get(expr) || expr;\r\n\r\n\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\tif (expr.name) return map.get(expr) || expr;\r\n\r\n\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생한다.\r\n\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\treturn new Fun({\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ER.substitute(expr.expr, map)\r\n\t\t\t});\r\n\t\tcase 'typevar':\r\n\t\t\treturn map.get(expr) || expr;\r\n\t\tcase 'tee':\r\n\t\t\tvar left = expr.left.map(e => ER.substitute(e, map));\r\n\t\t\tvar right = ER.substitute(expr.right, map);\r\n\r\n\t\t\treturn new Tee({\r\n\t\t\t\tleft, right\r\n\t\t\t});\r\n\t\tcase 'schemacall':\r\n\t\t\treturn new Schemacall({\r\n\t\t\t\tschema: ER.substitute(expr.schema, map),\r\n\t\t\t\targs: expr.args.map(arg => ER.substitute(arg, map))\r\n\t\t\t});\r\n\t\tcase 'schema':\r\n\t\t\t// 이름이 있는 것은 최상단에만 선언되므로 치환되어야 할 것을 포함하지 않으므로 확인하지 않는다는 생각이 들어 있다.\r\n\t\t\tif (expr.name) return expr;\r\n\r\n\t\t\t// 위의 expr.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\r\n\t\t\tif (expr.params.some(e => map.has(e)))\r\n\t\t\t\tthrow Error('Parameter collision');\r\n\r\n\t\t\treturn new Schema({\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ER.substitute(expr.expr, map)\r\n\t\t\t});\r\n\t\tcase 'reduction':\r\n\t\t\treturn ER.substitute(expr.reduced, map);\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${expr._type}`);\r\n\t}\r\n};\r\n\r\nER.call0 = function (fun, args) {\r\n\tif (fun._type != 'fun') {\r\n\t\tthrow Error('Illegal type');\r\n\t}\r\n\r\n\tif (!fun.expr) {\r\n\t\tthrow Error('Cannot call a primitive fun');\r\n\t}\r\n\r\n\tif (fun.params.length != args.length) {\r\n\t\tthrow Error('Illegal arguments length');\r\n\t}\r\n\r\n\tvar map = new Map();\r\n\r\n\tfor (var i = 0; i < fun.params.length; i++) {\r\n\t\tmap.set(fun.params[i], args[i]);\r\n\t}\r\n\r\n\treturn ER.substitute(fun.expr, map);\r\n};\r\n\r\nER.callMeta = function (schema, args) {\r\n\tif (schema._type != 'schema') {\r\n\t\tthrow Error('Illegal type');\r\n\t}\r\n\r\n\tif (schema.params.length != args.length) {\r\n\t\tthrow Error('Illegal arguments length');\r\n\t}\r\n\r\n\tvar map = new Map();\r\n\r\n\tfor (var i = 0; i < schema.params.length; i++) {\r\n\t\tmap.set(schema.params[i], args[i]);\r\n\t}\r\n\r\n\treturn ER.substitute(schema.expr, map);\r\n};\r\n\r\n/*\r\n * 이름 있는 것도 푼다. 한 번만.\r\n * equals0에서 쓴다.\r\n */\r\nER.expand0FuncallOnce = function (expr) {\r\n\tif (expr._type != 'funcall') {\r\n\t\tthrow Error('Illegal type');\r\n\t}\r\n\r\n\tif (expr.fun._type == 'funcall') {\r\n\t\tvar fun = ER.expand0FuncallOnce(expr.fun);\r\n\t\treturn new Funcall({\r\n\t\t\tfun,\r\n\t\t\targs: expr.args\r\n\t\t});\r\n\t}\r\n\r\n\tif (!expr.fun.expr)\r\n\t\tthrow Error('Could not expand');\r\n\r\n\treturn ER.call0(expr.fun, expr.args);\r\n};\r\n\r\n// 이름 있는 것은 풀지 않는다. 재귀적.\r\nER.expand0Funcalls = function (expr) {\r\n\tif (expr._type == 'funcall') {\r\n\t\tvar fun = ER.expand0Funcalls(expr.fun);\r\n\t\tvar args = expr.args.map(ER.expand0Funcalls);\r\n\r\n\t\tif (fun._type != 'fun' || fun.name)\r\n\t\t\treturn new Funcall({fun, args});\r\n\r\n\t\treturn ER.expand0Funcalls(ER.call0(fun, args));\r\n\t} else if (expr._type == 'fun' && !expr.name) {\r\n\t\treturn new Fun({\r\n\t\t\tname: null,\r\n\t\t\tparams: expr.params,\r\n\t\t\texpr: ER.expand0Funcalls(expr.expr)\r\n\t\t});\r\n\t} else {\r\n\t\treturn expr;\r\n\t}\r\n};\r\n\r\n// expand0은 하지 않는다.\r\nER.expandMeta = function (expr) {\r\n\tif (expr.native) {\r\n\t\treturn expr;\r\n\t}\r\n\r\n\tswitch (expr._type) {\r\n\t\tcase 'tee':\r\n\t\t\tvar left = expr.left.map(ER.expandMeta);\r\n\t\t\tvar right = ER.expandMeta(expr.right);\r\n\r\n\t\t\treturn new Tee({left, right});\r\n\t\tcase 'schemacall':\r\n\t\t\tvar schema = ER.expandMeta(expr.schema),\r\n\t\t\t\targs = expr.args;\r\n\r\n\t\t\treturn ER.expandMeta(ER.callMeta(schema, args));\r\n\t\tcase 'reduction':\r\n\t\t\treturn ER.expandMeta(expr.reduced);\r\n\t\tcase 'schema':\r\n\t\t\treturn new Schema({\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ER.expandMeta(expr.expr)\r\n\t\t\t});\r\n\t\tcase 'funcall':\r\n\t\tcase 'fun':\r\n\t\tcase 'typevar':\r\n\t\t\treturn expr;\r\n\t\tdefault:\r\n\t\t\tconsole.log(expr);\r\n\t\t\tthrow Error('Unknown metaexpr');\r\n\t}\r\n};\r\n\r\n// expr0의 이름 없는 funcall까지 풀음.\r\nER.expandMetaAndFuncalls = function (expr) {\r\n\tswitch (expr._type) {\r\n\t\tcase 'tee':\r\n\t\t\tvar left = expr.left.map(ER.expandMetaAndFuncalls);\r\n\t\t\tvar right = ER.expandMetaAndFuncalls(expr.right);\r\n\r\n\t\t\treturn new Tee({left, right});\r\n\t\tcase 'schemacall':\r\n\t\t\tvar schema = ER.expandMetaAndFuncalls(expr.schema);\r\n\t\t\tvar args = expr.args.map(ER.expand0Funcalls);\r\n\r\n\t\t\treturn ER.expandMetaAndFuncalls(ER.callMeta(schema, args));\r\n\t\tcase 'reduction':\r\n\t\t\treturn ER.expandMetaAndFuncalls(expr.reduced);\r\n\t\tcase 'schema':\r\n\t\t\treturn new Schema({\r\n\t\t\t\taxiomatic: expr.axiomatic,\r\n\t\t\t\tname: null,\r\n\t\t\t\tparams: expr.params,\r\n\t\t\t\texpr: ER.expandMetaAndFuncalls(expr.expr)\r\n\t\t\t});\r\n\t\tcase 'funcall':\r\n\t\tcase 'fun':\r\n\t\tcase 'typevar':\r\n\t\t\treturn ER.expand0Funcalls(expr);\r\n\t\tdefault:\r\n\t\t\tconsole.log(expr);\r\n\t\t\tthrow Error('Unknown metaexpr');\r\n\t}\r\n};\r\n\r\n/*\r\n * 스펙 참조.\r\n */\r\nER.equals0 = function (a, b) {\r\n\tfunction recurse(a, b, depth) {\r\n\t\tif (a == b) return true;\r\n\r\n\t\tif (!a.type.equals(b.type)) return false;\r\n\r\n\t\tif (a._type == 'funcall' && b._type == 'funcall') {\r\n\t\t\tif (a.fun._type == 'funcall') return recurseWrap(\r\n\t\t\t\tER.expand0FuncallOnce(a), b, depth + 1\r\n\t\t\t);\r\n\r\n\t\t\tif (b.fun._type == 'funcall') return recurseWrap(\r\n\t\t\t\ta, ER.expand0FuncallOnce(b), depth + 1\r\n\t\t\t);\r\n\r\n\t\t\tif (!a.fun.expr && !b.fun.expr) {\r\n\t\t\t\tif (a.fun != b.fun) return false;\r\n\t\t\t\tfor (var i = 0; i < a.args.length; i++) {\r\n\t\t\t\t\tif (!recurseWrap(a.args[i], b.args[i], depth + 1)) return false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (a.fun.expr) return recurseWrap(\r\n\t\t\t\tER.expand0FuncallOnce(a), b, depth + 1\r\n\t\t\t);\r\n\r\n\t\t\treturn recurseWrap(\r\n\t\t\t\ta, ER.expand0FuncallOnce(b), depth + 1\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (a._type == 'funcall') {\r\n\t\t\tif (a.fun._type == 'funcall') return recurseWrap(\r\n\t\t\t\tER.expand0FuncallOnce(a), b, depth + 1\r\n\t\t\t);\r\n\r\n\t\t\tif (!a.fun.expr) return false;\r\n\t\t\treturn recurseWrap(\r\n\t\t\t\tER.expand0FuncallOnce(a), b, depth + 1\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (b._type == 'funcall') {\r\n\t\t\tif (b.fun._type == 'funcall') return recurseWrap(\r\n\t\t\t\ta, ER.expand0FuncallOnce(b), depth + 1\r\n\t\t\t);\r\n\r\n\t\t\tif (!b.fun.expr) return false;\r\n\t\t\treturn recurseWrap(\r\n\t\t\t\ta, ER.expand0FuncallOnce(b), depth + 1\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (a.type.isFunctional) {\r\n\t\t\tvar placeholders = Array(a.type.resolve().from.length).fill().map((_, i) =>\r\n\t\t\t\tnew Typevar({\r\n\t\t\t\t\ttype: a.type.resolve().from[i],\r\n\t\t\t\t\tname: '$' + i\r\n\t\t\t\t})\r\n\t\t\t);\r\n\r\n\t\t\treturn recurseWrap(\r\n\t\t\t\tnew Funcall({\r\n\t\t\t\t\tfun: a,\r\n\t\t\t\t\targs: placeholders\r\n\t\t\t\t}),\r\n\t\t\t\tnew Funcall({\r\n\t\t\t\t\tfun: b,\r\n\t\t\t\t\targs: placeholders\r\n\t\t\t\t}),\r\n\t\t\t\tdepth + 1\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar recurseWrap = recurse;\r\n\r\n\t// function recurseWrap(a, b, depth) {\r\n\t// \tconsole.log(`${depth}\\n${a}\\n\\n${b}`);\r\n\t// \tvar ret = recurse(a, b, depth);\r\n\t// \tconsole.log(`${depth}\\n${a}\\n\\n${b}\\n${ret}`);\r\n\t// \treturn ret;\r\n\t// }\r\n\r\n\treturn recurseWrap(a, b, 0);\r\n};\r\n\r\nER.equalsMeta = function (a, b) {\r\n\tif (a._type == 'reduction') {\r\n\t\treturn ER.equalsMeta(a.reduced, b);\r\n\t}\r\n\r\n\tif (b._type == 'reduction') {\r\n\t\treturn ER.equalsMeta(a, b.reduced);\r\n\t}\r\n\r\n\tif (a.type._type == 'type' && b.type._type == 'type') {\r\n\t\treturn ER.equals0(a, b);\r\n\t}\r\n\r\n\tif (a.type._type != b.type._type) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn (function recurse(a, b) {\r\n\t\tif (a == b) return true;\r\n\t\t\r\n\t\tif (!a.type.equals(b.type)) return false;\r\n\r\n\t\ta = ER.expandMeta(a);\r\n\t\tb = ER.expandMeta(b);\r\n\r\n\t\tif (a._type == 'tee') {\r\n\t\t\tif (b._type != 'tee') {\r\n\t\t\t\tthrow Error('wut');\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0; i < a.left.length; i++) {\r\n\t\t\t\tif (!ER.equals0(a.left[i], b.left[i])) return false;\r\n\t\t\t}\r\n\r\n\t\t\treturn ER.equals0(a.right, b.right);\r\n\t\t}\r\n\r\n\t\tif (a._type == 'schema') {\r\n\t\t\tif (b._type != 'schema' || a.type.from.length != b.type.from.length) {\r\n\t\t\t\tthrow Error('wut');\r\n\t\t\t}\r\n\r\n\t\t\tvar placeholders = Array(a.type.from.length).fill().map((_, i) =>\r\n\t\t\t\tnew Typevar({\r\n\t\t\t\t\ttype: a.type.from[i],\r\n\t\t\t\t\tname: '$' + i\r\n\t\t\t\t})\r\n\t\t\t);\r\n\r\n\t\t\treturn recurse(\r\n\t\t\t\tnew Schemacall({\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tschema: a,\r\n\t\t\t\t\targs: placeholders\r\n\t\t\t\t}),\r\n\t\t\t\tnew Schemacall({\r\n\t\t\t\t\tname: null,\r\n\t\t\t\t\tschema: b,\r\n\t\t\t\t\targs: placeholders\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthrow Error('wut');\r\n\t})(a, b);\r\n};\r\n\r\nER.chain = function (tees) {\r\n\tif (!tees.every(tee => tee._type == 'tee')) {\r\n\t\tthrow Error('no');\r\n\t}\r\n\r\n\treturn ER.expandMetaAndFuncalls(tees.reduceRight((r, l) => {\r\n\t\tfor (var i = 0; i < r.left.length; i++) {\r\n\t\t\tif (ER.equals0(l.right, r.left[i])) {\r\n\t\t\t\tvar newleft = r.left.slice(0, i)\r\n\t\t\t\t\t.concat(l.left)\r\n\t\t\t\t\t.concat(r.left.slice(i + 1));\r\n\r\n\t\t\t\treturn new Tee({\r\n\t\t\t\t\tleft: newleft,\r\n\t\t\t\t\tright: r.right\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow Error(`Chaining failed:\r\n\r\n--- LEFT ---\r\n${l}\r\n------------\r\n\r\n--- RIGHT ---\r\n${r}\r\n-------------`);\r\n\t}));\r\n};\r\n\r\nmodule.exports = ER;\n\n//# sourceURL=webpack://math/./src/ExpressionResolver.js?");

/***/ }),

/***/ "./src/PegInterface.js":
/*!*****************************!*\
  !*** ./src/PegInterface.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\r\n * PEG.js의 출력은 여기에서만 처리해야 한다.\r\n */\r\n\r\nvar Type = __webpack_require__(/*! ./nodes/Type */ \"./src/nodes/Type.js\");\r\nvar Typevar = __webpack_require__(/*! ./nodes/Typevar */ \"./src/nodes/Typevar.js\");\r\nvar Fun = __webpack_require__(/*! ./nodes/Fun */ \"./src/nodes/Fun.js\");\r\nvar Funcall = __webpack_require__(/*! ./nodes/Funcall */ \"./src/nodes/Funcall.js\");\r\nvar Tee = __webpack_require__(/*! ./nodes/Tee */ \"./src/nodes/Tee.js\");\r\nvar Ruleset = __webpack_require__(/*! ./nodes/Ruleset */ \"./src/nodes/Ruleset.js\");\r\nvar Schema = __webpack_require__(/*! ./nodes/Schema */ \"./src/nodes/Schema.js\");\r\nvar Schemacall = __webpack_require__(/*! ./nodes/Schemacall */ \"./src/nodes/Schemacall.js\");\r\nvar Reduction = __webpack_require__(/*! ./nodes/Reduction */ \"./src/nodes/Reduction.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ./ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nvar PI = {};\r\n\r\nfunction typeObjToString(obj) {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) return obj.name;\r\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\r\n\t\t\t+ typeObjToString(obj.to) + ']';\r\n}\r\n\r\n/*\r\n * Scope.prototype.getType이나 Scope.prototype.hasType 등의 입력 형태로 바꾼다.\r\n * st\t\t\t\t\t\t-> 'st'\r\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\r\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\r\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\r\n */\r\nfunction typeObjToNestedArr(obj) {\r\n\tif (obj._type != 'type')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tif (!obj.ftype) {\r\n\t\tif (!obj.name)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.name;\r\n\t} else {\r\n\t\tif (!obj.from || !obj.to)\r\n\t\t\tthrow Error('Assertion failed');\r\n\r\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\r\n\t\t\t[typeObjToNestedArr(obj.to)]\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction varObjToString(obj) {\r\n\tswitch (obj.type) {\r\n\t\tcase 'ruleset':\r\n\t\t\treturn `${obj.rulesetName}.${obj.name}`;\r\n\t\tcase 'normal':\r\n\t\t\treturn `${obj.name}`;\r\n\t\tdefault:\r\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\r\n\t}\r\n}\r\n\r\nPI.type = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'typedef')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('type', obj.name, obj.location);\r\n\r\n\tvar origin = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\r\n\r\n\tvar name = obj.name;\r\n\tvar doc = obj.doc;\r\n\tvar base = obj.base;\r\n\r\n\tif (base && origin) {\r\n\t\tthrow trace.error('Base type should not be an alias');\r\n\t}\r\n\r\n\tif (origin) {\r\n\t\treturn new Type({\r\n\t\t\tname,\r\n\t\t\tdoc,\r\n\t\t\tbase,\r\n\t\t\torigin\r\n\t\t});\r\n\t}\r\n\r\n\treturn new Type({\r\n\t\tfunctional: false,\r\n\t\tname,\r\n\t\tdoc,\r\n\t\tbase\r\n\t});\r\n};\r\n\r\nPI.typevar = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'defv')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('typevar', obj.name, obj.location);\r\n\r\n\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\r\n\t\tthrow trace.error(`Type ${obj.type} not found`);\r\n\r\n\tvar type = scope.getType(typeObjToNestedArr(obj.type));\r\n\r\n\treturn new Typevar({\r\n\t\ttype,\r\n\t\tisParam: !!obj.isParam,\r\n\t\tguess: obj.guess || null,\r\n\t\tname: obj.name,\r\n\t\tdoc: obj.doc,\r\n\t\ttex: obj.tex\r\n\t}, scope, trace);\r\n};\r\n\r\nPI.fun = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'defun' && obj._type != 'funexpr')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('fun', obj.name || null, obj.location);\r\n\r\n\tvar name = obj.name || null;\r\n\tvar type = null;\r\n\tvar params = obj.params.map(tvo => {\r\n\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\tthrow trace.error(`Param type ${typeObjToString(tvo.type)} not found`);\r\n\r\n\t\tif (scope.hasOwnTypevar(tvo.name))\r\n\t\t\tthrow trace.error(`Param name ${tvo.name} already is there`);\r\n\r\n\t\tvar tv = PI.typevar(tvo, scope, trace);\r\n\t\treturn scope.addTypevar(tv);\r\n\t});\r\n\tvar expr = null;\r\n\tvar doc = obj.doc || null;\r\n\tvar tex = obj.tex || null;\r\n\r\n\tswitch (obj._type) {\r\n\t\tcase 'defun':\r\n\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype)))\r\n\t\t\t\tthrow trace.error(`Rettype ${typeObjToString(obj.rettype)} not found`);\r\n\r\n\t\t\tvar rettype = scope.getType(typeObjToNestedArr(obj.rettype));\r\n\r\n\t\t\tif (obj.expr) {\r\n\t\t\t\texpr = PI.expr0(obj.expr, scope, trace);\r\n\t\t\t\tif (!rettype.equals(expr.type))\r\n\t\t\t\t\tthrow trace.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`);\r\n\t\t\t} else {\r\n\t\t\t\ttype = new Type({\r\n\t\t\t\t\tfunctional: true,\r\n\t\t\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\t\t\tto: rettype\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'funexpr':\r\n\t\t\texpr = PI.expr0(obj.expr, scope, trace);\r\n\t\t\ttype = null;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow Error('wut');\r\n\t}\r\n\r\n\treturn new Fun({name, type, params, expr, doc, tex}, scope, trace);\r\n};\r\n\r\nPI.funcall = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'funcall')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('funcall', obj.fun.name || null, obj.location);\r\n\r\n\tvar fun = PI.expr0(obj.fun, scope, trace);\r\n\r\n\tvar args = obj.args.map(arg => {\r\n\t\treturn PI.expr0(arg, scope, trace);\r\n\t});\r\n\r\n\treturn new Funcall({fun, args}, scope, trace);\r\n};\r\n\r\nPI.metaexpr = function (obj, parentScope, trace) {\r\n\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var'].includes(obj._type))\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\t// don't extend scope/trace\r\n\tvar scope = parentScope;\r\n\r\n\tswitch (obj._type) {\r\n\t\tcase 'tee':\r\n\t\t\treturn PI.tee(obj, scope, trace);\r\n\t\tcase 'reduction':\r\n\t\t\treturn PI.reduction(obj, scope, trace);\r\n\t\tcase 'schemacall':\r\n\t\t\treturn PI.schemacall(obj, scope, trace);\r\n\t\tcase 'schemaexpr':\r\n\t\t\treturn PI.schema(obj, scope, trace);\r\n\t\tcase 'var':\r\n\t\t\treturn PI.metavar(obj, scope, trace);\r\n\t\tdefault:\r\n\t\t\tthrow Error('wut');\r\n\t}\r\n};\r\n\r\nPI.expr0 = function (obj, parentScope, trace) {\r\n\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\r\n\t\tconsole.log(obj);\r\n\t\tthrow Error('Assertion failed');\r\n\t}\r\n\r\n\t// don't extend scope/trace\r\n\tvar scope = parentScope;\r\n\r\n\tswitch (obj._type) {\r\n\t\tcase 'funcall':\r\n\t\t\treturn PI.funcall(obj, scope, trace);\r\n\t\tcase 'funexpr':\r\n\t\t\treturn PI.fun(obj, scope, trace);\r\n\t\tcase 'var':\r\n\t\t\tif (!scope.hasTypevar(obj.name))\r\n\t\t\t\tthrow trace.error(`Undefined identifier ${obj.name}`);\r\n\t\t\treturn scope.getTypevar(obj.name);\r\n\t\tdefault:\r\n\t\t\tthrow Error('wut');\r\n\t}\r\n};\r\n\r\nPI.metavar = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'var')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\t// don't extend scope/trace\r\n\tvar scope = parentScope;\r\n\r\n\tswitch (obj.type) {\r\n\t\tcase 'ruleset':\r\n\t\t\tif (!scope.hasRuleset(obj.rulesetName))\r\n\t\t\t\tthrow trace.error(`Ruleset ${obj.rulesetName} is not defined`);\r\n\r\n\t\t\tvar ruleset = scope.getRuleset(obj.rulesetName);\r\n\r\n\t\t\tif (!ruleset.native)\r\n\t\t\t\tthrow trace.error('Behavior undefined for non-native rulesets');\r\n\r\n\t\t\tvar schema = ruleset.native.get(obj.name, scope);\r\n\r\n\t\t\tif (!schema)\r\n\t\t\t\tthrow trace.error(`Schema ${varObjToString(obj)} not found`);\r\n\t\t\t\r\n\t\t\treturn schema;\r\n\t\tcase 'normal':\r\n\t\t\tif (!scope.hasSchema(obj.name))\r\n\t\t\t\tthrow trace.error(`Schema ${obj.name} is not defined`);\r\n\r\n\t\t\treturn scope.getSchema(obj.name);\r\n\t\tdefault:\r\n\t\t\tthrow trace.error(`Unknown type ${obj.type}`);\r\n\t}\r\n};\r\n\r\nPI.tee = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'tee')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('tee', null, obj.location);\r\n\r\n\tvar foo = obj => PI.metaexpr(obj, scope, trace);\r\n\r\n\tvar left = obj.left.map(foo);\r\n\tvar right = foo(obj.right);\r\n\r\n\treturn new Tee({left, right}, scope, trace);\r\n};\r\n\r\nPI.schema = function (obj, parentScope, trace, nativeMap) {\r\n\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('schema', obj.name, obj.location);\r\n\r\n\tvar axiomatic = obj.axiomatic;\r\n\tvar name = obj.name;\r\n\r\n\tif (obj.native) {\r\n\t\tif (!nativeMap.schema[name])\r\n\t\t\tthrow trace.error(`Native code for native schema ${name} not found`);\r\n\r\n\t\tvar native = {\r\n\t\t\tget: args => nativeMap.schema[name].get(args, scope, ExpressionResolver)\r\n\t\t};\r\n\r\n\t\treturn new Schema({axiomatic, name, native, doc: obj.doc}, scope, trace);\r\n\t}\r\n\r\n\tvar params = obj.params.map(tvo => {\r\n\t\tif (!scope.hasType(typeObjToNestedArr(tvo.type)))\r\n\t\t\tthrow trace.error(`Param type ${typeObjToString(tvo.type)} not found`);\r\n\r\n\t\tif (scope.hasOwnTypevar(tvo.name))\r\n\t\t\tthrow trace.error(`Param name ${tvo.name} already is there`);\r\n\r\n\t\tvar tv = PI.typevar(tvo, scope, trace);\r\n\t\treturn scope.addTypevar(tv);\r\n\t});\r\n\r\n\tvar expr = PI.metaexpr(obj.expr, scope, trace);\r\n\r\n\tif (obj._type == 'schemaexpr' && expr.type._type == 'type') {\r\n\t\treturn new Fun({\r\n\t\t\tname,\r\n\t\t\tparams,\r\n\t\t\texpr,\r\n\t\t\tdoc: obj.doc,\r\n\t\t\ttex: null\r\n\t\t}, scope, trace);\r\n\t}\r\n\r\n\treturn new Schema({axiomatic, name, params, expr, doc: obj.doc}, scope, trace);\r\n};\r\n\r\nPI.schemacall = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'schemacall')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('schemacall', obj.schema.name || null, obj.location);\r\n\r\n\tvar schema = PI.metaexpr(obj.schema, scope, trace);\r\n\r\n\tif (schema.type._type == 'type') {\r\n\t\treturn PI.funcall({\r\n\t\t\t_type: 'funcall',\r\n\t\t\tfun: obj.schema,\r\n\t\t\targs: obj.args,\r\n\t\t\tlocation: obj.location\r\n\t\t}, parentScope, trace);\r\n\t}\r\n\r\n\tvar args = obj.args.map(obj => {\r\n\t\treturn PI.expr0(obj, scope, trace);\r\n\t});\r\n\r\n\treturn new Schemacall({\r\n\t\tschema,\r\n\t\targs\r\n\t}, scope, trace);\r\n};\r\n\r\nPI.ruleset = function (obj, parentScope, trace, nativeMap) {\r\n\tif (obj._type != 'defruleset')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('ruleset', obj.name, obj.location);\r\n\r\n\tvar axiomatic = obj.axiomatic;\r\n\tvar name = obj.name;\r\n\r\n\tif (!obj.native)\r\n\t\tthrow trace.error('Assertion failed');\r\n\r\n\tif (!nativeMap.ruleset[name])\r\n\t\tthrow trace.error(`Native code for native ruleset ${name} not found`);\r\n\r\n\tvar native = nativeMap.ruleset[name];\r\n\r\n\treturn new Ruleset({axiomatic, name, native, doc: obj.doc}, scope, trace);\r\n};\r\n\r\nPI.reduction = function (obj, parentScope, trace) {\r\n\tif (obj._type != 'reduction')\r\n\t\tthrow Error('Assertion failed');\r\n\r\n\tvar scope = parentScope.extend();\r\n\ttrace = trace.extend('reduction', obj.subject.name || null, obj.location);\r\n\r\n\tvar subject = PI.metaexpr(obj.subject, scope, trace);\r\n\r\n\tvar guesses = !obj.guesses\r\n\t\t? null\r\n\t\t: obj.guesses.map(g => {\r\n\t\t\treturn g && PI.expr0(g, scope, trace);\r\n\t\t});\r\n\r\n\tvar leftargs = obj.leftargs.map(obj => {\r\n\t\treturn PI.metaexpr(obj, scope, trace);\r\n\t});\r\n\r\n\treturn new Reduction({\r\n\t\tsubject,\r\n\t\tguesses,\r\n\t\tleftargs\r\n\t}, scope, trace);\r\n};\r\n\r\nmodule.exports = PI;\n\n//# sourceURL=webpack://math/./src/PegInterface.js?");

/***/ }),

/***/ "./src/Program.js":
/*!************************!*\
  !*** ./src/Program.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Scope = __webpack_require__(/*! ./Scope */ \"./src/Scope.js\");\r\n\r\nvar Type = __webpack_require__(/*! ./nodes/Type */ \"./src/nodes/Type.js\");\r\nvar Typevar = __webpack_require__(/*! ./nodes/Typevar */ \"./src/nodes/Typevar.js\");\r\nvar Fun = __webpack_require__(/*! ./nodes/Fun */ \"./src/nodes/Fun.js\");\r\nvar Funcall = __webpack_require__(/*! ./nodes/Funcall */ \"./src/nodes/Funcall.js\");\r\nvar Tee = __webpack_require__(/*! ./nodes/Tee */ \"./src/nodes/Tee.js\");\r\nvar Ruleset = __webpack_require__(/*! ./nodes/Ruleset */ \"./src/nodes/Ruleset.js\");\r\nvar Schema = __webpack_require__(/*! ./nodes/Schema */ \"./src/nodes/Schema.js\");\r\nvar Schemacall = __webpack_require__(/*! ./nodes/Schemacall */ \"./src/nodes/Schemacall.js\");\r\n\r\nvar PegInterface = __webpack_require__(/*! ./PegInterface */ \"./src/PegInterface.js\");\r\nvar ExpressionResolver = __webpack_require__(/*! ./ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\nvar StackTrace = __webpack_require__(/*! ./StackTrace */ \"./src/StackTrace.js\");\r\n\r\nExpressionResolver.init({Type, Typevar, Fun, Funcall, Tee, Ruleset, Schema, Schemacall});\r\n\r\nfunction Program() {\r\n\tthis.scope = new Scope(null);\r\n\tthis.trace = new StackTrace();\r\n\tthis.ExpressionResolver = ExpressionResolver;\r\n}\r\n\r\nProgram.prototype.feed = function (lines, nativeMap) {\r\n\tlines.forEach(line => {\r\n\t\tswitch (line._type) {\r\n\t\t\tcase 'typedef':\r\n\t\t\t\tvar type = PegInterface.type(line, this.scope, this.trace);\r\n\t\t\t\tthis.scope.addType(type);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'defv':\r\n\t\t\t\tvar typevar = PegInterface.typevar(line, this.scope, this.trace);\r\n\t\t\t\tthis.scope.addTypevar(typevar);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'defun':\r\n\t\t\t\tvar fun = PegInterface.fun(line, this.scope, this.trace);\r\n\t\t\t\tthis.scope.addFun(fun);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'defruleset':\r\n\t\t\t\tvar ruleset = PegInterface.ruleset(line, this.scope, this.trace, nativeMap);\r\n\t\t\t\tthis.scope.addRuleset(ruleset);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'defschema':\r\n\t\t\t\tvar schema = PegInterface.schema(line, this.scope, this.trace, nativeMap);\r\n\t\t\t\tthis.scope.addSchema(schema);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow Error(`Unknown line type ${line._type}`);\r\n\t\t}\r\n\t});\r\n};\r\n\r\nmodule.exports = Program;\n\n//# sourceURL=webpack://math/./src/Program.js?");

/***/ }),

/***/ "./src/Scope.js":
/*!**********************!*\
  !*** ./src/Scope.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Type = __webpack_require__(/*! ./nodes/Type */ \"./src/nodes/Type.js\");\r\nvar Typevar = __webpack_require__(/*! ./nodes/Typevar */ \"./src/nodes/Typevar.js\");\r\nvar Fun = __webpack_require__(/*! ./nodes/Fun */ \"./src/nodes/Fun.js\");\r\nvar Funcall = __webpack_require__(/*! ./nodes/Funcall */ \"./src/nodes/Funcall.js\");\r\nvar Tee = __webpack_require__(/*! ./nodes/Tee */ \"./src/nodes/Tee.js\");\r\nvar Ruleset = __webpack_require__(/*! ./nodes/Ruleset */ \"./src/nodes/Ruleset.js\");\r\nvar Schema = __webpack_require__(/*! ./nodes/Schema */ \"./src/nodes/Schema.js\");\r\nvar Schemacall = __webpack_require__(/*! ./nodes/Schemacall */ \"./src/nodes/Schemacall.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ./ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nfunction Scope(parent) {\r\n\tthis.typedefMap = {};\r\n\tthis.defMap = {};\r\n\tthis.schemaMap = {};\r\n\tthis.rulesetMap = {};\r\n\r\n\tthis.Type = Type;\r\n\tthis.Typevar = Typevar;\r\n\tthis.Fun = Fun;\r\n\tthis.Funcall = Funcall;\r\n\tthis.Tee = Tee;\r\n\tthis.Ruleset = Ruleset;\r\n\tthis.Schema = Schema;\r\n\tthis.Schemacall = Schemacall;\r\n\r\n\tthis.ExpressionResolver = ExpressionResolver;\r\n\r\n\tthis.parent = parent;\r\n\tthis.root = parent ? parent.root : this;\r\n\r\n\tthis.baseType = parent ? parent.baseType : null;\r\n}\r\n\r\nScope.prototype.extend = function () {\r\n\treturn new Scope(this);\r\n};\r\n\r\n/*\r\n * Possible input values:\r\n * 'st'\t\t\t\t\t\t-> st\r\n * ['cls', 'st']\t\t\t-> [cls -> st]\r\n * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n */\r\nScope.prototype.hasOwnType = function (name) {\r\n\tif (typeof name == 'string') {\r\n\t\treturn !!this.typedefMap[name];\r\n\t}\r\n\r\n\tif (!(name instanceof Array))\r\n\t\tthrow Error('Gimme an array/string');\r\n\r\n\tif (name.length < 2)\r\n\t\tthrow Error('Illegal array length');\r\n\r\n\treturn name.map(e => {\r\n\t\treturn this.hasOwnType(e);\r\n\t}).every(e => e);\r\n};\r\n\r\n/*\r\n * Possible input values:\r\n * 'st'\t\t\t\t\t\t-> st\r\n * ['cls', 'st']\t\t\t-> [cls -> st]\r\n * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n */\r\nScope.prototype.hasType = function (name) {\r\n\tif (typeof name == 'string') {\r\n\t\treturn this.hasOwnType(name)\r\n\t\t\t|| (!!this.parent && this.parent.hasType(name));\r\n\t}\r\n\r\n\tif (!(name instanceof Array))\r\n\t\tthrow Error('Gimme an array/string');\r\n\r\n\tif (name.length < 2)\r\n\t\tthrow Error('Illegal array length');\r\n\r\n\treturn name.map(e => {\r\n\t\treturn this.hasType(e);\r\n\t}).every(e => e);\r\n};\r\n\r\nScope.prototype.addType = function (type) {\r\n\tif (!(type instanceof Type))\r\n\t\tthrow Error('Illegal argument type');\r\n\r\n\tif (!type.name)\r\n\t\tthrow Error('Something\\'s wrong');\r\n\r\n\tif (this.hasOwnType(type.name))\r\n\t\tthrow Error(`Type with name ${type.name} already is there`);\r\n\r\n\tif (type.isBaseType) {\r\n\t\tif (this.baseType) {\r\n\t\t\tthrow Error('A base type already exists');\r\n\t\t}\r\n\r\n\t\t(function broadcast(scope) {\r\n\t\t\tscope.baseType = type;\r\n\t\t\tif (scope.parent) broadcast(scope.parent);\r\n\t\t})(this);\r\n\t}\r\n\r\n\treturn this.typedefMap[type.name] = type;\r\n};\r\n\r\n/*\r\n * Possible input values:\r\n * 'st'\t\t\t\t\t\t-> st\r\n * ['cls', 'st']\t\t\t-> [cls -> st]\r\n * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\r\n * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\r\n */\r\nScope.prototype.getType = function (name) {\r\n\tif (typeof name == 'string') {\r\n\t\tif (!this.hasType(name))\r\n\t\t\tthrow Error(`Type with name ${name} not found`);\r\n\r\n\t\treturn this.typedefMap[name] ||\r\n\t\t\t(!!this.parent && this.parent.getType(name));\r\n\t}\r\n\r\n\tif (!(name instanceof Array))\r\n\t\tthrow Error('Gimme an array/string');\r\n\r\n\tif (name.length < 2)\r\n\t\tthrow Error('Illegal array length');\r\n\r\n\tvar from = name.slice(0, name.length - 1).map(e => {\r\n\t\treturn this.getType(e);\r\n\t});\r\n\r\n\tvar to = this.getType(name[name.length - 1]);\r\n\r\n\treturn new Type({\r\n\t\tfunctional: true,\r\n\t\tfrom,\r\n\t\tto\r\n\t});\r\n};\r\n\r\nScope.prototype.hasOwnTypevar = function (name) {\r\n\treturn !!this.defMap[name];\r\n};\r\n\r\nScope.prototype.hasTypevar = function (name) {\r\n\treturn this.hasOwnTypevar(name) ||\r\n\t\t(!!this.parent && this.parent.hasTypevar(name));\r\n};\r\n\r\nScope.prototype.addTypevar = function (typevar) {\r\n\tif (!(typevar instanceof Typevar))\r\n\t\tthrow Error('Illegal argument type');\r\n\r\n\tif (this.hasOwnTypevar(typevar.name))\r\n\t\tthrow Error(`Def with name ${typevar.name} already is there`);\r\n\r\n\treturn this.defMap[typevar.name] = typevar;\r\n};\r\n\r\nScope.prototype.addFun = function (fun) {\r\n\tif (!(fun instanceof Fun))\r\n\t\tthrow Error('Illegal argument type');\r\n\r\n\tif (!fun.name)\r\n\t\tthrow Error('Cannot add anonymous fun to scope');\r\n\r\n\tif (this.hasOwnTypevar(fun.name))\r\n\t\tthrow Error(`Def with name ${fun.name} already is there`);\r\n\r\n\treturn this.defMap[fun.name] = fun;\r\n};\r\n\r\nScope.prototype.getTypevar = function (name) {\r\n\tif (!this.hasTypevar(name))\r\n\t\tthrow Error(`Def with name ${name} not found`);\r\n\r\n\treturn this.defMap[name] ||\r\n\t\t(!!this.parent && this.parent.getTypevar(name));\r\n};\r\n\r\nScope.prototype.hasOwnRuleset = function (name) {\r\n\treturn !!this.rulesetMap[name];\r\n};\r\n\r\nScope.prototype.hasRuleset = function (name) {\r\n\treturn this.hasOwnRuleset(name)\r\n\t\t|| (!!this.parent && this.parent.hasRuleset(name));\r\n};\r\n\r\nScope.prototype.addRuleset = function (ruleset) {\r\n\tif (!(ruleset instanceof Ruleset))\r\n\t\tthrow Error('Illegal argument type');\r\n\r\n\tif (this.hasOwnRuleset(ruleset.name))\r\n\t\tthrow Error(`Ruleset with name ${ruleset.name} already is there`);\r\n\r\n\treturn this.rulesetMap[ruleset.name] = ruleset;\r\n};\r\n\r\nScope.prototype.getRuleset = function (name) {\r\n\tif (!this.hasRuleset(name))\r\n\t\tthrow Error(`Ruleset with name ${name} not found`);\r\n\r\n\treturn this.rulesetMap[name] ||\r\n\t\t(!!this.parent && this.parent.getRuleset(name));\r\n};\r\n\r\nScope.prototype.hasOwnSchema = function (name) {\r\n\treturn !!this.schemaMap[name] || !!this.defMap[name];\r\n};\r\n\r\nScope.prototype.hasSchema = function (name) {\r\n\treturn this.hasOwnSchema(name)\r\n\t\t|| (!!this.parent && this.parent.hasSchema(name));\r\n};\r\n\r\nScope.prototype.addSchema = function (schema) {\r\n\tif (!(schema instanceof Schema))\r\n\t\tthrow Error('Illegal argument type');\r\n\r\n\tif (this.hasOwnSchema(schema.name))\r\n\t\tthrow Error(`Schema with name ${schema.name} already is there`);\r\n\r\n\treturn this.schemaMap[schema.name] = schema;\r\n};\r\n\r\nScope.prototype.getSchema = function (name) {\r\n\tif (!this.hasSchema(name))\r\n\t\tthrow Error(`Schema with name ${name} not found`);\r\n\r\n\treturn this.schemaMap[name] || this.defMap[name] ||\r\n\t\t(!!this.parent && this.parent.getSchema(name));\r\n};\r\n\r\nmodule.exports = Scope;\n\n//# sourceURL=webpack://math/./src/Scope.js?");

/***/ }),

/***/ "./src/StackTrace.js":
/*!***************************!*\
  !*** ./src/StackTrace.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nfunction StackTrace(stack) {\r\n\tthis.stack = stack || [];\r\n}\r\n\r\nStackTrace.prototype.extend = function (type, name, location) {\r\n\treturn new StackTrace([[type, name, location]].concat(this.stack));\r\n};\r\n\r\nStackTrace.prototype.error = function (message) {\r\n\treturn new Error(\r\n\t\tmessage\r\n\t\t+ '\\n\\tat ' + this.stack.map(([type, name, location]) => {\r\n\t\t\treturn `${type} ${name || '<anonymous>'} (code.js:${location.start.line}:${location.start.column})`;\r\n\t\t}).join('\\n\\tat ')\r\n\t);\r\n};\r\n\r\nmodule.exports = StackTrace;\n\n//# sourceURL=webpack://math/./src/StackTrace.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ../dist/parser */ \"./dist/parser.js\");\r\nvar Program = __webpack_require__(/*! ./Program */ \"./src/Program.js\");\r\n\r\nmodule.exports = {parser, Program};\n\n//# sourceURL=webpack://math/./src/entry.js?");

/***/ }),

/***/ "./src/nodes/Fun.js":
/*!**************************!*\
  !*** ./src/nodes/Fun.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar Type = __webpack_require__(/*! ./Type */ \"./src/nodes/Type.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ../ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\n/*\r\n * name, expr 중 하나 이상 있어야 하고 type, expr 중\r\n * 한 개만 있어야 한다.\r\n */\r\nfunction Fun({name, type, params, expr, doc, tex}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tthis.doc = doc;\r\n\r\n\tif (tex) {\r\n\t\tvar {precedence, code} = this.parseTeX(tex);\r\n\r\n\t\tthis.precedence = precedence;\r\n\t\tthis.tex = code;\r\n\t} else {\r\n\t\tthis.precedence = false;\r\n\t\tthis.tex = false;\r\n\t}\r\n\r\n\tif (!name && !expr)\r\n\t\tthrow this.error('Anonymous fun cannot be primitive');\r\n\r\n\tif (type && expr)\r\n\t\tthrow this.error('no');\r\n\r\n\tif (!type && !expr)\r\n\t\tthrow this.error('Cannot guess the type of a primitive fun');\r\n\r\n\tif (name !== null && typeof name != 'string')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (type && type._type != 'type')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (!(params instanceof Array)\r\n\t\t\t|| params.map(e => e instanceof Node).some(e => !e))\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (expr !== null && !(expr instanceof Node))\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tthis.name = name;\r\n\tthis.type = type || new Type({\r\n\t\tfunctional: true,\r\n\t\tfrom: params.map(typevar => typevar.type),\r\n\t\tto: expr.type\r\n\t});\r\n\tthis.params = params;\r\n\tthis.expr = expr;\r\n}\r\n\r\nFun.prototype = Object.create(Node.prototype);\r\nFun.prototype.constructor = Fun;\r\nFun.prototype._type = 'fun';\r\n\r\nFun.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nFun.prototype.toIndentedString = function (indent) {\r\n\tif (!this.expr)\r\n\t\treturn `ƒ ${this.type.to} ${this.name}(${this.params.join(', ')});`;\r\n\r\n\treturn [\r\n\t\t(this.name ? 'ƒ ' + this.type.to + ' ' + this.name : 'ƒ ')\r\n\t\t\t+ `(${this.params.join(', ')}) => {`,\r\n\t\t`\\t${this.expr.toIndentedString(indent + 1)}`,\r\n\t\t'}'\r\n\t].join('\\n' + '\\t'.repeat(indent));\r\n};\r\n\r\nFun.prototype.toTeXString = function (prec, root) {\r\n\tif (!this.name) {\r\n\t\tthis.precedence = this.PREC_FUNEXPR;\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t(\r\n\t\t\t\tthis.params.length == 1\r\n\t\t\t\t? this.params[0].toTeXString(false)\r\n\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t),\r\n\t\t\t`\\\\mapsto ${ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(false)}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n\r\n\tif (!root)\r\n\t\treturn `\\\\href{#def-${this.name}}\\\\mathrm{${this.escapeTeX(this.name)}}`;\r\n\r\n\tif (!this.expr)\r\n\t\treturn this.funcallToTeXString(this.params, prec);\r\n\r\n\treturn this.funcallToTeXString(this.params, this.PREC_COLONEQQ)\r\n\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(this.PREC_COLONEQQ)}`;\r\n};\r\n\r\nFun.prototype.funcallToTeXString = function (args, prec) {\r\n\targs = args.map(arg => {\r\n\t\treturn arg.toTeXString(this.tex ? this.precedence : this.PREC_COMMA);\r\n\t});\r\n\r\n\tif (this.tex) {\r\n\t\treturn this.makeTeX('def-' + this.name, args, prec);\r\n\t}\r\n\r\n\treturn `${!this.name\r\n\t\t\t? this.toTeXString(false)\r\n\t\t\t: `\\\\href{#def-${this.name}}{${this.name.length == 1 ? this.escapeTeX(this.name) : `\\\\mathrm{${this.escapeTeX(this.name)}}`}}`}`\r\n\t\t+ `(${args.join(', ')})`;\r\n};\r\n\r\nmodule.exports = Fun;\n\n//# sourceURL=webpack://math/./src/nodes/Fun.js?");

/***/ }),

/***/ "./src/nodes/Funcall.js":
/*!******************************!*\
  !*** ./src/nodes/Funcall.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar Typevar = __webpack_require__(/*! ./Typevar */ \"./src/nodes/Typevar.js\");\r\nvar Fun = __webpack_require__(/*! ./Fun */ \"./src/nodes/Fun.js\");\r\n\r\nfunction Funcall({fun, args}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tif (!(fun instanceof Node))\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (!['typevar', 'fun', 'funcall'].includes(fun._type))\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (fun.type.isSimple)\r\n\t\tthrow this.error(`${fun.name} is not callable`);\r\n\r\n\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tvar resolvedType = fun.type.resolve(),\r\n\t\tparamTypes = resolvedType.from,\r\n\t\targTypes = args.map(e => e.type);\r\n\r\n\tif (paramTypes.length != argTypes.length)\r\n\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\tif (!paramTypes[i].equals(argTypes[i]))\r\n\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t}\r\n\t\r\n\tthis.fun = fun;\r\n\tthis.type = resolvedType.to;\r\n\tthis.args = args;\r\n}\r\n\r\nFuncall.prototype = Object.create(Node.prototype);\r\nFuncall.prototype.constructor = Funcall;\r\nFuncall.prototype._type = 'funcall';\r\n\r\nFuncall.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nFuncall.prototype.toIndentedString = function (indent) {\r\n\tvar args = this.args.map(arg => {\r\n\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\treturn arg.toIndentedString(indent + 1);\r\n\t});\r\n\r\n\tif (args.join('').length <= 50) {\r\n\t\targs = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Typevar) return `${arg.name}<${arg._id}>`;\r\n\t\t\treturn arg.toIndentedString(indent);\r\n\t\t});\r\n\r\n\t\targs = args.join(', ');\r\n\r\n\t\treturn [\r\n\t\t\t`${this.fun._type != 'fun' || !this.fun.name ? '(' + this.fun.toIndentedString(indent) + ')' : this.fun.name}(`,\r\n\t\t\targs,\r\n\t\t\t')'\r\n\t\t].join('');\r\n\t} else {\r\n\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\r\n\t\treturn [\r\n\t\t\t`${this.fun._type != 'fun' || !this.fun.name ? '(' + this.fun.toIndentedString(indent) + ')' : this.fun.name}(`,\r\n\t\t\t'\\t' + args,\r\n\t\t\t')'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n};\r\n\r\nFuncall.prototype.toTeXString = function (prec, root) {\r\n\tif (this.fun instanceof Fun)\r\n\t\treturn this.fun.funcallToTeXString(this.args, prec);\r\n\r\n\tvar args = this.args.map(arg => {\r\n\t\treturn arg.toTeXString(this.PREC_COMMA);\r\n\t});\r\n\r\n\treturn `${!this.fun.name || this.fun._type == 'typevar'\r\n\t\t\t? this.fun.toTeXString(false)\r\n\t\t\t: this.fun.name.length == 1\r\n\t\t\t\t? this.escapeTeX(this.fun.name)\r\n\t\t\t\t: `\\\\mathrm{${this.escapeTeX(this.fun.name)}}`}`\r\n\t\t+ `(${args.join(', ')})`;\r\n};\r\n\r\n\r\nmodule.exports = Funcall;\n\n//# sourceURL=webpack://math/./src/nodes/Funcall.js?");

/***/ }),

/***/ "./src/nodes/MetaType.js":
/*!*******************************!*\
  !*** ./src/nodes/MetaType.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar Type = __webpack_require__(/*! ./Type */ \"./src/nodes/Type.js\");\r\n\r\nfunction MetaType(o) {\r\n\tNode.call(this);\r\n\r\n\tif (typeof o.functional != 'boolean')\r\n\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\r\n\tthis.isFunctional = o.functional;\r\n\tthis.isSimple = !o.functional;\r\n\r\n\tif (!o.functional) {\r\n\t\tif (!(o.left instanceof Array))\r\n\t\t\tthrow this.error('left should be an array');\r\n\r\n\t\tthis.left = o.left;\r\n\t\tthis.right = o.right;\r\n\t} else {\r\n\t\tif (o.from.some(f => !(f instanceof Type)))\r\n\t\t\tthrow this.error('o.from.some(f => !(f instanceof Type))');\r\n\t\t// if (!(o.to instanceof MetaType))\r\n\t\t// \tthrow this.error('!(o.to instanceof MetaType)');\r\n\r\n\t\tif (o.to.isFunctional)\r\n\t\t\tthrow this.error('Functional metatype in functional metatype is not supported');\r\n\r\n\t\tthis.from = o.from;\r\n\t\tthis.to = o.to;\r\n\t}\r\n}\r\n\r\nMetaType.prototype = Object.create(Node.prototype);\r\nMetaType.prototype.constructor = MetaType;\r\nMetaType.prototype._type = 'metatype';\r\n\r\nMetaType.prototype.toString = function () {\r\n\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\r\n\r\n\treturn `[${this.from.join(', ')} -> ${this.to}]`;\r\n};\r\n\r\nMetaType.prototype.equals = function (t) {\r\n\tif (!(t instanceof MetaType)) return false;\r\n\r\n\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\tif (this.isSimple) {\r\n\t\tif (this.left.length != t.left.length) return false;\r\n\r\n\t\tfor (let i = 0; i < this.left.length; i++) {\r\n\t\t\tif (!this.left[i].equals(t.left[i])) return false;\r\n\t\t}\r\n\r\n\t\tif (!this.right.equals(t.right)) return false;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (this.from.length != t.from.length) return false;\r\n\r\n\tfor (let i = 0; i < this.from.length; i++)\r\n\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\treturn this.to.equals(t.to);\r\n};\r\n\r\nmodule.exports = MetaType;\n\n//# sourceURL=webpack://math/./src/nodes/MetaType.js?");

/***/ }),

/***/ "./src/nodes/Node.js":
/*!***************************!*\
  !*** ./src/nodes/Node.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ctr = 0;\r\n\r\nfunction Node(trace) {\r\n\tthis._id = ++ctr;\r\n\tthis.trace = trace || null;\r\n}\r\n\r\nNode.prototype.error = function (message) {\r\n\tif (this.trace) {\r\n\t\treturn this.trace.error(message);\r\n\t} else {\r\n\t\treturn new Error(message);\r\n\t}\r\n};\r\n\r\nNode.prototype.escapeTeX = function (s) {\r\n\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\r\n\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\r\n\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\r\n\t\t'}': '\\\\}',\r\n\t\t'~': '\\\\textasciitilde',\r\n\t\t'^': '\\\\textasciicircum',\r\n\t\t'\\\\': '\\\\textbackslash'\r\n\t})[m]);\r\n};\r\n\r\nNode.prototype.parseTeX = function (tex) {\r\n\tvar precedence = false;\r\n\r\n\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\r\n\t\tprecedence = g1 * 1;\r\n\t\treturn '';\r\n\t});\r\n\r\n\treturn {precedence, code};\r\n};\r\n\r\nNode.prototype.PREC_FUNEXPR = 1000;\r\nNode.prototype.PREC_COMMA = 1000;\r\nNode.prototype.PREC_COLONEQQ = 100000;\r\n\r\n/*\r\n * false corresponds to 0.\r\n * true corresponds to w * 2.\r\n */\r\nNode.prototype.normalizePrecedence = function (prec) {\r\n\tif (prec === false) return [0, 0];\r\n\tif (prec === true) return [2, 0];\r\n\tif (typeof prec == 'number') return [0, prec];\r\n\r\n\tif (!(prec instanceof Array && prec.length == 2)) {\r\n\t\tconsole.log(prec);\r\n\t\tthrow Error('wut');\r\n\t}\r\n\r\n\treturn prec;\r\n};\r\n\r\nNode.prototype.shouldConsolidate = function (prec) {\r\n\tvar my = this.normalizePrecedence(this.precedence || false),\r\n\t\tyour = this.normalizePrecedence(prec || false);\r\n\r\n\tif (my[0] == 0 && my[1] == 0) return false;\r\n\r\n\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\r\n};\r\n\r\nNode.prototype.makeTeX = function (id, args, prec) {\r\n\targs = args || [];\r\n\tprec = prec || false;\r\n\t\r\n\tvar ret = this.tex;\r\n\r\n\tif (this.shouldConsolidate(prec)) {\r\n\t\tret = '\\\\left(' + ret + '\\\\right)';\r\n\t}\r\n\r\n\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\r\n\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\r\n\t}).replace(/<<(.+?)>>/, (match, g1) => {\r\n\t\treturn `\\\\href{#${id}}{${g1}}`;\r\n\t});\r\n};\r\n\r\nmodule.exports = Node;\n\n//# sourceURL=webpack://math/./src/nodes/Node.js?");

/***/ }),

/***/ "./src/nodes/Reduction.js":
/*!********************************!*\
  !*** ./src/nodes/Reduction.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar Schemacall = __webpack_require__(/*! ./Schemacall */ \"./src/nodes/Schemacall.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ../ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nfunction Reduction({subject, guesses, leftargs}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tif (!subject.native && subject._type == 'schema') {\r\n\r\n\t\tsubject.params.forEach((p, i) => {\r\n\t\t\tif (!(guesses && guesses[i]) && !p.guess) {\r\n\t\t\t\tthrow this.error(`Argument #${i + 1} could not be guessed`);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar derefs = subject.params.map((p, i) => {\r\n\t\t\tif (guesses && guesses[i]) return guesses[i];\r\n\r\n\t\t\treturn this.query(\r\n\t\t\t\tp.guess,\r\n\t\t\t\tExpressionResolver.expandMeta(subject.expr).left,\r\n\t\t\t\tleftargs\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tsubject = new Schemacall({\r\n\t\t\tschema: subject,\r\n\t\t\targs: derefs,\r\n\t\t}, scope, trace);\r\n\t} else if (guesses) {\r\n\t\tthrow this.error('Something\\'s wrong');\r\n\t}\r\n\r\n\tif (!subject.native\r\n\t\t\t&& !(subject.type._type == 'metatype' && subject.type.isSimple))\r\n\t\tthrow this.error('Subject is not reducible');\r\n\r\n\tif (!(leftargs instanceof Array)\r\n\t\t\t|| leftargs.map(e => e instanceof Node).some(e => !e))\r\n\t\tthrow this.error('Assertion failed');\r\n\t\r\n\tthis.subject = subject;\r\n\tthis.leftargs = leftargs;\r\n\r\n\tif (subject.native) {\r\n\t\tthis.reduced = subject.native.get(leftargs);\r\n\t\tthis.type = this.reduced.type;\r\n\t} else {\r\n\t\tvar paramTypes = subject.type.left,\r\n\t\t\tleftargTypes = leftargs.map(e => e.type);\r\n\r\n\t\tif (paramTypes.length != leftargTypes.length)\r\n\t\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${leftargTypes.length}`);\r\n\r\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\r\n\t\t\tif (!paramTypes[i].equals(leftargTypes[i]))\r\n\t\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${leftargTypes[i]}`);\r\n\t\t}\r\n\r\n\t\tthis.type = subject.type.right;\r\n\r\n\t\tvar tee = ExpressionResolver.expandMetaAndFuncalls(subject);\r\n\r\n\t\tif (tee._type != 'tee') {\r\n\t\t\tthrow this.error('Assertion failed');\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < tee.left.length; i++) {\r\n\t\t\tif (!ExpressionResolver.equalsMeta(tee.left[i], leftargs[i])) {\r\n\t\t\t\tthrow this.error(`LHS #${i + 1} failed to match:\r\n\r\n--- EXPECTED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(tee.left[i])}\r\n----------------\r\n\r\n--- RECEIVED ---\r\n${ExpressionResolver.expandMetaAndFuncalls(leftargs[i])}\r\n----------------`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.reduced = tee.right;\r\n\t}\r\n}\r\n\r\nReduction.prototype = Object.create(Node.prototype);\r\nReduction.prototype.constructor = Reduction;\r\nReduction.prototype._type = 'reduction';\r\n\r\nReduction.prototype.query = function (guess, left, leftargs) {\r\n\tif (guess.length == 0) throw this.error('wut');\r\n\r\n\tif (!(1 <= guess[0] * 1 && guess[0] * 1 <= leftargs.length))\r\n\t\tthrow this.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\r\n\tvar lef = left[guess[0] * 1 - 1];\r\n\tvar ret = leftargs[guess[0] * 1 - 1];\r\n\r\n\tvar that = this;\r\n\r\n\treturn (function recurse(guess, lef, node, ptr) {\r\n\t\tnode = ExpressionResolver.expandMetaAndFuncalls(node);\r\n\t\t\r\n\t\tif (guess.length <= ptr) return node;\r\n\r\n\t\tif (/[0-9]/.test(guess[ptr])) {\r\n\t\t\tvar n = guess[ptr] * 1;\r\n\r\n\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\tif (lef.left.length != node.left.length) {\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent length mismatch`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!(1 <= n && n <= node.left.length)) {\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}: antecedent index out of range`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn recurse(guess, lef.left[n - 1], node.left[n - 1], ptr + 1);\r\n\t\t\t}\r\n\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (!lef.fun || !node.fun) {\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ExpressionResolver.equals0(lef.fun, node.fun)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.fun.expr) {\r\n\t\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = ExpressionResolver.expand0FuncallOnce(node);\r\n\t\t\t}\r\n\r\n\t\t\tif (!node.args || !(1 <= n && n <= node.args.length))\r\n\t\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\r\n\t\t\treturn recurse(guess, lef.args[n - 1], node.args[n - 1], ptr + 1);\r\n\t\t} else if (guess[ptr] == 'r') {\r\n\t\t\tif (lef._type == 'tee' && node._type == 'tee') {\r\n\t\t\t\treturn recurse(guess, lef.right, node.right, ptr + 1);\r\n\t\t\t}\r\n\r\n\t\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t\t}\r\n\r\n\t\tthrow that.error(`Cannot dereference @${guess}`);\r\n\t})(guess, lef, ret, 1);\r\n};\r\n\r\nReduction.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nReduction.prototype.toIndentedString = function (indent) {\r\n\tvar leftargs = this.leftargs.map(arg => {\r\n\t\treturn arg.toIndentedString(indent + 1);\r\n\t});\r\n\r\n\tif (leftargs.join('').length <= 50) {\r\n\t\tleftargs = this.leftargs.map(arg => {\r\n\t\t\treturn arg.toIndentedString(indent);\r\n\t\t});\r\n\r\n\t\tleftargs = leftargs.join(', ');\r\n\r\n\t\treturn [\r\n\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\tleftargs,\r\n\t\t\t']'\r\n\t\t].join('');\r\n\t}\r\n\telse {\r\n\t\tleftargs = leftargs.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\r\n\t\treturn [\r\n\t\t\t`${this.subject.toIndentedString(indent)}[`,\r\n\t\t\t'\\t' + leftargs,\r\n\t\t\t']'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n};\r\n\r\nReduction.prototype.toTeXString = function (prec, root) {\r\n\treturn `${this.subject.toTeXString(false)}[${this.leftargs.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')}]`;\r\n};\r\n\r\nmodule.exports = Reduction;\n\n//# sourceURL=webpack://math/./src/nodes/Reduction.js?");

/***/ }),

/***/ "./src/nodes/Ruleset.js":
/*!******************************!*\
  !*** ./src/nodes/Ruleset.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\n\r\nfunction Ruleset({axiomatic, name, native, doc}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tthis.doc = doc;\r\n\r\n\tif (typeof name != 'string')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (!native)\r\n\t\tthrow this.error('Assertion failed');\r\n\t\r\n\tthis.axiomatic = axiomatic;\r\n\tthis.name = name;\r\n\tthis.native = native || false;\r\n}\r\n\r\nRuleset.prototype = Object.create(Node.prototype);\r\nRuleset.prototype.constructor = Ruleset;\r\nRuleset.prototype._type = 'ruleset';\r\n\r\nRuleset.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nRuleset.prototype.toIndentedString = function (indent) {\r\n\treturn `RS ${this.name}`\r\n\t\t+ (this.native ? ' <native>' : ' <error>');\r\n};\r\n\r\nRuleset.prototype.toTeXString = function (prec, root) {\r\n\treturn `\\\\href{#ruleset-${this.name}}{\\\\mathsf{${this.escapeTeX(this.name)}}}`\r\n\t\t+ (this.native ? '\\\\ (\\\\textrm{native})' : '\\\\ (\\\\textit{error})');\r\n};\r\n\r\nmodule.exports = Ruleset;\n\n//# sourceURL=webpack://math/./src/nodes/Ruleset.js?");

/***/ }),

/***/ "./src/nodes/Schema.js":
/*!*****************************!*\
  !*** ./src/nodes/Schema.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar MetaType = __webpack_require__(/*! ./MetaType */ \"./src/nodes/MetaType.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ../ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nfunction Schema({axiomatic, /* nullable */ name, native, params, expr, doc}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tthis.doc = doc;\r\n\r\n\tif (typeof axiomatic != 'boolean') {\r\n\t\tthrow this.error('Assertion failed');\r\n\t}\r\n\r\n\tif (name !== null && typeof name != 'string')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (!native && !['type', 'metatype'].includes(expr.type._type)) {\r\n\t\tthrow this.error('Assertion failed');\r\n\t}\r\n\r\n\tthis.axiomatic = axiomatic;\r\n\tthis.name = name;\r\n\r\n\tif (native) {\r\n\t\tthis.native = native;\r\n\t\tthis.expr = null;\r\n\t\tthis.type = null;\r\n\t} else {\r\n\t\tif (!(params instanceof Array)\r\n\t\t\t\t|| params.map(e => e._type == 'typevar').some(e => !e))\r\n\t\t\tthrow this.error('Assertion failed');\r\n\r\n\t\tthis.params = params;\r\n\t\tthis.expr = expr;\r\n\t\tthis.type = new MetaType({\r\n\t\t\tfunctional: true,\r\n\t\t\tfrom: params.map(typevar => typevar.type),\r\n\t\t\tto: expr.type\r\n\t\t});\r\n\t}\r\n}\r\n\r\nSchema.prototype = Object.create(Node.prototype);\r\nSchema.prototype.constructor = Schema;\r\nSchema.prototype._type = 'schema';\r\n\r\nSchema.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nSchema.prototype.toIndentedString = function (indent) {\r\n\tif (this.native)\r\n\t\treturn `∫ ${this.name} <native>`;\r\n\r\n\treturn [\r\n\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\r\n\t\t'\\t' + this.expr.toIndentedString(indent + 1),\r\n\t\t'}'\r\n\t].join('\\n' + '\\t'.repeat(indent));\r\n};\r\n\r\nSchema.prototype.toTeXString = function (prec, root) {\r\n\tif (!this.name) {\r\n\t\tthis.precedence = this.PREC_FUNEXPR;\r\n\t\treturn [\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t\t(\r\n\t\t\t\tthis.params.length == 1\r\n\t\t\t\t? this.params[0].toTeXString()\r\n\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')}\\\\right)`\r\n\t\t\t),\r\n\t\t\t`\\\\mapsto ${this.expr.toTeXString(false)}`,\r\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t\t].join('');\r\n\t}\r\n\r\n\tif (!root)\r\n\t\treturn `\\\\href{#schema-${this.name}}\\\\mathsf{${this.escapeTeX(this.name)}}`;\r\n\r\n\tif (this.native)\r\n\t\treturn `\\\\href{#schema-${this.name}}{\\\\mathsf{${this.escapeTeX(this.name)}}}`\r\n\t\t\t+ '\\\\ (\\\\textrm{native})';\r\n\r\n\treturn `\\\\href{#schema-${this.name}}{\\\\mathsf{${this.escapeTeX(this.name)}}}(${this.params.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')}):`\r\n\t\t\t\t+ '\\\\\\\\\\\\quad' + ExpressionResolver.expandMetaAndFuncalls(this.expr).toTeXString(true);\r\n};\r\n\r\nmodule.exports = Schema;\n\n//# sourceURL=webpack://math/./src/nodes/Schema.js?");

/***/ }),

/***/ "./src/nodes/Schemacall.js":
/*!*********************************!*\
  !*** ./src/nodes/Schemacall.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar Typevar = __webpack_require__(/*! ./Typevar */ \"./src/nodes/Typevar.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ../ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nfunction Schemacall({schema, args}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tif (!schema) {\r\n\t\tthrow this.error('Assertion failed');\r\n\t}\r\n\r\n\tif (!(args instanceof Array))\r\n\t\tthrow this.error('Assertion failed');\r\n\t\r\n\tthis.schema = schema;\r\n\tthis.args = args;\r\n\r\n\tvar paramTypes = schema.type.from,\r\n\t\targTypes = args.map(e => e.type);\r\n\r\n\tif (paramTypes.length != argTypes.length)\r\n\t\tthrow this.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`);\r\n\r\n\tfor (var i = 0; i < paramTypes.length; i++) {\r\n\t\tif (!paramTypes[i].equals(argTypes[i]))\r\n\t\t\tthrow this.error(`Illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`);\r\n\t}\r\n\r\n\tthis.type = schema.type.to;\r\n\r\n\tthis.expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n}\r\n\r\nSchemacall.prototype = Object.create(Node.prototype);\r\nSchemacall.prototype.constructor = Schemacall;\r\nSchemacall.prototype._type = 'schemacall';\r\n\r\nSchemacall.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nSchemacall.prototype.toIndentedString = function (indent) {\r\n\tvar args = this.args.map(arg => {\r\n\t\tif (arg instanceof Typevar) return arg.name;\r\n\t\treturn arg.toIndentedString(indent + 1);\r\n\t});\r\n\r\n\tif (args.join('').length <= 50) {\r\n\t\targs = this.args.map(arg => {\r\n\t\t\tif (arg instanceof Typevar) return arg.name;\r\n\t\t\treturn arg.toIndentedString(indent);\r\n\t\t});\r\n\r\n\t\targs = args.join(', ');\r\n\r\n\t\treturn [\r\n\t\t\t`${this.schema.name}(`,\r\n\t\t\targs,\r\n\t\t\t')'\r\n\t\t].join('');\r\n\t}\r\n\telse {\r\n\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\r\n\r\n\t\treturn [\r\n\t\t\t`${this.schema.name}(`,\r\n\t\t\t'\\t' + args,\r\n\t\t\t')'\r\n\t\t].join('\\n' + '\\t'.repeat(indent));\r\n\t}\r\n};\r\n\r\nSchemacall.prototype.toTeXString = function (prec, root) {\r\n\treturn (\r\n\t\tthis.schema.name\r\n\t\t\t? `\\\\href{#schema-${this.schema.name}}{\\\\textsf{${this.escapeTeX(this.schema.name)}}}`\r\n\t\t\t: this.schema.toTeXString(false)\r\n\t) + `(${this.args.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')})`;\r\n};\r\n\r\nmodule.exports = Schemacall;\n\n//# sourceURL=webpack://math/./src/nodes/Schemacall.js?");

/***/ }),

/***/ "./src/nodes/Tee.js":
/*!**************************!*\
  !*** ./src/nodes/Tee.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\nvar MetaType = __webpack_require__(/*! ./MetaType */ \"./src/nodes/MetaType.js\");\r\n\r\nvar ExpressionResolver = __webpack_require__(/*! ../ExpressionResolver */ \"./src/ExpressionResolver.js\");\r\n\r\nfunction Tee({left, right}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tif (!(left instanceof Array\r\n\t\t\t&& left.every(l => ['type', 'metatype'].includes(l.type._type)))) {\r\n\t\tconsole.log(left);\r\n\t\tthrow this.error('Assertion failed');\r\n\t}\r\n\r\n\tif (!['type', 'metatype'].includes(right.type._type)) {\r\n\t\tconsole.log(right);\r\n\t\tthrow this.error('Assertion failed');\r\n\t}\r\n\r\n\tif (right.type.isFunctional) {\r\n\t\tthrow this.error('RHS of a rule cannot be a schema');\r\n\t}\r\n\r\n\t// antecedent의 contraction\r\n\t// 현재 antecedent를 집합처럼 생각하므로 contraction을 자동으로 한다.\r\n\t// antecedent가 집합인지 시퀀스인지는 #14 참조.\r\n\tthis.left = left.reduce((l, r) => {\r\n\t\tfor (var i = 0; i < l.length; i++)\r\n\t\t\tif (ExpressionResolver.equals0(l[i], r)) return l;\r\n\r\n\t\treturn l.push(r), l;\r\n\t}, []);\r\n\r\n\tthis.right = right;\r\n\r\n\tthis.type = new MetaType({\r\n\t\tfunctional: false,\r\n\t\tleft: left.map(e => e.type),\r\n\t\tright: right.type\r\n\t});\r\n}\r\n\r\nTee.prototype = Object.create(Node.prototype);\r\nTee.prototype.constructor = Tee;\r\nTee.prototype._type = 'tee';\r\nTee.prototype.precedence = Node.prototype.PREC_COMMA;\r\n\r\nTee.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nTee.prototype.toIndentedString = function (indent) {\r\n\tif (!this.left.length) {\r\n\t\treturn '|- ' + this.right.toIndentedString(indent);\r\n\t}\r\n\r\n\treturn [\r\n\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\r\n\t\t'|-',\r\n\t\t'\\t' + this.right.toIndentedString(indent + 1)\r\n\t].join('\\n' + '\\t'.repeat(indent));\r\n};\r\n\r\nTee.prototype.toTeXString = function (prec, root) {\r\n\tvar expanded = ExpressionResolver.expandMetaAndFuncalls(this);\r\n\r\n\treturn [\r\n\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\r\n\t\t`{${expanded.left.map(e => e.toTeXString(this.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(this.PREC_COMMA)}}`,\r\n\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\r\n\t].join('');\r\n};\r\n\r\nmodule.exports = Tee;\n\n//# sourceURL=webpack://math/./src/nodes/Tee.js?");

/***/ }),

/***/ "./src/nodes/Type.js":
/*!***************************!*\
  !*** ./src/nodes/Type.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\n\r\nfunction Type(o) {\r\n\tNode.call(this);\r\n\r\n\tthis.doc = o.doc;\r\n\tthis.isBaseType = !!o.base;\r\n\r\n\tif (o.origin) {\r\n\t\tif (typeof o.name != 'string')\r\n\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\tthis.name = o.name;\r\n\r\n\t\tif (!(o.origin instanceof Type))\r\n\t\t\tthrow this.error('!(o.origin instanceof Type)');\r\n\r\n\t\tthis.isFunctional = o.origin.isFunctional;\r\n\t\tthis.isSimple = o.origin.isSimple;\r\n\t\tthis.origin = o.origin;\r\n\t} else {\r\n\t\tif (typeof o.functional != 'boolean')\r\n\t\t\tthrow this.error('typeof o.functional != \\'boolean\\'');\r\n\t\tthis.isFunctional = o.functional;\r\n\t\tthis.isSimple = !o.functional;\r\n\r\n\t\tif (!o.functional) {\r\n\t\t\tif (typeof o.name != 'string')\r\n\t\t\t\tthrow this.error('typeof o.name != \\'string\\'');\r\n\t\t\tthis.name = o.name;\r\n\t\t} else {\r\n\t\t\tif (o.from.map(f => f instanceof Type).some(e => !e))\r\n\t\t\t\tthrow this.error('o.from.map(f => f instanceof Type).some(e => !e)');\r\n\t\t\tif (!(o.to instanceof Type))\r\n\t\t\t\tthrow this.error('!(o.to instanceof Type)');\r\n\r\n\t\t\tthis.from = o.from;\r\n\t\t\tthis.to = o.to;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nType.prototype = Object.create(Node.prototype);\r\nType.prototype.constructor = Type;\r\nType.prototype._type = 'type';\r\n\r\nType.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\nType.prototype.toSimpleString = function () {\r\n\tif (this.name) return this.name;\r\n\r\n\tvar resolved = this.resolve();\r\n\r\n\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\r\n};\r\n\r\nType.prototype.toIndentedString = function (indent) {\r\n\tif (this.isSimple) return this.name;\r\n\r\n\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\r\n};\r\n\r\nType.prototype.toTeXString = function (root) {\r\n\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\r\n\tif (!root && this.name) {\r\n\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\r\n\t}\r\n\r\n\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\r\n\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\r\n\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\r\n};\r\n\r\nType.prototype.resolve = function () {\r\n\treturn this.origin ? this.origin.resolve() : this;\r\n};\r\n\r\nType.prototype.equals = function (t) {\r\n\tif (!(t instanceof Type)) return false;\r\n\r\n\tif (this.origin) return this.origin.equals(t);\r\n\tif (t.origin) return this.equals(t.origin);\r\n\r\n\tif (this.isSimple != t.isSimple) return false;\r\n\r\n\tif (this.isSimple) return this === t;\r\n\r\n\tif (this.from.length != t.from.length) return false;\r\n\r\n\tfor (var i = 0; i < this.from.length; i++)\r\n\t\tif (!this.from[i].equals(t.from[i])) return false;\r\n\r\n\treturn this.to.equals(t.to);\r\n};\r\n\r\nmodule.exports = Type;\n\n//# sourceURL=webpack://math/./src/nodes/Type.js?");

/***/ }),

/***/ "./src/nodes/Typevar.js":
/*!******************************!*\
  !*** ./src/nodes/Typevar.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Node = __webpack_require__(/*! ./Node */ \"./src/nodes/Node.js\");\r\n\r\nfunction Typevar({type, isParam, guess, name, doc, tex}, scope, trace) {\r\n\tNode.call(this, trace);\r\n\r\n\tthis.doc = doc;\r\n\tthis.tex = tex;\r\n\r\n\tthis.isParam = !!isParam;\r\n\tthis.guess = guess || null;\r\n\r\n\tif (type._type != 'type')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tif (typeof name != 'string')\r\n\t\tthrow this.error('Assertion failed');\r\n\r\n\tthis.type = type;\r\n\tthis.name = name;\r\n}\r\n\r\nTypevar.prototype = Object.create(Node.prototype);\r\nTypevar.prototype.constructor = Typevar;\r\nTypevar.prototype._type = 'typevar';\r\n\r\nTypevar.prototype.toString = function () {\r\n\treturn this.toIndentedString(0);\r\n};\r\n\r\n// pr f\r\nTypevar.prototype.toSimpleString = function () {\r\n\treturn this.type.toSimpleString() + ' ' + this.name;\r\n};\r\n\r\nTypevar.prototype.toIndentedString = function (indent, root) {\r\n\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\r\n};\r\n\r\nTypevar.prototype.toTeXString = function (prec, root) {\r\n\tvar id = this.isParam ? `id-${this._id}` : `def-${this.name}`;\r\n\r\n\tvar tex = this.tex\r\n\t\t|| (\r\n\t\t\tthis.name.length == 1\r\n\t\t\t\t? this.escapeTeX(this.name)\r\n\t\t\t\t: `\\\\mathrm{${this.escapeTeX(this.name)}}`\r\n\t\t);\r\n\t\r\n\treturn `\\\\href{#${id}}{${tex}}`;\r\n};\r\n\r\nmodule.exports = Typevar;\n\n//# sourceURL=webpack://math/./src/nodes/Typevar.js?");

/***/ })

/******/ });